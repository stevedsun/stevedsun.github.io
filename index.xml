<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>電波障害</title><link>https://sund.site/</link><description>Recent content on 電波障害</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 18 Sep 2022 17:01:29 +0800</lastBuildDate><atom:link href="https://sund.site/index.xml" rel="self" type="application/rss+xml"/><item><title>边缘计算模式——数据管道</title><link>https://sund.site/posts/2022/pattern-of-edge-computing-data-pipeline/</link><pubDate>Sun, 18 Sep 2022 17:01:29 +0800</pubDate><guid>https://sund.site/posts/2022/pattern-of-edge-computing-data-pipeline/</guid><description>&lt;h2 id="问题">问题&lt;/h2>
&lt;p>在物联网多层架构设计的中，数据从终端设备流向云端，应该在哪一层做数据处理，哪一层做数据展示？分层的依据是什么？&lt;/p>
&lt;h2 id="解决方案">解决方案&lt;/h2>
&lt;h3 id="架构设计">架构设计&lt;/h3>
&lt;p>边缘计算的三层数据管道。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>数据源&lt;/strong>是由若干终端设备组成的，内置在设备中的 agent 负责采集设备的基础数据如 cpu，内存使用量，应用统计数据等。&lt;/li>
&lt;li>&lt;strong>Edge（边缘）节点&lt;/strong>主要负责数据的处理，如 InfluxDB 通常设置在中间这一层。&lt;/li>
&lt;li>&lt;strong>Cloud（云端）节点&lt;/strong>是地理位置无关的，有容灾和扩展能力的云端服务层，因为边缘节点的硬件限制，扩展性不如云端，因此通常经过加工的数据从边缘节点发送到云端做持久化和数据展示。云端节点也负责一部分复杂数据的加工和聚合。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/13c5369a09c98c9d3bc40694052db3e.jpg" alt="">&lt;/p>
&lt;h2 id="edge-层">Edge 层&lt;/h2>
&lt;p>Edge 层的通常由一个 &lt;strong>gateway（网关）&lt;/strong>，数据处理服务，存储服务和若干的应用服务组成。因为硬件和维护的限制，Edge 层通常安装的服务数量和分配的资源有限。它主要负责数据的轻量级加工和聚合，减少从 Edge 层到 Cloud 层之间数据传输的带宽，同时快速地监控、反馈问题给终端设备。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/edge-computing--edge-node.png" alt="">&lt;/p>
&lt;h3 id="gateway">Gateway&lt;/h3>
&lt;p>Gateway 通常要求能够根据终端设备数据自适应扩展。通常 gateway 还有设备 ID 识别，权限认证等功能。对于数据量较大的场景，gateway 需要缓存认证服务的状态，防止并发过大导致认证服务崩溃。&lt;/p>
&lt;h3 id="data-processors">Data processors&lt;/h3>
&lt;p>数据处理服务负责对终端发来的数据根据各种指标计算出复合指标存储到数据库或者数据仓库中。通常这一层会设置一个消息队列 MQ，如 Kafka，但是仍然因为 Edge 层设备资源的限制，消息队列最好是系统级别共享的并且能够缓存一段时期的数据，之后数据消费者（应用服务）可以根据自身需要订阅数据流。&lt;/p>
&lt;p>常用的时序数据库，如 InfluxDB，内置了 Task 功能，将数据处理和存储合二为一。大大简化了这一层的开发工作。&lt;/p>
&lt;h3 id="system-services--storage">System Services &amp;amp; Storage&lt;/h3>
&lt;p>这一层由数据库和若干系统服务组成。向上层提供系统级别的 API 和数据。值得注意的是，数据库通常不会存储长期数据，因为 Edge 层存储容量的限制和不易扩展的特性，会给数据库设置 &lt;strong>retention period&lt;/strong> 参数，令过期数据自动销毁或通过定时任务&lt;strong>Downloadsampling（降采样）&lt;/strong>。&lt;/p>
&lt;p>系统服务一般由认证服务、数据 API、设备管理 API 等服务组成，这一层需要完成对设备的注册发现和管理。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>以上就是对边缘计算的三层架构的概述和 Edge 层的设计。根据工作中的实际情况，应该重点关注几方面的问题：&lt;/p>
&lt;ul>
&lt;li>Edge 层的扩展性，当设备数据急速增长时是否有能力应对。&lt;/li>
&lt;li>Edge 层的服务拆分和数据持久化策略。因为部署环境和性能的限制，开发人员并不能像 Cloud 端开发一样快速响应 Edge 节点的情况，因此 Edge 层最考验开发者根据实际用户场景调参，自动化扩展、恢复的能力。&lt;/li>
&lt;/ul></description></item><item><title>边缘计算模式——任务队列</title><link>https://sund.site/posts/2022/pattern-of-edge-computing-lock/</link><pubDate>Wed, 14 Sep 2022 08:46:21 +0800</pubDate><guid>https://sund.site/posts/2022/pattern-of-edge-computing-lock/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>在边缘计算中，边缘节点通常介于终端节点和云端节点之间，它的扩展性也介于两者之间。对于高并发或是高资源占用的业务场景，应该如何设计边缘节点的策略。&lt;/p>
&lt;h2 id="问题">问题&lt;/h2>
&lt;p>在边缘计算中，对于那些占用 CPU 和内存资源较大的请求，什么时候应该加锁？&lt;/p>
&lt;h2 id="解决方案">解决方案&lt;/h2>
&lt;p>边缘计算中有三类节点：终端节点（device），边缘节点（edge）,云端节点（cloud）。&lt;/p>
&lt;ul>
&lt;li>终端节点：通常应该加锁限制高资源占用。因为终端设备往往资源紧张，不可扩展。&lt;/li>
&lt;li>云端节点：通常不需要加锁，而是扩展副本。&lt;/li>
&lt;/ul>
&lt;p>对于情况比较复杂的边缘节点，通常要综合考虑当前系统资源分配策略和用户使用场景。&lt;/p>
&lt;h3 id="一般情况">一般情况&lt;/h3>
&lt;p>对于工业物联网环境，边缘节点的操作员通常较少，同一时间进行的操作不多，在这种情况下可以采用加锁的方式来限制资源占用。&lt;/p>
&lt;h3 id="最佳实践全局任务队列">最佳实践——全局任务队列&lt;/h3>
&lt;p>对于多用户或者并发稍高的情况，边缘节点可以实现全局的任务队列来缓解高资源占用的任务给系统造成的负担。在应用的架构设计上，应该将高资源占用的请求以事件形式发送到全局任务队列，由边缘节点系统统一调度这些任务，按顺序或特定的优先级依次执行。&lt;/p>
&lt;p>对于任务队列已满的情况，再考虑扩展应用服务副本数量。&lt;/p></description></item><item><title>规范的错误信息</title><link>https://sund.site/posts/2022/write-error-message/</link><pubDate>Tue, 23 Aug 2022 22:18:00 +0800</pubDate><guid>https://sund.site/posts/2022/write-error-message/</guid><description>&lt;p>本文整理了 Google 官方文档中关于错误信息的编写规范。适用于有一定编程经验，尤其从事业务开发的程序员。&lt;/p>
&lt;p>通过本文你可以：&lt;/p>
&lt;ul>
&lt;li>写出风格统一、用户友好的错误信息&lt;/li>
&lt;li>提高代码的可维护性，降低沟通成本&lt;/li>
&lt;/ul>
&lt;p>Google 文档原文：&lt;a href="https://developers.google.com/tech-writing/error-messages">Error Messages&lt;/a>&lt;/p>
&lt;h2 id="基本原则">基本原则&lt;/h2>
&lt;ul>
&lt;li>错误不应该被掩盖 (Don&amp;rsquo;t fail silently)&lt;/li>
&lt;li>遵循语言的规范 (Follow the programming language guides)&lt;/li>
&lt;li>实现完整的错误模型 (Implement the full error model)
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">包含错误码、错误内容、错误原因、处理方法
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>避免吞掉问题根源 (Avoid swallowing the root cause)&lt;/li>
&lt;li>输出错误代码 (Log the error codes)&lt;/li>
&lt;li>快速抛出错误 (Raise errors immediately)&lt;/li>
&lt;/ul>
&lt;h2 id="解释错误原因">解释错误原因&lt;/h2>
&lt;p>使用错误信息给用户解释原因时，应该遵循：&lt;/p>
&lt;ul>
&lt;li>具体，准确，避免含糊。&lt;/li>
&lt;li>在错误信息中包含用户输入的错误内容。如果输入的内容特别长：
&lt;ul>
&lt;li>渐进地显示，提供一个可展开详情的省略号。&lt;/li>
&lt;li>截断内容，只保留必要部分。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>明确告诉用户，系统的要求和限制&lt;/li>
&lt;/ul>
&lt;h2 id="解释如何处理问题">解释如何处理问题&lt;/h2>
&lt;ul>
&lt;li>对用户来说，错误信息必须有可操作性。也就是说，在解释了问题的原因后，说明如何解决这个问题。&lt;/li>
&lt;li>最好给用户提供一个例子。&lt;/li>
&lt;/ul>
&lt;h2 id="清晰的错误信息">清晰的错误信息&lt;/h2>
&lt;ul>
&lt;li>简明扼要，使用主动语态。（这方面内容可以参考&lt;a href="https://sund.site/posts/2022/technical-writing/">技术文档写作指南&lt;/a>）&lt;/li>
&lt;li>避免出现双重否定句式。&lt;/li>
&lt;li>让目标用户能够理解，即根据用户掌握的知识，提供有帮助的内容。&lt;/li>
&lt;li>专业术语应前后一致。&lt;/li>
&lt;/ul>
&lt;h2 id="错误信息的格式">错误信息的格式&lt;/h2>
&lt;ul>
&lt;li>使用链接提供更多信息。&lt;/li>
&lt;li>渐进式呈现错误信息（比如可以展开详情的省略号）。&lt;/li>
&lt;li>错误提示应该贴近错误发生的位置。&lt;/li>
&lt;li>避免错误信息滥用字体或颜色。&lt;/li>
&lt;li>使用正确的语气:
&lt;ul>
&lt;li>不要告诉用户错在哪，告诉用户应该做什么。&lt;/li>
&lt;li>避免责备、幽默、道歉的语气。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="对后端开发的建议">对后端开发的建议&lt;/h2>
&lt;ul>
&lt;li>错误要有错误码&lt;/li>
&lt;li>可以在错误信息结构里提供一个指向错误解释的 ID，如：
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;error&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Bad Request - Request is missing a required parameter: -collection_name. Update parameter and resubmit. Issue Reference Number BR0x0071&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul></description></item><item><title>技术文档写作指南</title><link>https://sund.site/posts/2022/technical-writing/</link><pubDate>Sun, 21 Aug 2022 15:29:00 +0800</pubDate><guid>https://sund.site/posts/2022/technical-writing/</guid><description>&lt;p>本文内容摘录自 &lt;a href="https://developers.google.com/tech-writing/overview">Technical Writing&lt;/a> （谷歌技术文档写作指南）的第一部分。&lt;/p>
&lt;p>本文适用于想要提高技术文档写作、技术领域日常沟通能力的读者，对于一些商务的、非文学性质的英语办公场景沟通，也能起一定帮助作用。&lt;/p>
&lt;p>阅读过本文的读者可以：&lt;/p>
&lt;ul>
&lt;li>提高在日常办公中清晰、准确、客观地传达概念和逻辑的能力。&lt;/li>
&lt;li>掌握英文技术文档写作规范。&lt;/li>
&lt;/ul>
&lt;h2 id="词汇words">词汇（Words）&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>对于已有的术语，不要重复发明新的词汇，可以用一个链接指向解释它的页面。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果有必要，可以在文档中直接定义新的术语，但如果术语比较多，最好建立一个术语对照表。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>文档各处出现的术语应该保持一致的名称或缩写。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>关于缩写：第一次出现要用&lt;strong>粗体&lt;/strong>写全称并用括号指明缩写，之后的文章中不要反复混用全称和缩写。正确的例子：&lt;/p>
&lt;blockquote>
&lt;p>This document is for engineers who are new to the &lt;strong>Telekinetic Tactile Network&lt;/strong> (&lt;strong>TTN&lt;/strong>) or need to understand how to order TTN replacement parts through finger motions.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>如果一个术语出现频率不高，请不要使用缩写。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用缩写的情况有：1. 缩写明显更简短；2. 该术语出现频率很高。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>谨慎使用代名词（It，they，that 等）。&lt;/p>
&lt;ul>
&lt;li>代名词一定要出现在它所指代的名词之后。&lt;/li>
&lt;li>如果代名词远离它指代的名词（超过 5 个单词），就不用代名词。&lt;/li>
&lt;li>在名词和代名词之间出现第二个名词，会产生歧义，应避免这种情况。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>类比计算机编程语言：&lt;/p>
&lt;p>缩写 = 对术语的一层抽象。读者需要花费更多脑力去把它展开成对应的名词。&lt;/p>
&lt;p>代名词 = 指针。它容易引起歧义，所以要避免在读者大脑中引起「空指针」错误。&lt;/p>
&lt;h2 id="主动语态active-voice">主动语态（Active voice）&lt;/h2>
&lt;ul>
&lt;li>技术文档中应尽量使用主动语态。
&lt;ul>
&lt;li>被动语态在读者大脑中需要额外的加工转换才能被理解。&lt;/li>
&lt;li>被动语态用来间接地表达行为，容易引起混乱。&lt;/li>
&lt;li>有些被动语态省略了行为主体，会迫使读者猜测主语是谁。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果使用被动语态，应正确使用过去分词的各种形式和介词（如 as，by）。&lt;/li>
&lt;li>祈使句的动词（命令式动词）应该使用主动语态。&lt;/li>
&lt;li>科技论文中经常出现被动语态（如 It has been suggested that&amp;hellip;），这种写法并不能传递更多信息，很多科学期刊也开始鼓励使用主动语态。&lt;/li>
&lt;/ul>
&lt;h2 id="炼句clear-sentencesshort-sentences">炼句（Clear sentences，Short sentences）&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>选择准确、有力、具体的动词。减少不精确的、软弱的或通用的动词。
不好的例子： is，are，occur，happen&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/Untitled.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Be 动词和通用动词可以用，但它们通常是一些不良写作习惯的信号，如&lt;/p>
&lt;ul>
&lt;li>句子中缺少行为主体&lt;/li>
&lt;li>句子使用了被动语态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>减少 there be 句式，把 there be 句式中的主语和动词提炼出来，如&lt;/p>
&lt;blockquote>
&lt;p>避免这样用：There is no guarantee that the updates will be received in sequential order.
应改为：Clients might not receive the updates in sequential order.&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>尽量少用或不用形容词和副词，因为这些词汇过于主观。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>尽量使用短的句子。短句比长句更易读、易维护、不易犯错。&lt;/p>
&lt;ul>
&lt;li>每一个句子只表达一个观点。&lt;/li>
&lt;li>长句尽量转换成列表。&lt;/li>
&lt;li>用简洁表达，去掉多余的词汇，如
&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/Untitled%201.png" alt="">&lt;/li>
&lt;li>减少从句。&lt;/li>
&lt;li>正确区分 that 和 which 从句。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="列表和表格lists-and-tables">列表和表格（Lists and tables）&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>正确区分有序列表（数字列表，numbered lists）和无序列表（圆点列表，bulleted lists）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>把句内列举的项（embedded list）转换成无序列表，如：&lt;/p>
&lt;blockquote>
&lt;p>The llamacatcher API enables callers to create and query llamas, analyze alpacas, delete vicugnas, and track dromedaries.
换成：
The llamacatcher API enables callers to do the following:&lt;/p>
&lt;ul>
&lt;li>Create and query llamas.&lt;/li>
&lt;li>Analyze alpacas.&lt;/li>
&lt;li>Delete vicugnas.&lt;/li>
&lt;li>Track dromedaries.&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>保持列表项之间的平行关系（避免把不同层级的东西混在一列）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在使用有序列表时，用一个命令式动词开头，如：&lt;/p>
&lt;blockquote>
&lt;p>好的例子：&lt;/p>
&lt;ol>
&lt;li>Download the Frambus app from Google Play or iTunes.&lt;/li>
&lt;li>Configure the Frambus app&amp;rsquo;s settings.&lt;/li>
&lt;li>Start the Frambus app.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>只有列表每一个项都是句子时，才使用首字母大写和句号，否则不需要。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>使用表格应遵循的原则：&lt;/p>
&lt;ul>
&lt;li>每列都有标题&lt;/li>
&lt;li>单元格字数尽量少&lt;/li>
&lt;li>尽量保证每一列的数据类型相同&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>表格或列表的前面，用一句话来介绍上下文&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="段落paragraphs">段落（Paragraphs）&lt;/h2>
&lt;ul>
&lt;li>以中心句开头。&lt;/li>
&lt;li>每段只围绕一个主题写作，不要包含其他段落中出现的主题内容。&lt;/li>
&lt;li>三到五句话一段，不要超过七句。&lt;/li>
&lt;li>段落能够解释清楚三件事： what，why，how。&lt;/li>
&lt;/ul>
&lt;h2 id="读者audience">读者（Audience）&lt;/h2>
&lt;blockquote>
&lt;p>好的文档 = 读者要完成任务所需的知识和技能 - 读者已有的知识和技能&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>定义读者的身份（开发者、科学家、技术经理、未毕业的工程专业学生、毕业生、非技术人员……）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>了解目标读者对不同知识的掌握程度。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>确定读者需要什么，读过文档能学到什么。比如在设计规范开头这样写：&lt;/p>
&lt;blockquote>
&lt;p>After reading the design spec, the audience will learn the following: …&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>
&lt;p>满足读者：&lt;/p>
&lt;ul>
&lt;li>解释必要的词汇和概念。&lt;/li>
&lt;li>对新手友好。&lt;/li>
&lt;li>使用简单的英语词汇。&lt;/li>
&lt;li>对不同文化、语言环境的读者友好，避免使用成语或俗语。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="文档documents">文档（Documents）&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>声明文档的适用场景（scope）。&lt;/p>
&lt;ul>
&lt;li>最好能声明哪些场景不适用（non-scope），不适合哪些读者阅读。这不仅对读者有用，对写作者也能限制其写作的范围。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>声明目标读者。&lt;/p>
&lt;ul>
&lt;li>最好能指出读者在阅读前应该具备的知识和经验。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>在开头部分概括文档的关键点&lt;/p>
&lt;ul>
&lt;li>可以通过比较、对比旧观点的手法，让读者明白你要表达的新观点。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>按读者需要组织文档格式。&lt;/p>
&lt;blockquote>
&lt;p>一个好的大纲：&lt;/p>
&lt;ol>
&lt;li>Overview of the algorithm
&lt;ul>
&lt;li>Compare and contrast with quicksort, including Big O comparisons
&lt;ul>
&lt;li>Link to Wikipedia article on quicksort&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Optimal datasets for the algorithm&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Implementing the algorithm
&lt;ul>
&lt;li>Implementation in pseudocode&lt;/li>
&lt;li>Implementation tips, including common mistakes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Deeper analysis of algorithm
&lt;ul>
&lt;li>Edge cases&lt;/li>
&lt;li>Known unknowns&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;/li>
&lt;/ul>
&lt;h2 id="标点符号punctuation">标点符号（Punctuation）&lt;/h2>
&lt;blockquote>
&lt;p>Note:
这部分原文涉及英文标点符号的用法，大部分和汉语规则近似，略过不译。以下是我在排版方面的经验：
大多数中国人对英文排版易错的地方是空格的滥用。可以参考这篇文章： &lt;a href="https://zhuanlan.zhihu.com/p/110266694">英文标点要如何排版？&lt;/a>。概括起来：&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>&lt;code>, ; : . ? !&lt;/code> 这些符号后加空格&lt;/li>
&lt;li>&lt;code>() '' &amp;quot;&amp;quot;&lt;/code> 这些成对的符号左右加空格，内部不加空格&lt;/li>
&lt;li>&lt;code>/ - _&lt;/code>不加空格&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;ul>
&lt;li>统一使用术语。&lt;/li>
&lt;li>避免模棱两可的代名词。&lt;/li>
&lt;li>主动语态优于被动语态。&lt;/li>
&lt;li>选择具体的动词而不是模糊的动词。&lt;/li>
&lt;li>每句话集中在一个想法上。&lt;/li>
&lt;li>将一些长句子转化为列表。&lt;/li>
&lt;li>消除不必要的词。&lt;/li>
&lt;li>有顺序时使用有序（数字）列表，无顺序时使用无序（圆点）列表。&lt;/li>
&lt;li>保持列表项目平行（概念层次相同）。&lt;/li>
&lt;li>用祈使（命令性）的词作为有序列表项的开头。&lt;/li>
&lt;li>适当地介绍列表和表格。&lt;/li>
&lt;li>开宗明义，明确段落的中心点。&lt;/li>
&lt;li>将每一段落集中在一个主题上。&lt;/li>
&lt;li>确定你的读者需要学习什么。&lt;/li>
&lt;li>使文档适应读者。&lt;/li>
&lt;li>在文档的开头指出关键信息。&lt;/li>
&lt;/ul>
&lt;h2 id="延伸阅读资料">延伸阅读资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://docsfordevelopers.com/">Docs for Developers&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.oreilly.com/library/view/software-engineering-at/9781492082781/">Software Engineering at Google&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://about.gitlab.com/handbook/engineering/ux/technical-writing/fundamentals/">Gitlab Technical Writing Fundamentals courese&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>《分手的决心》细节分析</title><link>https://sund.site/posts/2022/decision_to_leave/</link><pubDate>Sun, 14 Aug 2022 17:01:56 +0800</pubDate><guid>https://sund.site/posts/2022/decision_to_leave/</guid><description>&lt;blockquote>
&lt;p>把那部手机丢进海里，让它陷入深处，没人能寻到。&lt;/p>
&lt;/blockquote>
&lt;p>看完《分手的决心》，我决心水一篇。今天跟大家一起分析分析电影里的细节。&lt;/p>
&lt;h2 id="影片开头的支线情节">影片开头的支线情节&lt;/h2>
&lt;p>电影的一开头，刑警张海俊在追查两起凶杀案。分别是知九洞杀人案和女主宋瑞莱（汤唯饰）丈夫坠山案。第一次看时令我不解的是，前一起案件看似和整个剧情毫无关系，为什么导演要花那么多时间讲一个支线故事呢。&lt;/p>
&lt;p>让我们回顾一下知九洞案：凶手洪山五曾经和女友吴佳人非常相爱，后来吴与小凡（后来的死者）偷情，得知被绿后的洪山五愤而刺死情敌。在刑警男主一番抓捕之后，洪山五被逼到天台边缘跳楼自杀。他在自杀前，特别希望转告女友吴佳人：「虽然我为了你受苦，但如果不是你，我的人生将是一场空」。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814134440634.png" alt="">&lt;/p>
&lt;p>这里印证了前面情节中，知九洞案另一位嫌疑犯，洪山五的朋友（李智久）的口供。&lt;/p>
&lt;blockquote>
&lt;p>他那个人，宁可自杀也不会回监狱，因为回忆太过美好。&lt;/p>
&lt;/blockquote>
&lt;p>这句话点出洪山五选择跳楼自杀的原因——当初和女友在一起时的美好回忆，令他陷在过去中，无法面对现实。&lt;/p>
&lt;p>这是整个故事的基调，也暗示了男女主人公的结局。&lt;/p>
&lt;p>而洪山五跳下的那栋楼，和女主丈夫奇都秀坠亡的那座山，在男主的俯视角镜头里形成了呼应。「山」在这里暗示了「稳固的关系」，洪山五为其而死，奇度秀被其所害。&lt;/p>
&lt;h2 id="正篇">正篇&lt;/h2>
&lt;p>下面是我画的一张主要人物关系图。如果忘了剧情可以参考一下。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/%E5%88%86%E6%89%8B%E7%9A%84%E5%86%B3%E5%BF%83%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="">&lt;/p>
&lt;h3 id="山与海的隐喻">山与海的隐喻&lt;/h3>
&lt;p>回到主线，女主宋瑞莱的名字里已经透露了重要的信息，「瑞」字里有「山」，男主张海俊的名字里有「海」。中文译者把线索藏在两位主角的名字里，其用心真是让我惊叹啊。另外故事里也反复出现「山海经」、水纹封面的笔记等元素。&lt;/p>
&lt;p>从女主宋瑞莱的角度看，片中反复出现她在「山」和「海」两种状态的摇摆。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814140654675.png" alt="">&lt;/p>
&lt;p>第一次是在警局问话时，她提到「智者乐水，仁者乐山，我不是智者，所以我喜欢水」。这明显是撒谎，是为了解释她和丈夫吵架的借口。因为在后面情节中，她反复提到她的母亲在临死前跟她说「去找你姥爷在韩国老家的山吧」。这里出现的山，并不仅仅是现实中的锄头山，也是女主心里追寻的山。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814140952601.png" alt="">&lt;/p>
&lt;p>而后半段中，女主和男主两人在雪中爬上锄头山之后，女主说，「母亲告诉我，去韩国吧，去那里就有这座山」。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814141046727.png" alt="">&lt;/p>
&lt;p>可见，女主身世坎坷，来到韩国后心中一直追寻稳定的依靠，母亲的话冥冥中指引她「去那里吧，那里有你的山」。可是到韩国后第一任丈夫的长期虐待，让宋瑞莱仇恨眼前的山，而把男主张海俊视作是可以真正依靠的山。&lt;/p>
&lt;p>而站在男主的视角，他的山，是枷锁。&lt;/p>
&lt;p>山稳固有形，水流动无形。男主刑警张海俊，有个在核电站工作、周末同房的妻子。两人的关系是稳固的，同时也是空洞的。男主经常夜里一个人去看海。而他的妻子对此不屑一顾。&lt;/p>
&lt;blockquote>
&lt;p>男主：要我说，我是大海的男子汉！&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>夫人：什么大海的男子汉，明明内陆才是故乡。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814142506839.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814142535311.png" alt="">&lt;/p>
&lt;p>男主想要逃避的是眼前的山，在他和女主相遇的一瞬间，他就清晰地知道，他们是同一类人。&lt;/p>
&lt;h3 id="两部手机">两部手机&lt;/h3>
&lt;p>故事的第一个高潮，男主发现女主作案的铁证之后，陷入因自己沉迷感情而丧失破案机会的「崩溃」中。男主戳穿宋瑞莱的作案过程之后，仍然选择抛弃自己的身份，和宋瑞莱成为共犯（可能已经是他人生剧本中早已经注定的安排），他对宋瑞莱说：&lt;/p>
&lt;blockquote>
&lt;p>把那部手机丢进海里，让它陷入深处，没人能寻到。&lt;/p>
&lt;/blockquote>
&lt;p>对于宋瑞莱来说，这句话击中了她心里最柔软的地方。当男主在她面前放弃了自己最重视的东西时，她发现自己也已经没有办法从这段关系里挣脱，她在男主离去后，留下一滴眼泪。&lt;/p>
&lt;p>讲到这里，电影里最重要的线索就是手机。片中一共有两部手机，第一部女主的红色手机记录了宋瑞莱杀死丈夫的线索，另一部第二任丈夫的手机，记录了男主保护宋瑞莱，掩盖杀人线索的录音。&lt;/p>
&lt;p>这两部手机的归宿也很耐人寻味。&lt;/p>
&lt;p>第一部手机（记录女主罪证），男主希望丢掉，却被女主保留下来。&lt;/p>
&lt;p>另一部手机（记录男主罪证）是宋瑞莱主动丢到大海里，但是被男主捞上来的。&lt;/p>
&lt;p>这两部犯罪的证据，成为双方为了保护对方，丢不掉的羁绊。&lt;/p>
&lt;p>故事的结局，宋瑞莱没有选择丢弃手机，而是带着这段回忆，和手机一起消失在无人知道的大海里。她在临别时说：&lt;/p>
&lt;blockquote>
&lt;p>海里捞出来的手机，你重新丢了吧，丢到更深的海里。&lt;/p>
&lt;/blockquote>
&lt;p>没有说出的话，大概是「忘了我吧，但是我会记得你」。&lt;/p>
&lt;h3 id="婚戒">婚戒&lt;/h3>
&lt;p>电影的另一个反复出现的线索是婚戒。&lt;/p>
&lt;p>影片里，男主与夫人羞羞之后，导演给了婚戒一个特写，男主有一个把婚戒握起来的小动作，暗示了男主和夫人之间看似恩爱的表面下，是双方都不愿意说破的冷漠。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814150620934.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814150634759.png" alt="">&lt;/p>
&lt;p>而在发生丈夫坠山事件之后，宋瑞莱在警察局审问中途去了一趟洗手间，她发现手上的婚戒没有戴，然后悄悄戴上了。也说明她似乎在掩饰着什么。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814150735689.png" alt="">&lt;/p>
&lt;p>在女主的第二任丈夫死后，男主押送女主的汽车上，男主的手上仍然有婚戒。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814150841261.png" alt="">&lt;/p>
&lt;p>但是片尾，两个人第二次同坐一辆车时，男主的婚戒已经消失了，而宋瑞莱的手紧紧握住了张海俊：&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814150918432.png" alt="">&lt;/p>
&lt;h3 id="乌鸦的羽毛">乌鸦的羽毛&lt;/h3>
&lt;p>另一个多次出现的暗示，是黑色羽毛。女主喂养的小猫为了报答主人，弄死了一只乌鸦叼到女主身边。这正是后半段女主杀夫护男主的伏笔。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814151043041.png" alt="">&lt;/p>
&lt;p>片中第二次和第三次出现乌鸦羽毛，分别在男主调查两任丈夫死亡线索时一闪而过。其实男主早就把两任丈夫的死亡，同女主紧紧绑定在一起了。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814151325447.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814151335869.png" alt="">&lt;/p>
&lt;h2 id="尾声">尾声&lt;/h2>
&lt;p>其实电影里还有很多细节，比如女主的很多韩语对白都是从电视剧里学的；宋瑞莱两任丈夫分别死在山上和水里；影片里的城市以「雾」闻名，而雾是介于有形和无形之间的东西……等等。&lt;/p>
&lt;p>最后送上汤唯的一段表情，宋瑞莱开车前往海边时，张海俊在电话里问她「我什么时候说过爱你？」，宋瑞莱在短短几秒钟内的四个眼神。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814151745062.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814151854912-16604615388562.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814151913303.png" alt="">&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/image-20220814151924590.png" alt="">&lt;/p></description></item><item><title>3 ways to access host system in Docker container</title><link>https://sund.site/posts/2022/3_ways_to_access_host_system_in_container/</link><pubDate>Mon, 08 Aug 2022 20:04:00 +0800</pubDate><guid>https://sund.site/posts/2022/3_ways_to_access_host_system_in_container/</guid><description>&lt;p>When we are using Docker, we always access the host system by mounting the host folders as a volume. But sometimes we can not do that due to deployment reasons or security limits.&lt;/p>
&lt;p>There are three workaround ways to access the host system.&lt;/p>
&lt;h2 id="1-mount-dockersocks-into-container">1. Mount &lt;code>docker.socks&lt;/code> into container&lt;/h2>
&lt;p>&lt;code>docker.socks&lt;/code> is a Unix socket that Docker Engine API listens on. You can mount &lt;code>/var/run/docker.socks&lt;/code> file to your container and call Docker Engine API through this socket.&lt;/p>
&lt;p>For instance, If I want to get docker information by calling that API:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">curl -s --unix-socket /var/run/docker.sock http://localhost/info
&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can refer to &lt;a href="https://docs.docker.com/engine/api/v1.41/">Docker Engine API&lt;/a> to find more useful details.&lt;/p>
&lt;h2 id="2-using-pid-mode-host">2. Using PID mode &lt;code>host&lt;/code>&lt;/h2>
&lt;p>By default, Docker uses the Linux PID namespace to isolate containers' filesystem view. It means if two processes have the same PID, they will share the filesystem permission.&lt;/p>
&lt;p>Docker has a startup parameter &lt;code>--pid=host&lt;/code> to change the PID namespace to its host process&amp;rsquo;s namespace. You can use this parameter to make your docker container have the same privilege as the host process.&lt;/p>
&lt;blockquote>
&lt;p>When using &lt;code>--pid=host&lt;/code>, you can list host system&amp;rsquo;s processes by &lt;code>ps -ef&lt;/code>.&lt;/p>
&lt;/blockquote>
&lt;h2 id="3-by-docker---privileged">3. By &lt;code>docker --privileged&lt;/code>&lt;/h2>
&lt;p>It is the last way you can access the host system, but it is not recommended for most cases.&lt;/p></description></item><item><title>品味和效率</title><link>https://sund.site/posts/2022/2022-08-04/</link><pubDate>Thu, 04 Aug 2022 07:59:00 +0800</pubDate><guid>https://sund.site/posts/2022/2022-08-04/</guid><description>&lt;p>早起又随性写点东西。&lt;/p>
&lt;p>最近朋友圈被转载很多的一篇文章，来自 GQ 实验室对重轻老师的采访。里面有一段关于品味的叙述：&lt;/p>
&lt;blockquote>
&lt;p>……审美的底层逻辑是能感受到那些细微差别。这本身是非常非常幸福的，是一个“自我奖励”的事；另一方面它只能通过大量的自我训练来实现，没法让别人嚼好了喂给你，就是得自己重复喝很多咖啡、听很多唱片、看很多电影，然后试图去分辨。这个过程不会很舒服，甚至挺累的，是一个苦活，一种「爱的苦工」。&lt;/p>
&lt;p>我相信审美、品味是值得向往的：“有品位”作为自我装点的标签没啥意义，是我们花费很多时间、经历大量摸索、甚至是克服了很多困难的那个过程，它很值得向往。&lt;/p>
&lt;/blockquote>
&lt;p>品味是需要心甘情愿付出劳动的。陈丹青有一次接受采访时说：&lt;/p>
&lt;blockquote>
&lt;p>年轻人装逼没什么不好的，我年轻时候就喜欢装逼……只是现在装成了。（笑）&lt;/p>
&lt;/blockquote>
&lt;p>「装成了」是结果，自我愉悦是过程，付出辛苦是前提。缺少任一条件，都是字面上的装逼。&lt;/p>
&lt;p>延申地说，可能不仅是欣赏文化作品，每一件跟赚钱无关的事，都能达成「装成了」的境界。当你不把追求效率放在第一位时，「付出劳动」就和「自我愉悦」挂钩了。&lt;/p>
&lt;p>另一件生活里的小事是，我发现那些工作很忙碌的人，往往是不追求效率的。真正追求工作效率的人，是为了解放时间留给业余生活，但是很多人只是沉迷工作本身，他们热爱这件事，能从中获得愉悦（或者满足感）。&lt;/p>
&lt;p>「追求效率」不是为了享受，其实是为了更好的逃离某种状态。比如你刷了一小时抖音，这就是追求效率，而不是享受，你是想逃离工作状态，想逃离手机以外的烦心事。你如果真想享受生活，躺在沙发上刷短视频满足不了你。&lt;/p>
&lt;p>有时候折腾效率软件也跟喝咖啡一样，效率（提神）只是这件事的副作用，它个寻找快乐的过程。真追求效率的人不在乎软件是什么，黑猫白猫抓住耗子就是好猫，这才是效率。&lt;/p>
&lt;p>最后奉上一张 Twitter 上的梗图。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/529f94b3bfab914f272c3a51adcd83e.jpg" alt="">&lt;/p></description></item><item><title>Notion as a dashboard</title><link>https://sund.site/posts/2022/using_notion_as_a_dashboard/</link><pubDate>Sun, 31 Jul 2022 21:01:56 +0800</pubDate><guid>https://sund.site/posts/2022/using_notion_as_a_dashboard/</guid><description>&lt;p>I have built a Chrome extension &lt;a href="https://chrome.google.com/webstore/detail/%E6%97%A0%E7%94%A8%E4%B8%BB%E6%84%8F%E6%A0%87%E7%AD%BE%E9%A1%B5/lieiofhdejclfpflofeooilpeaphlcgd?hl=zh-CN">无用主意&lt;/a> during the last month. The backend service implemented by Flask is using Notion as a dashboard.&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/20220731212027.png" alt="">&lt;/p>
&lt;h2 id="notion-api">Notion API&lt;/h2>
&lt;p>If you want your service to connect to Notion, you have to create a Notion integration on &lt;a href="https://www.notion.so/my-integrations">this page&lt;/a>. Afterward, you have to share a specific Notion page to the integration you just created.&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/20220731213331.png" alt="">&lt;/p>
&lt;p>Now, you can call &lt;a href="https://developers.notion.com/reference/intro">Notion API&lt;/a> to visit your page.&lt;/p>
&lt;p>Once the service has permission to write and read data to Notion, we can sync data between them.&lt;/p>
&lt;p>I&amp;rsquo;m using a &lt;code>status&lt;/code> column to let me know which row has been updated into the service&amp;rsquo;s SQLite database.&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/static/images/20220731212654.png" alt="">&lt;/p>
&lt;p>And also, I can update this row&amp;rsquo;s content, then mark &lt;code>status&lt;/code> as &amp;ldquo;To Update&amp;rdquo; to tell Flask service to sync this line later. At every night, Flask service sync data from Notion page to SQLite and marks &lt;code>status&lt;/code> as &amp;ldquo;Done&amp;rdquo;.&lt;/p>
&lt;p>In this way, I am making Notion as my backend service dashboard.&lt;/p></description></item><item><title>Building a file parser</title><link>https://sund.site/posts/2022/2022-5-8_lexer_design/</link><pubDate>Sun, 08 May 2022 14:00:00 +0800</pubDate><guid>https://sund.site/posts/2022/2022-5-8_lexer_design/</guid><description>&lt;p>Last week, after reading this article - &lt;a href="https://www.aaronraff.dev/blog/how-to-write-a-lexer-in-go">How to Write a Lexer in Go&lt;/a>, I found that it is not so difficult to design a configuration file parser by this article&amp;rsquo;s mind-set. Then I tried to write a fluent-bit configuration parser, finally got this &lt;a href="https://github.com/stevedsun/go-fluentbit-conf-parser">Fluent-Bit configuration parser for Golang&lt;/a>.&lt;/p>
&lt;p>In this article, I want to introduce how to parse Fluent-bit configuration &lt;code>.conf&lt;/code> file, and the thinking behind it.&lt;/p>
&lt;h2 id="fluent-bit-configuration-format-and-schema">Fluent-bit configuration format and schema&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">[FIRST_SECTION]
Key1 some value
Key2 another value
[SECOND_SECTION]
KeyN 3.14
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Here is a classic mode configuration of Fluent-bit, it includes two parts:&lt;/p>
&lt;ul>
&lt;li>Section&lt;/li>
&lt;li>Key/value pair&lt;/li>
&lt;/ul>
&lt;p>First of all, we need to define a struct which represents the Fluent-bit configuration file.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">type&lt;/span> &lt;span class="nx">FluentBitConf&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Sections&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">Section&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">Section&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nx">Entries&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">Entry&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kd">type&lt;/span> &lt;span class="nx">Entry&lt;/span> &lt;span class="kd">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">Key&lt;/span> &lt;span class="kt">string&lt;/span>
&lt;span class="nx">Value&lt;/span> &lt;span class="kd">interface&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once we have a struct, the next step is to parse tokens from the file and save their values into golang struct. We can copy the logic of the lexer to develop our fluentbit parser.&lt;/p>
&lt;p>In a lexer program, the target characters which we want to parse out are called &amp;ldquo;Token&amp;rdquo;, Token is also the keyword that our parser program is searching for. A parser program will read characters in a file one by one, whenever it found a token, the parser saves the value between tokens into the final structure and go ahead.&lt;/p>
&lt;h2 id="parse-a-single-token">Parse a single token&lt;/h2>
&lt;p>If we want to parse Section, we have to make the parser read characters one by one and stop at &lt;code>[&lt;/code> character, which means the beginning of a Section. The parser must save the current state as &lt;code>t_section&lt;/code> and keep parser reading until &lt;code>]&lt;/code> character, the word between &lt;code>[&lt;/code> and &lt;code>]&lt;/code> is the Section value we need to persist into go struct.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">
&lt;span class="c1">// define some tag to tell parser state
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="kd">const&lt;/span> &lt;span class="p">(&lt;/span>
&lt;span class="nx">t_section&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">iota&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">parser&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">FluentBitConfParser&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">Parse&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">FluentBitConf&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">currSection&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">Section&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// read charector one by one
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">r&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">reader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ReadRune&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// stop at the end of file
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">io&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">EOF&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">currSection&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Conf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Sections&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Conf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Sections&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">currSection&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Conf&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Conf&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;\n&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">continue&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="sc">&amp;#39;[&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="c1">// save last config item
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">currSection&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Conf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Sections&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Conf&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Sections&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">currSection&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// create new config item
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">currSection&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">Section&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">Name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nx">Entries&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="nx">Entry&lt;/span>&lt;span class="p">{},&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">token&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">t_section&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">unicode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">IsSpace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">continue&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// here is important function, read the charectors after token-chareactor and save them into struct
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">strValue&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">parseString&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">token&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="nx">t_section&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nx">currSection&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Name&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">strValue&lt;/span>
&lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">token&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">t_entry_key&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>In function &lt;code>parser.parseString()&lt;/code>, we have to read until the end of a value (for section, it&amp;rsquo;s &lt;code>]&lt;/code>), then return the value.&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-go" data-lang="go">&lt;span class="kd">func&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">parser&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">FluentBitConfParser&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="nf">parseString&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">string&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">error&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="kt">string&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">reader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">UnreadRune&lt;/span>&lt;span class="p">();&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">r&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">reader&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">ReadRune&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">err&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">io&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">EOF&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s">&amp;#34;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">err&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">parser&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">token&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">t_section&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">r&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="sc">&amp;#39;]&amp;#39;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">val&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kc">nil&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">val&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="nb">string&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">r&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s all logic for parsing a section. To parse key/value pair is the same process, just note to make parser know which state it is and save values between whitespace or &lt;code>\n&lt;/code>, you can see the code at &lt;a href="https://github.com/stevedsun/go-fluentbit-conf-parser/blob/master/parser.go">the github repo&lt;/a>.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>To parse a configuration file, we have to&lt;/p>
&lt;ul>
&lt;li>Defining token (key characters)&lt;/li>
&lt;li>Reading characters and looking for a token&lt;/li>
&lt;li>Saving current state to tell parser which struct the following characters belong&lt;/li>
&lt;/ul></description></item><item><title>分布式缓存系统的设计</title><link>https://sund.site/posts/2021/distributed-cache/</link><pubDate>Thu, 18 Mar 2021 15:32:57 +0800</pubDate><guid>https://sund.site/posts/2021/distributed-cache/</guid><description>&lt;p>很久不写技术文章了。这是一篇关于Redis构建分布式缓存系统的总结，结合之前项目上的使用场景，做一个系统性的梳理。&lt;/p>
&lt;p>下面就以我做过的商品预约平台项目作为引子，引出分布式缓存设计的一些要点。&lt;/p>
&lt;p>该商品预约平台的背景如下：&lt;/p>
&lt;ul>
&lt;li>该系统由多个微服务组成&lt;/li>
&lt;li>预约的过程：用户可以选择指定门店，指定日期到店提领商品，如果对应门店和日期没有库存，则不能预约&lt;/li>
&lt;li>因为“预约”的是未来时刻的库存，所以门店的未来某个时间剩余库存是通过一系列公式计算得出的。这个公式比较复杂，考虑到了用户指定的日期是否在配货周期内等因素，这里省略掉细节&lt;/li>
&lt;li>每年节日高峰时期，用户会集中预约商品，导致服务压力骤增。又因为未来日期的库存需要动态计算的特点（比如A预约了1月1日的最后一件商品，B就会无法在该日预约），不同用户的预约操作会互相影响，严重时导致数据库死锁、数据不一致等问题&lt;/li>
&lt;/ul>
&lt;p>基于以上背景，这个预约系统的设计必须将性能作为主要优化目标，而缓存作为性能优化的不二选择，就承担了重要职责。&lt;/p>
&lt;h2 id="识别热点数据">识别热点数据&lt;/h2>
&lt;p>并不是所有数据都有必要被缓存，往往缓存的数据具有以下几个特点：&lt;/p>
&lt;ul>
&lt;li>读写比很高。如果写操作比读操作还多，缓存系统频繁更新会大大降低可用性&lt;/li>
&lt;li>是热点数据。因为内存的价格昂贵，所以按照2-8原则，20%热点数据才值得被缓存&lt;/li>
&lt;li>能够容忍短时间的不一致&lt;/li>
&lt;/ul>
&lt;p>结合项目需要，排除掉一些不适合缓存的数据：&lt;/p>
&lt;ul>
&lt;li>对于那些只读的、配置相关的数据，只需要做进程缓存（使用Guava Cache），在服务启动时加载数据到内存就可以了&lt;/li>
&lt;li>尽量用 CDN 和 Nginx 静态缓存来解决大部分不常更新的资源&lt;/li>
&lt;/ul>
&lt;p>对于该预约项目，用户最频繁查询的数据是不同门店在不同日期下的库存数量。这类数据是缓存设计的重点照顾对象：&lt;/p>
&lt;ul>
&lt;li>用户选择了指定城市、指定门店后，系统会返回最近30天的库存信息，用户只可能修改其中一条信息。所以读写比很高&lt;/li>
&lt;li>库存信息是预约订单流程的必备步骤，而且是跨服务调用（预约服务 -&amp;gt; 库存服务）的数据，所以涉及到大量网络请求、数据库查询。&lt;/li>
&lt;/ul>
&lt;h2 id="指定性能优化的指标">指定性能优化的指标&lt;/h2>
&lt;p>在即将完成业务系统开发时，我们就根据 &lt;a href="https://sre.google/books/">Google SRE Books&lt;/a> 提到的四个黄金指标，制定了监控系统性能的四个维度：&lt;/p>
&lt;ul>
&lt;li>请求率&lt;/li>
&lt;li>错误数，非200返回结果数量&lt;/li>
&lt;li>响应时间&lt;/li>
&lt;li>资源利用率（CPU、内存）&lt;/li>
&lt;/ul>
&lt;p>我们使用 Prometheus + Grafana 的组合实现监控可视化，这样每次测试人员进行压力测试时，都可以通过这些指标对系统进行调整。缓存影响最大的指标是&lt;strong>请求率&lt;/strong>（一般用TPS或者QPS）和&lt;strong>响应时间&lt;/strong>。所以在设计缓存系统时，要不断参照这两个指标进行优化。&lt;/p>
&lt;h2 id="缓存的设计的实践">缓存的设计的实践&lt;/h2>
&lt;h3 id="分级缓存">分级缓存&lt;/h3>
&lt;p>为了不让某一接口或者微服务的缓存失效导致其他接口或服务的并发量暴增，就要针对不同来源（数据库的表、接口等）的数据做分级缓存。比如用户在一次查询中涉及到“附近可预约门店”的查询、“活动期间不同日期剩余库存”的查询、“已预约数量“的查询，这三种查询逐层依赖后边的查询结果。&lt;/p>
&lt;p>假设如果只针对库存数量做缓存，一旦这部分缓存失效，那么“附近可预约门店”的查询就会直接访问数据库查询全部门店的剩余库存来确定哪个门店可以预约。这样就导致查询库存的接口并发量骤增。所以&lt;strong>分级缓存一定程度上缓解了缓存雪崩的问题&lt;/strong>。&lt;/p>
&lt;h3 id="自动化测试api参数合法性">自动化测试API参数合法性&lt;/h3>
&lt;p>我们的QA通常会写自动化脚本对后端API做定期的扫描，检查哪些接口的数据输入、输出有不合法的类型或是数值范围。除了巩固系统的健壮性，还能帮助缓存系统抵御&lt;strong>缓存穿透&lt;/strong>的风险。&lt;/p>
&lt;h3 id="缓存和数据库双写问题">缓存和数据库双写问题&lt;/h3>
&lt;p>这是一个“先淘汰缓存&amp;quot;还是”先写数据库“的问题。通常没有明确的最佳方法。我们采用 &lt;a href="https://dzone.com/articles/cache-aside-pattern">&lt;strong>Cache-Aside Pattern&lt;/strong>&lt;/a> 的方式：&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>失效&lt;/strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。&lt;/li>
&lt;li>&lt;strong>命中&lt;/strong>：应用程序从cache中取数据，取到后返回。&lt;/li>
&lt;li>&lt;strong>更新&lt;/strong>：先把数据存到数据库中，成功后，再让缓存失效。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>缺点：可能有小概率脏数据&lt;/strong>。比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。&lt;/p>
&lt;/blockquote>
&lt;p>考虑到写操作通常比读操作时间更长，所以 Cache-Aside Pattern 中的脏数据概率非常小，即便发生，用户在实际下单时系统仍然会去数据库里做数据校验，不会影响业务数据的正确性。&lt;/p>
&lt;p>如果对缓存一致性有更高要求，可以采用&lt;a href="https://juejin.cn/post/6844903805641818120">延时双删策略或异步更新缓存&lt;/a>。不过这两种方式本质都是用一定程度的串行化操作来解决并发造成的问题。&lt;/p>
&lt;h3 id="预热">预热&lt;/h3>
&lt;p>预加载热点数据时需要注意的点是，要考虑好服务一旦重启或是生产环境发生事故，要避免服务重启后再次造成二次事故。&lt;/p>
&lt;h2 id="缓存系统常见的问题和应对思路">缓存系统常见的问题和应对思路&lt;/h2>
&lt;p>首先要保证应用服务能做好熔断、限流、降级的措施。然后再针对不同情况做应对处理。&lt;/p>
&lt;h3 id="缓存雪崩">缓存雪崩&lt;/h3>
&lt;p>原因：热点缓存数据批量过期，导致大量缓存失效。&lt;/p>
&lt;p>解决思路：&lt;/p>
&lt;ul>
&lt;li>错开过期时间、随机过期时间&lt;/li>
&lt;li>构建多级缓存&lt;/li>
&lt;li>避免热点数据频繁淘汰（如修改Redis淘汰策略为LRU）&lt;/li>
&lt;li>必要时限流、降级&lt;/li>
&lt;/ul>
&lt;h3 id="缓存击穿">缓存击穿&lt;/h3>
&lt;p>原因：热点Key突然过期。&lt;/p>
&lt;p>解决思路：&lt;/p>
&lt;ul>
&lt;li>设计系统时针对性预防措施，比如热点Key的更新策略不依据时间，而是程序控制&lt;/li>
&lt;li>配合监控和后台调整，保证高峰时段热点key可用&lt;/li>
&lt;li>必要时限流、降级&lt;/li>
&lt;/ul>
&lt;h3 id="缓存穿透">缓存穿透&lt;/h3>
&lt;p>原因：黑客通过访问缓存中不存在的数据，将大量请求直达数据库。&lt;/p>
&lt;p>解决思路：&lt;/p>
&lt;ul>
&lt;li>监控报警&lt;/li>
&lt;li>在服务层做好熔断&lt;/li>
&lt;/ul>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>在设计缓存系统时优先排除掉大部分不需要缓存或者通过进程本地缓存的数据。搭建合理的监控手段，自动化测试框架，再结合预热、缓存淘汰策略、双写策略等最佳实践方法，不断优化缓存性能。&lt;/p>
&lt;p>尤其要注意缓存的集中常见问题：雪崩、击穿和穿透。做好应用服务的熔断、降级、限流措施，保证在事故发生时针对每种情况都有预案。&lt;/p></description></item><item><title>用 Notion 实践卡片盒笔记法</title><link>https://sund.site/posts/2020/2020-12-12_notion-as-zettelkasten/</link><pubDate>Sat, 12 Dec 2020 22:42:53 +0800</pubDate><guid>https://sund.site/posts/2020/2020-12-12_notion-as-zettelkasten/</guid><description>&lt;p>今天给大家介绍一种整理和回顾碎片知识的方法——卡片盒笔记法。&lt;/p>
&lt;p>应该不少人都读过少数派作者玉树芝兰老师写的&lt;a href="https://sspai.com/post/59109">关于卡片盒笔记法的文章&lt;/a>。&lt;a href="https://pmthinking.com/">产品沉思录&lt;/a>的主理人少楠也写过很多相关的内容，最近他们还出了一个工具（Flomo - 浮墨笔记）也是基于这套方法论的。&lt;/p>
&lt;p>在这篇文章中，我会结合自己用 Notion 的经验，分享一下我如何用 Notion 做卡片笔记。&lt;/p>
&lt;p>本文参考了 &lt;a href="https://www.youtube.com/channel/UC66w1T4oMv66Jn1LR5CW2yg">Youtube 频道 Mukul Khanna&lt;/a> 关于 Notion 的一系列使用方法。&lt;/p>
&lt;h2 id="什么是卡片盒笔记法">什么是卡片盒笔记法&lt;/h2>
&lt;p>卡片盒笔记法（Zettelkasten）是一种将零散的想法、笔记和文献，通过编号、引用、索引等方式彼此关联起来，形成知识网络并提取有效信息的方法。其著名使用者——社会学家 Niklas Luhmann 一生创建了9万多张索引卡片，发布了70多本专著和400多篇学术论文。&lt;/p>
&lt;p>卡片盒笔记法可以类比为人类大脑记忆和归纳知识的回路。&lt;/p>
&lt;p>人类大脑有两种思维模式——专注和发散。&lt;/p>
&lt;p>&lt;strong>我门通常学习某一学科知识时使用的是专注模式——从一个知识点引申到相关的知识点，像串糖葫芦一样把一系列知识点串联起来形成一套知识体系&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>在另一些情况下，如艺术创作、技术创新等，我们的大脑会切换为发散模式——大脑在在一些关联但不同领域的知识间来回跳跃，形成一种全新的思考路径&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gll946614lj311v0lbe3p.jpg" alt="https://tva1.sinaimg.cn/large/0081Kckwgy1gll946614lj311v0lbe3p.jpg">&lt;/p>
&lt;p>此时此刻，我为了将分散在不同笔记中零散的知识点关联起来形成这篇大家看到的文章，就需要同时借助两种模式，找到不同网站、文献间相关的内容，把他们组织起来。&lt;/p>
&lt;p>相对应的，卡片盒笔记法有两种关联笔记的方式，「顺序」和「引用」：&lt;/p>
&lt;p>&lt;strong>当我们在专注模式下阅读一本书或一篇文献时，我们可以把瞬间的想法记录在笔记中，按顺序（比如按章节）把若干笔记关联起来&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>而当我们在记录笔记过程中想到相关的内容在另一篇文献中也出现过，那么我们可以在笔记中用引用的方式把另一篇笔记内容和这篇内容做关联&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gllaebar7dj312w0jd76s.jpg" alt="https://tva1.sinaimg.cn/large/0081Kckwgy1gllaebar7dj312w0jd76s.jpg">&lt;/p>
&lt;p>这样一篇笔记（卡片盒笔记法里的「卡片」），就有了两条途径来回顾它——&lt;strong>顺序阅读和延伸阅读&lt;/strong>。例如，一段时间后，我们想把这段时间的学习心得梳理出来归纳成一篇文章，我们就可以先以某一篇笔记为起始点，顺序读下面的笔记卡片，读到感兴趣的内容再看看它关联的那些卡片是否可以作为素材。以此类推，从一片知识的网络中抽丝剥茧，抽象出一种独特的脉络。当然，这些卡片还可以和其他卡片组合，形成另一种视角。这一套卡片构成的卡片盒，就是一套不断碰撞出新想法的数据库。&lt;/p>
&lt;h2 id="notion-为什么适合做卡片盒笔记法">Notion 为什么适合做卡片盒笔记法&lt;/h2>
&lt;p>Notion 在前一段时间更新了 Backlinks （反向链接）功能，这一功能的推出，把 Notion 和新晋的几款网状知识管理工具（Roam Search、Obsidian）的差异大大缩小，成为了做卡片盒笔记法的合适工具。相对于专注做卡片笔记的软件来说，Notion 的优势是更加灵活的配置和用途广泛的页面元素。&lt;/p>
&lt;h2 id="用-notion-实践卡片盒笔记法">用 Notion 实践卡片盒笔记法&lt;/h2>
&lt;p>我们首先脱离 Notion 这个软件，看看通常情况下一张卡片由哪些部分组成。下图是来自 &lt;a href="https://zettelkasten.de/introduction/">Introduction to the Zettelkasten&lt;/a> 文章的配图，呈现了一张卡片的样子：&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gllag43nh1j312w0k6jve.jpg" alt="https://tva1.sinaimg.cn/large/0081Kckwgy1gllag43nh1j312w0k6jve.jpg">&lt;/p>
&lt;ul>
&lt;li>标题。包含一个唯一编号的标题，编号的作用是在其他笔记中可以方便引用该笔记，而不用担心笔记的标题发生变化使引用失效&lt;/li>
&lt;li>标签。方便回顾笔记时对某一类内容做整理归纳&lt;/li>
&lt;li>正文。笔记正文是一个想法或是一个知识点的总结。一定是用自己的话来归纳。可以引用其他笔记的编号或是参考文献的地址来配合内容展现&lt;/li>
&lt;li>参考文献。结尾部分是这篇笔记卡片是由哪些文献引申而来的&lt;/li>
&lt;/ul>
&lt;p>由此可见，卡片盒笔记法中的「卡片」是通过&lt;/p>
&lt;ol>
&lt;li>引用卡片编号，来关联其他卡片&lt;/li>
&lt;li>引用参考文献，来关联外部文献&lt;/li>
&lt;/ol>
&lt;p>下面回到 Notion 这个工具，我们一步步来搭建卡片盒笔记法。&lt;/p>
&lt;h3 id="搭建文献库---零散知识的数据库">搭建文献库 - 零散知识的数据库&lt;/h3>
&lt;p>所谓巧妇难为无米之炊，我们做笔记的第一步就是搭建文献资料库，这是一切笔记的源头，有点像数据工程里的「贴源数据层」，文献库是为了让互联网上经常失效的文章有个备份的好地方，同时你也可以在文献库里对文章进行划线、高亮和备注。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gllari2255j31n60u0qi3.jpg" alt="https://tva1.sinaimg.cn/large/0081Kckwgy1gllari2255j31n60u0qi3.jpg">&lt;/p>
&lt;p>这是我的一个文献库，专门收藏一些专业外的小知识。&lt;/p>
&lt;p>首先要在 Notion 创建一个列表页面（List Page），取名「文献库」。列表中的每一个条目都是一个页面，包含一些基本属性：&lt;/p>
&lt;ul>
&lt;li>标题&lt;/li>
&lt;li>备注&lt;/li>
&lt;li>标签&lt;/li>
&lt;li>被引用。使用 Notion 的 Relation 属性，关联到和这篇笔记有关的笔记&lt;/li>
&lt;li>领域，可有可无。类似一种标签，我把领域也做成了页面来关联到这里&lt;/li>
&lt;li>URL，这是 Chrome 网页剪藏扩展（Save to Notion）的默认属性&lt;/li>
&lt;li>添加时间&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gllav36i2hj30wy0u0guj.jpg" alt="https://tva1.sinaimg.cn/large/0081Kckwgy1gllav36i2hj30wy0u0guj.jpg">&lt;/p>
&lt;p>为了从网页上剪藏这样一篇文章，我在 Chrome 浏览器里安装了 &lt;a href="https://chrome.google.com/webstore/detail/ldmmifpegigmeammaeckplhnjbbpccmm">Save to Notion&lt;/a> 这个扩展，它的优点就是可以在剪藏网页内容同时设置好笔记的属性。把 Save to Notion 保存位置设置成你已经建立好的文献库，就可以一键保存到 Notion 了。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gllc7be6nlj30km0vitcl.jpg" alt="https://tva1.sinaimg.cn/large/0081Kckwgy1gllc7be6nlj30km0vitcl.jpg">&lt;/p>
&lt;p>对于那些无法被直接剪藏的文献（比如 pdf 格式的论文、书籍、视频等）也可以直接在笔记页面直接填写 meta data 的方式指明出处，下文会介绍何谓卡片笔记的 meta data。&lt;/p>
&lt;h3 id="搭建卡片盒---思维碎片的收集器">搭建卡片盒 - 思维碎片的收集器&lt;/h3>
&lt;p>有了可以追溯的文献库，接下来是卡片盒笔记法的核心步骤，搭建卡片盒。&lt;/p>
&lt;p>卡片盒可以用 Notion 的 Gallery Page 来展现。每一个笔记页面都是一张卡片。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gllcdx8g82j31re0u0hdt.jpg" alt="https://tva1.sinaimg.cn/large/0081Kckwgy1gllcdx8g82j31re0u0hdt.jpg">&lt;/p>
&lt;p>「卡片」也有一些基本属性需要设置：&lt;/p>
&lt;ul>
&lt;li>标题&lt;/li>
&lt;li>ID，可有可无。Notion 可以直接用 @ 符号引用其他页面。 这里 ID 参考了卡片盒笔记法的编号，可以用 Notion 的公式属性来根据时间生成一个唯一的 ID。偶尔在其他软件中引用这个编号，可以方便在 Notion 中快速搜索&lt;/li>
&lt;li>创建时间&lt;/li>
&lt;li>项目，可有可无。关联到某个项目的页面&lt;/li>
&lt;li>标签&lt;/li>
&lt;li>文献。关联到文件库中的某一篇剪藏的文章&lt;/li>
&lt;li>文献 metadata。一些无法保存到 Notion 的内容，可以直接在这里备注出处的段落。方便日后查找，如 《某某图书》的第一章第三段&lt;/li>
&lt;li>上一条。按「顺序」关联的思路，上一篇相关的笔记的链接&lt;/li>
&lt;li>下一条。下一篇顺序关联的笔记&lt;/li>
&lt;li>索引。表明这篇文章是否被收录到索引里。关于索引在下文会介绍&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gllci3rwh8j30xo0u0gsq.jpg" alt="https://tva1.sinaimg.cn/large/0081Kckwgy1gllci3rwh8j30xo0u0gsq.jpg">&lt;/p>
&lt;p>前文说，一张笔记卡片有两种方式和其他卡片或参考文献产生关联：&lt;/p>
&lt;ol>
&lt;li>在参考中引用文献。这点在属性的文献、文献 metadata 中我们已经实现了。&lt;/li>
&lt;li>直接在正文中引用。Notion 天然支持 backlinks 双向关联。一个页面如果提及了其他页面内容，可以在被引用的页面顶部的 backlinks 里看到二者的关联。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glldjnqmsyj31d70u0qad.jpg" alt="https://tva1.sinaimg.cn/large/0081Kckwgy1glldjnqmsyj31d70u0qad.jpg">&lt;/p>
&lt;p>另外针对思维的两种模式：专注模式和发散模式，有两种回顾卡片的方式：&lt;/p>
&lt;ol>
&lt;li>我们特意设置了「上一条」、「下一条」这样的指向其他页面的链接，来方便我们按顺序回顾一系列笔记，对应了专注模式&lt;/li>
&lt;li>我们也可以通过点击正文中超链接的方式看其他相关的卡片内容，对应了发散模式&lt;/li>
&lt;/ol>
&lt;p>好了，现在你已经有了文献库、卡片盒，每次读到感兴趣的内容、有新的想法，都可以在卡片盒中创建一篇笔记，用自己的话总结、记录它。&lt;/p>
&lt;p>但是要把他人的知识变为自己的知识，做到这些还远远不够。零散的知识仅仅被记录下来并不代表它属于我们。那只是知识网络中的一个节点。而我们要的是一个回路。&lt;strong>思维就是一系列知识节点的脑回路。卡片盒笔记法里用索引卡片的方式为一系列卡片创建目录&lt;/strong>。&lt;/p>
&lt;h3 id="搭建卡片索引---网络中的高速公路">搭建卡片索引 - 网络中的高速公路&lt;/h3>
&lt;p>有了知识的网络，我们还要回顾。很多人管理笔记的方式就是存起来放在那里，这是自欺欺人。我们要定期回顾，按顺序、标签、延伸阅读等方式，在卡片盒中随机漫步，把相关的卡片联系起来，在知识的网络里构成一条思维的回路，发现一些过去没有发现的知识关联，让不同学科、领域的知识可以互相佐证、交叉引用。&lt;/p>
&lt;p>继续在 Notion 创建一个名为「索引」的列表页面，页面中每一个条目都是一个主题的索引页面，将多张卡片用超链接的方式组织在一个主题下，犹如图书的目录。比如这篇文章，我就是从这个索引中演化而来。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glld3ii7lxj30wo0omdht.jpg" alt="https://tva1.sinaimg.cn/large/0081Kckwgy1glld3ii7lxj30wo0omdht.jpg">&lt;/p>
&lt;p>这就好比一条信息高速公路。可以让我们直达这个主题下的笔记。但是修建高速公路的副作用，是会让我们忽略那些拥有别样风景的小路。每一张卡片，可以成为另一个主题里的内容。&lt;strong>重要的是，路径不只一条。&lt;/strong>&lt;/p>
&lt;h3 id="减少笔记数量给大脑减压">减少笔记数量，给大脑减压&lt;/h3>
&lt;p>卡片盒笔记法和其他知识管理方法的共同问题就是，笔记量越大，回顾的成本越高，越到后期回顾越花费时间，很多人有心里负担也就放弃或是干脆觉得这些方法都是糊弄人的。&lt;/p>
&lt;p>知识管理就像打怪升级，想要超凡的经验，苦练不能少。我们也可以通过定期删掉过时、重复的笔记，剔除一些无效的节点来减少阅读成本。&lt;/p>
&lt;p>卡片盒笔记法还鼓励定期提炼多张同类的笔记为一个笔记，从而减少后期回顾成本。即把知识网络中的节点合并起来。这些小技巧因人而异，实践中可以多多总结发现。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>这次介绍了卡片盒笔记法和 Notion 结合的用法。请注意 Notion 的页面关联功能 （Relation）是让这套方法成立的根基，相当于用 Notion 配置了一个专门用于卡片盒笔记法的笔记工具。这也是 Notion 被称为第二大脑的关键，它不只是一个笔记软件，更是一个多种可能性的工具。&lt;/p>
&lt;p>卡片盒笔记法的核心是构筑彼此关联的笔记网络，在此基础上通过顺序、发散的回顾方式不断产生新的回路，抽象成为创作的素材。借助 Notion 的特性，我们可以在多个页面之间关联、跳转、搭建属于自己的高速公路。&lt;/p>
&lt;p>以上就是本文的内容，希望对你有用，你可以在延伸阅读里找到更多相关文章，也欢迎你关注我的公众号随时订阅我的新发现。&lt;/p>
&lt;h2 id="延伸阅读">延伸阅读&lt;/h2>
&lt;p>&lt;a href="https://index.pmthinking.com/effa3aa294af4d07ac279e74aec69602">花园与溪流的隐喻&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://sspai.com/post/61886">Matrix 圆桌 | 网状结构笔记工具是一阵风吗？&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zettelkasten.de/">Zettelkasten 介绍&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://takesmartnotes.com/">Take Smart Notes&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.youtube.com/watch?v=lOY-drtTJX0&amp;amp;feature=youtu.be">How I use Zettelkasten in Notion | Best note-taking knowledge-management system 📝&lt;/a>&lt;/p></description></item><item><title>职业生涯说明书（一）</title><link>https://sund.site/posts/2020/2020-6-6_career_strategies/</link><pubDate>Sat, 06 Jun 2020 19:30:43 +0800</pubDate><guid>https://sund.site/posts/2020/2020-6-6_career_strategies/</guid><description>&lt;p>对于大部分人来说，工作贯穿一生，工作对于人的健康、幸福感都发挥着决定性作用。&lt;/p>
&lt;p>今天的话题就是关于如何规划职业生涯。&lt;/p>
&lt;p>这次话题的起因是听了Rio和黄海主播的Podcast&lt;a href="https://crazy.capital/44">《疯投圈》的一期节目&lt;/a>，里面提到一本职业规划的书——&lt;a href="https://book.douban.com/subject/27609489/">《远见》&lt;/a>。作者&lt;a href="https://book.douban.com/subject_search?search_text=%E5%B8%83%E8%B5%96%E6%81%A9%C2%B7%E8%B4%B9%E7%91%9F%E6%96%AF%E9%80%9A%E8%B1%AA">布赖恩·费瑟斯通豪&lt;/a>是市场营销方面的大师，他主张对待职业生涯要看长远，普通人一生中绝大部分财富是在40岁之后积累的，所以年轻时对财富的忧虑往往是过度的，要对职业生涯做一个长达45年的分阶段职业规划，保持积累可持续的职场燃料。&lt;/p>
&lt;p>《远见》整本书都在围绕两个主题：&lt;/p>
&lt;ol>
&lt;li>寻找助推职业发展的「职场燃料」&lt;/li>
&lt;li>在职业的不同阶段，如何给自己清晰的定位&lt;/li>
&lt;/ol>
&lt;h2 id="积累职业生涯的三大职场燃料">积累职业生涯的三大职场燃料&lt;/h2>
&lt;p>所谓职场燃料，即&lt;/p>
&lt;ul>
&lt;li>可迁移的技能&lt;/li>
&lt;li>有意义的经验&lt;/li>
&lt;li>持久的关系&lt;/li>
&lt;/ul>
&lt;p>相比于即学即用的职业技能，这三大燃料往往是在漫长的工作经历中逐渐获取的。聪明的职业发展策略是，在整个职业生涯中持续积累、更新职场燃料，同时精明地消费它们。&lt;/p>
&lt;p>例如，当我们想要跳槽到下一家公司时，除了福利待遇，最看重的是什么呢？很多人会说「能不能学到东西」。其实这是非常模糊的概念，学到什么，通过什么学？这些问题决定了一份工作是否成为你职业生涯的助推器。&lt;/p>
&lt;h3 id="可迁移技能我应该从工作中学到什么">可迁移技能。我应该从工作中学到什么&lt;/h3>
&lt;blockquote>
&lt;p>（它）不仅是帮助你完成眼前工作的技术知识和行业术语，而且是当你从一个工作换到另一个工作，从一家公司换到另一家公司，甚至是从一个行业换到另一个行业时都能依靠的能力和基础。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>可迁移技能不光是指那些领域知识或者技术壁垒，更是一些通用的社会技能&lt;/strong>，例如：&lt;/p>
&lt;ul>
&lt;li>解决问题能力&lt;/li>
&lt;li>沟通能力&lt;/li>
&lt;li>人才吸引力&lt;/li>
&lt;li>寻求帮助和帮助他人的能力&lt;/li>
&lt;li>理解和连接他人情绪状态的能力&lt;/li>
&lt;/ul>
&lt;p>这些能力往往不存在于特定的公司或是领域。可迁移技能中的**大部分真正重要的能力，并不需要反复跳槽来获取。**如何尽可能获得能力的提升呢？布赖恩认为，关键在于开放性的心态。如果你能多一些耐心，通常就能在一家公司里获得丰富的经验。&lt;/p>
&lt;p>你可以试着用一张纸，把自己的可迁移技能列出来，审视一下，哪些是随着行业发展逐渐消失的？哪些会在未来持续提供你帮助的？你是否在积累这些技能？&lt;/p>
&lt;h3 id="有意义的经验我的工作是否有价值">有意义的经验。我的工作是否有价值&lt;/h3>
&lt;blockquote>
&lt;p>自信心必须建立在有市场竞争力的事情上面。&lt;/p>
&lt;/blockquote>
&lt;p>社交网络上总看到类似这样的职场段子——「离职无非两个原因：嫌钱少；干得不高兴」。用钱和高兴程度来衡量工作的价值还远远不够。&lt;/p>
&lt;p>&lt;strong>评估当前工作是否对我们有价值，可以通过4个黄金问题&lt;/strong>：&lt;/p>
&lt;p>1．我是否正在&lt;strong>学习&lt;/strong>和成长？&lt;/p>
&lt;p>2．我是否正在对某些人、现在的公司，乃至整个社会拥有&lt;strong>影响力&lt;/strong>&lt;/p>
&lt;p>3．我体验到&lt;strong>乐趣&lt;/strong>了吗？&lt;/p>
&lt;p>4．我是否得到了适当的&lt;strong>奖励&lt;/strong>，并创造了经济价值？&lt;/p>
&lt;p>这四个方面分别对应了学习、影响力、乐趣、奖励。&lt;/p>
&lt;p>学习决定了你是否在专业领域保持成长；影响力代表你对他人带来的益处，这会从多方面影响你的人际关系和发展机会；乐趣则是持续投入精力和从工作中获得幸福感的源动力；奖励则不光是薪水，还有各种福利、时间、补贴等因素。&lt;/p>
&lt;p>根据当下你的感受，给这四方面分别赋予一定权重（一个百分比），假如你更看重学习和乐趣，那么就给他们更高的权重，同时降低另外两项的权重。然后给当前工作的状态打出评分，10分满分，最后用权重乘以评分得到每一项的职业价值分：&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fgy1gfb2tptkq6j218i0d8gn3.jpg" alt="试着在纸上列出这四项，看看自己的得分吧">&lt;/p>
&lt;p>根据作者布赖恩的经验，如果总分在700分以上，那么你的工作就算非常有价值了。&lt;/p>
&lt;p>表格中的权重可以每年根据自己的感受进行调整。最重要的是，不要单纯把金钱和干得高兴作为决定工作价值的因素。影响力往往是人们最容易忽略的价值，年轻阶段积累的影响力，往往会在职业生涯的后半段起到决定性作用。&lt;/p>
&lt;h2 id="持久的关系">持久的关系&lt;/h2>
&lt;blockquote>
&lt;p>人脉关系网的构建者的心态是交易性的，他们在追求人际关系时只考虑其他人能为他们做什么。而人际关系的构建者会首先尝试帮助别人，他们不会有所保留。&lt;/p>
&lt;/blockquote>
&lt;p>很多教你如何「积累人脉」的书，骨子里都是在教你「虚伪」。布赖恩认为，&lt;strong>真正获得良好人际关系的诀窍在于不索取回报的付出&lt;/strong>。根据研究，付出者在利他性、责任心、社会正义和同情心方面表现的更加突出，往往跻身杰出和最幸福行列的机会也比别人大得多。&lt;/p>
&lt;p>我们总觉得社会关系要讲究「互利」，其实互利的本质就是「利他」。回报往往是非即时的，总要在一方面作出让步，才能在另一方面获得回报。&lt;/p>
&lt;p>「向他人提供帮助」的能力也是强大的可迁移技能，它的重要性甚至高于「向他人寻求帮助」的能力。&lt;/p>
&lt;p>然而，根据&lt;a href="https://zh.wikipedia.org/zh-hans/%E9%82%93%E5%B7%B4%E6%95%B0">邓巴数理论&lt;/a>，一个人能够同时保持密切关系的人数上限是150人。&lt;/p>
&lt;p>所以那些微信躺着上千好友的社交大咖，是把朋友当作交易性的「人脉」还是良好的「人际关系」？&lt;/p>
&lt;p>布赖恩把一个人的人际关系分为5层，数量上从多到少，依次是：&lt;/p>
&lt;ul>
&lt;li>通信录里的&lt;strong>联系人&lt;/strong>&lt;/li>
&lt;li>拥有特殊知识、权力的&lt;strong>专家团&lt;/strong>&lt;/li>
&lt;li>在公司里对你有决定性影响的5到10个&lt;strong>关键同事&lt;/strong>&lt;/li>
&lt;li>提建议、拥护你、激励你的&lt;strong>支持者（导师、帮手）&lt;/strong>&lt;/li>
&lt;li>你&lt;strong>自己&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>他们构成了支撑你职业生涯的金字塔。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fgy1gfb3tk5z1pj20p60rywft.jpg" alt="https://tva1.sinaimg.cn/large/4a41845fgy1gfb3tk5z1pj20p60rywft.jpg">&lt;/p>
&lt;p>联系人是你的通信录好友，你通过各种渠道认识的人。他们数量较多，通常他们中的少数人会成为你真正的好朋友。&lt;/p>
&lt;p>专家团是你的朋友中具备一定专业能力和领域知识的人，在你需要帮助时，可以向他们求援。在利他的原则下，我们也会成为别人的专家团，帮助他人。&lt;/p>
&lt;p>关键同事的重要性不言而喻，他们直接影响你的职业发展，其中榜首的是你的上司。&lt;/p>
&lt;p>支持者又称为你的「个人董事会」，他们的建议和帮助往往对你的职业生涯起着决定性作用。支持者在人的一生中十分稀有而宝贵，他们甚至会在背后默默帮助你，说你的好话，成为你重要职位的推荐人。那么如何寻找你的「支持者」呢？布赖恩给出的建议是：「&lt;strong>如果你将自己当成一个学生，那就自然会找到老师&lt;/strong>」。&lt;/p>
&lt;p>最后，不要忘了自己，你是你自己最好的品牌经理。&lt;/p>
&lt;p>这个人际关系金字塔是你赖以生存的职业生态系统，请把对你重要的那些人填在对应的位置。每年至少要审视一次，哪些关系为你带来了最大的价值？哪些关系正在枯竭？哪些关系还可以进一步发展？&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfisgq9qzxg30by090nna.gif" alt="可持续的关系是坚固的，反之，建立在「交易性质」关系之上的金字塔则非常脆弱">&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>本文介绍了职业生涯的三大助推燃料：可迁移的技能、有意义的经验和持久的关系。&lt;/p>
&lt;p>积累可迁移的技能并不意味着你必须通过跳槽来寻找学习机会。&lt;/p>
&lt;p>而有意义的经验则从4个维度评估的当前工作的价值，并介绍了一种基于权重和打分的个人评估工具。&lt;/p>
&lt;p>在持久的关系一节介绍了人际关系金字塔，请审视自己周围的人际关系，是否能够持续支撑你的职业发展。&lt;/p>
&lt;p>记住，在人际关系中的关键要素是「利他」。&lt;/p>
&lt;p>我会在下一篇《职业生涯说明书（二）》中继续介绍职业生涯的三大阶段，以及如何在不同阶段选择合适的定位，正确应对职场危机，从工作中实现真正的人生价值。&lt;/p></description></item><item><title>译文：重建世界2.0</title><link>https://sund.site/posts/2020/2020-5-10_build_world_2_0/</link><pubDate>Sun, 10 May 2020 20:22:53 +0800</pubDate><guid>https://sund.site/posts/2020/2020-5-10_build_world_2_0/</guid><description>&lt;p>这是一篇投资人&lt;a href="https://twitter.com/danielgross">Daniel Gross&lt;/a>发表在自己博客的文章，讨论了新冠疫情后期的世界如何进入2.0新模式，以及有哪些机会和挑战。我把它翻译过来，希望大家也能从中获得启发。&lt;/p>
&lt;h1 id="重建世界20">重建世界2.0&lt;/h1>
&lt;p>未来几周，因疫情导致的封锁将逐步放开，当我们再一次打开房门，迎接我们的将是世界2.0。在这个新版本的世界里，一切会看起来完全不同，这种「不同」会成为培育新一代开拓者们的土壤。&lt;/p>
&lt;p>开始话题之前，理解下面的原则可能会帮助我们思考：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>衰退不可避免&lt;/strong>。在用尽了所有维持经济运转的手段之后，洪水将会到来。在30%的失业率下，我们无法保持同样的经济增长了。&lt;/li>
&lt;li>&lt;strong>疫苗何时到来还不确定&lt;/strong>。就像普通感冒一样，没有特效药。在科学家研制出可行的药物之前，我们将被迫改变生活习惯以适应这种状态。&lt;/li>
&lt;li>&lt;strong>大自然迫使我们进行一场规模空前的社会实验&lt;/strong>。很多企业在几周内就全部远程办公了，一些地区觉得远程办公是一种巨大的经济负担。但是很多人终会明白，远程工作虽然不是特别好，但在这个背景下，仍然是一个好办法。&lt;/li>
&lt;li>如果世界2.0同样的保持平等、优越、法理……那一切行为都会产生永久性的改变。（译者：即永久性替代现有秩序）&lt;/li>
&lt;/ul>
&lt;p>如果你的想法足够超前，你一定能在这场游戏里获得有价值的东西：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>握手已死&lt;/strong>。疫情首先改变了家庭内部的习惯，然后，陌生人之间呢？&lt;/li>
&lt;li>&lt;strong>电影院的消亡&lt;/strong>。电影会在网络上重生。影院已经无力承担更少的座位了，即便在病毒爆发之前很多影院也已经濒临破产。已经有太多可以替代电影院的选择了。&lt;/li>
&lt;li>&lt;strong>暂停音乐会，在网上开&lt;/strong>。再次举办这种大型活动遥遥无期，目前还没有可替代的方案。我敢打赌，这种情况将会反复发生：再一次爆发疫情，再一次停止活动。&lt;/li>
&lt;li>&lt;strong>城市的（暂时性）终结&lt;/strong>。疫苗出现之前，越来越多人会搬去郊区。一些房地产经纪人告诉我旧金山公寓的市场在降温，同时郊区的房子却渐渐在升值。&lt;/li>
&lt;li>&lt;strong>信任&lt;/strong>。突然之间，所有人都变成了潜在病毒携带者，当你在大街看到一个陌生人时，内心是什么感觉？病毒增大了人与人的距离，减少了彼此的信任。&lt;/li>
&lt;li>&lt;strong>商务旅行变成了Zoom会议&lt;/strong>。部分公司发觉，可以通过远程会议完成谈判。我想，在经济衰退的市场环境下，很多管理者为了降低成本，会退而求其次。旅行的开支将会被大幅降低。&lt;/li>
&lt;li>&lt;strong>个人旅行减少&lt;/strong>。原因可能是个人经济能力的下降，而不是恐慌。&lt;/li>
&lt;li>&lt;strong>数字企业活动&lt;/strong>。过去几周我已经见识到很多在网上进行的商业活动。其中，很多经理人发现在一些项目中使用Zoom（远程会议软件）已经“足够好用”了，并开始着手削减此前在这方面的其他投入。如果这一次的网络商业活动实践产生了积极的作用，那么对于那些利润直接相关的企业部门未来采纳网上商业活动模式将至关重要。&lt;/li>
&lt;li>&lt;strong>「集体农场式」人事管理&lt;/strong>。如果未来在不同地区发生第二波第三波疫情，可以想象到，人们会共同参与社区管理，构筑起新的信任关系。类似室友和家庭之间的有机结合，这种结合越来越广泛。未来的公司甚至会鼓励同事之间共同隔离，以此提高返工管理流程的效率。&lt;/li>
&lt;li>&lt;strong>开放办公室会变得越来越不受欢迎&lt;/strong>。不但因为开放办公环境的人员密度不适合保持社交距离，而且人们经历了在家办公之后，会渐渐意识到一扇可以关上的门是多么重要。&lt;/li>
&lt;li>&lt;strong>公共交通被看作不安全&lt;/strong>。世界2.0不喜欢高密度的人口。还有什么比高峰时段的地铁更高密度呢？城市交通对一个城市的发展至关重要，要么我们会看到严厉的管控措施，要么就是像纽约那样大规模感染之后群体免疫。总之对Uber（等共享出行）来说可能是一个福音。&lt;/li>
&lt;li>&lt;strong>餐馆和数字餐馆&lt;/strong>。酒馆文化存在了几千年，所以它不会消失。但问题是，如何低密度地运营这项业务，以适应新时代的社交距离。由于家庭餐馆的模式并不理想，所以这个领域是我认为会出现新产品和创造力的地方。&lt;/li>
&lt;li>&lt;strong>学校会加强网络教学&lt;/strong>。父母顺理成章地会要求年轻人回到学校。没有什么比大学校园更好的生活环境了：那里聚集着一群对病毒免疫的年轻人，并且远离了老年人。也许会有新的数字教育替代品出现，但是用Zoom远程上课肯定不是最好的办法。&lt;/li>
&lt;li>&lt;strong>在线体育2.0&lt;/strong>。类似餐馆，在线体育也有很多上升空间。想象一下，在没有观众和球迷的体育场比赛，将会对运动员的生理水平造成什么影响。这很有趣。&lt;/li>
&lt;/ul>
&lt;p>这将是人类有史以来最不稳定的时代。一夜之间全世界的人们都改变了行为方式。这为创业营造了真正的机会，那些能够快速适应时代需要的人，将比其他人更好的发展。&lt;/p>
&lt;p>对于每一个新出现的行为模式，都会有一家新的创业公司出现填补空缺。假如人们想要音乐会，大自然不允许，那么替代方案是什么？如果酒吧餐馆因为社交距离的原因而无法维持，那么网络上酒吧餐馆是什么样呢？新的Zoom应该是什么样子，一个企业版的Snapchat如何引领销售业绩呢？正如Nat Friedman所言，“视频会议是一架不需要马的马车“。&lt;/p>
&lt;p>值得期待的是，在新冠疫情把我们从美梦中唤醒的同时，世界1.0正在衰退，大自然打破了常规，我们必须重新建立秩序。&lt;/p>
&lt;p>“IT&amp;rsquo;S TIME TO BUILD!”&lt;/p>
&lt;p>原文链接：&lt;a href="https://dcgross.com/building-in-world-2-0/">https://dcgross.com/building-in-world-2-0/&lt;/a>&lt;/p></description></item><item><title>一个购买数字商品的必备技能</title><link>https://sund.site/posts/2020/2020-3-30_us-paypal/</link><pubDate>Mon, 30 Mar 2020 23:39:33 +0800</pubDate><guid>https://sund.site/posts/2020/2020-3-30_us-paypal/</guid><description>&lt;p>&lt;img src="https://pbs.twimg.com/media/ET46ksZUUAA9t_l?format=jpg&amp;amp;name=large" alt="图像">&lt;/p>
&lt;p>《集合啦！动物森友会》最近占据了所有社交网络的时间线。这款游戏的快乐对于不了解它的人，恐怕只有亲身上岛，和动物朋友们一起捉虫钓鱼才能渐渐体会到。嗅觉灵敏的淘宝奸商（其实也是为了恰饭）一直在抬高售价，《动森》的价格被从320元一路炒到了450元，很多Nintendo Switch玩家无奈转战到eshop购买数字版。&lt;/p>
&lt;p>今天我会讲讲怎么以最便宜的价格购买数字版游戏，以及国内剁手党如何将全球便宜商品收入囊中。&lt;/p>
&lt;p>从这篇文章中你可以收获：&lt;/p>
&lt;ol>
&lt;li>购买Nintendo Switch亚区、美区、欧区的游戏都有哪些限制&lt;/li>
&lt;li>如何使用国内的VISA卡绑定美国的Paypal来购买数字版游戏&lt;/li>
&lt;li>除了买数字版游戏，美国Paypal还能做什么？&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gdb7f7isabj228k1744qu.jpg" alt="image-20200329231453072">&lt;/p>
&lt;h2 id="nintendo-eshop-各个区购买游戏有什么限制">Nintendo eShop 各个区购买游戏有什么限制&lt;/h2>
&lt;p>任天堂的电子商店eshop把全球玩家大致划分为三个大区——亚区、美区、欧（非、澳）区。非、澳洲和欧区享受同样的待遇，所以我们下文统称欧区。亚洲区里中国玩家最熟悉的是港服、日服，很多日本出的RPG游戏只有这两个区有中文版；至于国行的Nintendo Switch主机，因为只能购买国行的游戏，所以我们不去聊它。&lt;/p>
&lt;p>注意，在各个地区eshop购买游戏，首先需要注册对应地区的账号，可以参考这篇攻略&lt;a href="https://mp.weixin.qq.com/s/d9wCeRf6WgRm7pvF6Madnw">《简单几步，就可以完成看似复杂的任天堂账号注册| Jump 新手教程》&lt;/a>。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>亚区的eshop支持用国内的（VISA，MasterCard）信用卡付款，港服还支持用支付宝。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>欧区支持用国内的（VISA，MasterCard）信用卡付款。（但是也有部分朋友反应澳大利亚最近也无法使用信用卡支付成功了）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>美区只能使用美区那些国家的信用卡支付，比如加拿大、美国、墨西哥。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>可见，国内玩家最难购买的就是美区的游戏了。众所周知，墨西哥是eshop购买游戏最划算的地区之一，&lt;strong>同样的游戏，墨西哥总是比日本、美国等其他地区便宜将近一半！&lt;/strong>&lt;/p>
&lt;p>另外由于最近疫情影响，&lt;strong>澳元贬值，澳大利亚区也成为了购买数字产品的圣地&lt;/strong>。&lt;/p>
&lt;p>所以接下来就围绕「如何跨区购买数字商品」展开攻略吧。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gdb7wd0goyj20n01dsh33.jpg" alt="澳洲和美洲有着令人羡慕的价格">&lt;/p>
&lt;h2 id="如何用国内的双多币信用卡购买数字游戏和其他产品">如何用国内的双/多币信用卡购买数字游戏和其他产品&lt;/h2>
&lt;p>Nintendo eshop除了信用卡直接绑定付款，还可以绑定Paypal账号支付。网上出现过很多注册美国Paypal来购买游戏的教程，比如这篇&lt;a href="https://mp.weixin.qq.com/s/X5QJyQq86zrvbPbKq7i1xg">《购买eShop数字版游戏 | 完整版教程》&lt;/a>。但是教程中最困难，也是阻碍最多人走向成功的一步，就是美区的Paypal风控极其严格，如果你使用的国内信用卡并且没绑定美国的电话号码，马上就会被Paypal发现并锁定你的账号，要求你验证身份。&lt;/p>
&lt;p>我就是经历这样一个「注册成功-&amp;gt;😊-&amp;gt;被锁定-&amp;gt;😖」的过程，才终于知道了原来一个美国的电话号码对网上购买虚拟商品是如此重要。&lt;/p>
&lt;p>要注册一个美国Paypal，首先要能打得开&lt;a href="https://www.paypal.com/us/home">美国Paypal的网站&lt;/a>，然后在注册信息时填写美国的住址，你可以在这个&lt;a href="http://www.shenfendaquan.com/">神奇的网站&lt;/a>随机生成美国身份和地址信息。一直填写到最后一步——验证手机号码，这就到了本文最重要的部分了。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gdb7uqgb0zj21u60q2u0x.jpg" alt="美国Paypal的网站，点击右上角Sign Up注册个账号">&lt;/p>
&lt;p>获得一个美国电话号码，只要打开淘宝搜索「Google Voice账号」，以20元不到的价格购买到一个绑定了美国手机卡的Google Voice账号，就可以用Google Voice提供的虚拟号码来接收美国的短信了。&lt;/p>
&lt;p>Google Voice是Google公司推出的VoIP（基于IP的语音通话）服务，翻译成人话就是虚拟电话号码。你可以通过Google Voice拨打电话、收发短信。Google Voice账号需要绑定一张美国的电话卡，在淘宝购买的Google Voice账号里商家已经替你绑定好了。&lt;/p>
&lt;p>你得到Google Voice账号之后，用它登录到Google Voice的网页端或者手机端，然后在「设置-Google Voice号码」里看到你的虚拟号码，用这个号码注册美区Paypal，就可以正常接收Paypal发来的短信验证码了。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fgy1gdcx400fo2j20n01dsk2c.jpg" alt="⭕️标记多部分就是你的Google Voice号码了">&lt;/p>
&lt;p>有了Paypal账号，你先要在Paypal里绑定你的国内信用卡，Paypal会自动汇款1美元来测试信用卡是否可用（会自动退回给你）。&lt;/p>
&lt;p>最后，用你注册好的任天堂账号进入对应的墨西哥/澳大利亚区的Nintendo eshop，点击右上角头像，在设置里找到paypal的字样，绑定支付方式为刚注册的美国Paypal。&lt;/p>
&lt;p>然后，愉快地购买打折游戏吧！&lt;/p>
&lt;p>特别值得注意的一点是，Google Voice如果长期不用，号码会被Google自动回收，所以为了长期持有号码，最好设定一个日历提醒，每个月使用Google Voice发送一些短信，来保持活跃度。&lt;/p>
&lt;h2 id="美国paypal还能做什么">美国Paypal还能做什么？&lt;/h2>
&lt;p>和国内的Paypal不同，美国的Paypal可以绑定很多大陆地区无法支持的购物平台。例如网上看到的一篇文章提到：&lt;/p>
&lt;ol>
&lt;li>使用中国地址注册的PayPal无法在一些网站下单，比如联想美国站&lt;/li>
&lt;li>一些美国网站搞活动时，只有美国PayPal才能享受折扣或者只有美国PayPal才能试用产品，比如beenverified&lt;/li>
&lt;li>在阿里云国际、Google Play、App Store、Netflix等平台付款&lt;/li>
&lt;li>美国PayPal提现余额到美国银行无手续费，而中国PayPal提现余额到美国银行要收35美元手续费&lt;/li>
&lt;li>中国PayPal间不能相互转帐&lt;/li>
&lt;li>有些网站不接受你的信用卡付款，但把信用卡绑定到PayPal以后却可以正常付款，很明显这是网站为了降低风险，把风险直接丢给PayPal处理&lt;/li>
&lt;/ol>
&lt;p>如此众多的好处，拥有一个美国Paypal看来是居家旅行必备良品。&lt;/p>
&lt;p>以上，就是这一次的教程。喜欢动森的朋友，欢迎转发给更多朋友！&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fgy1gdcy7cnadgj20iw0andn0.jpg" alt="image-20200331112707819">&lt;/p>
&lt;p>本文部分内容参考了&lt;a href="https://blog.shuziyimin.org/">数字移民的博客&lt;/a>。&lt;/p></description></item><item><title>看懂电影《爱尔兰人》</title><link>https://sund.site/posts/2020/2020-3-8_the_irishman/</link><pubDate>Sun, 08 Mar 2020 17:19:49 +0800</pubDate><guid>https://sund.site/posts/2020/2020-3-8_the_irishman/</guid><description>&lt;p>&lt;em>友情提示，本文有轻度剧透，请慎重阅读&lt;/em>。&lt;/p>
&lt;p>说到美国，大家都知道它是个移民国家。美国的爱尔兰裔，占到了总人口的10%以上（&lt;a href="https://zh.wikipedia.org/zh-hant/%E6%84%9B%E7%88%BE%E8%98%AD%E8%A3%94%E7%BE%8E%E5%9C%8B%E4%BA%BA">数据来源&lt;/a>），仅次于德国裔，排在第二位（2000年最新数据显示非洲裔已经超过爱尔兰裔成为美国第二大族群）。爱尔兰裔美国人总数甚至超过了爱尔兰本土的人口数。美国的爱尔兰后裔为何如此之多？这就要从18世纪的爱尔兰说起。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gcmm29s2zwj21co1iwdp1.jpg" alt="美国人口种族分布">&lt;/p>
&lt;p>18世纪末期，英国彻底征服了爱尔兰，使之成为大英帝国的一部分。英国人剥夺了爱尔兰人世代赖以为生的土地，令其在自己的国家成为二等公民。&lt;/p>
&lt;p>爱尔兰人连同土地一起失去的，还有信仰。当时的英国以信仰新教为主，而爱尔兰人普遍信仰天主教。为了打击爱尔兰的天主教势力，同时也为了镇压爱尔兰叛乱，英国人不允许爱尔兰人组织天主教相关的活动，并且法律还规定爱尔兰人既无选举权，也不能充任公职、律师、教师等职业。&lt;/p>
&lt;p>如此严厉的律法，使得爱尔兰人只能从事低级的体力劳动，过着极其贫困的生活。&lt;/p>
&lt;p>政治家埃德蒙·伯克这样形容英国针对爱尔兰的法律（来源：&lt;a href="https://book.douban.com/subject/6892579//">《美国种族简史》&lt;/a>）：&lt;/p>
&lt;blockquote>
&lt;p>自古以来，人类凭借着邪念所能制造出最巧妙的机器，用以使百姓堕落，并进而败坏人性本身。&lt;/p>
&lt;/blockquote>
&lt;p>但上帝给爱尔兰人关闭一扇门的同时，也打开了一扇窗。为了生存和信仰，爱尔兰人在极端严酷的环境下，一边躲避迫害，一边在天主教的精神支撑下抱团取暖。久而久之竟然解锁了他们的种族天赋——强大的地下组织能力。&lt;/p>
&lt;p>19世纪40年代，爱尔兰爆发了大饥荒，上百万爱尔兰人死于饥饿和瘟疫。英国议会对爱尔兰人的漠视，使得爱尔兰土地上成千上万的民众，挣扎着自求生路。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gcmlzyv92aj20u00jbq92.jpg" alt="逃难的爱尔兰人">&lt;/p>
&lt;p>当时的商船从北美出发到英国，需要运载大量的农产品，但是从英国返回美国，则以运输体积较小的工业品为主，这就造成了大量船舱空间没有被利用。于是越来越多的底层爱尔兰人，借助远在美洲的爱尔兰同胞们赞助的钱财，购买这种廉价商船的「蹲票」，挤在狭小的商船货仓里前往北美洲。&lt;/p>
&lt;p>3个月的海上航行漫长而痛苦，无数爱尔兰人在船舱里因为缺水、疾病、饥饿而死去。活下来的少数人终于踏上了向往的新大陆。&lt;/p>
&lt;p>初到美国的爱尔兰人普遍身无分文，也只能从事低级的体力劳动维生，美国的矿工、铁路工人大都是这些人组成，比起南方种植园的黑人奴隶，爱尔兰人的生存境况更差，累死、饿死、工伤死亡的比比皆是。但是多亏了爱尔兰民族的种族天赋：强大的地下工作组织能力！很快，爱尔兰人主导的工人团体相继成立，1861年的美国矿工协会，1903年的国际妇女工会联盟，1905年的世界产业工人联盟……一个个由爱尔兰裔主导，旨在团结底层劳工的工会组织成为了美国重要的政治势力。&lt;/p>
&lt;p>时代成就了爱尔兰人。电影中，吉米·霍法创建的美国卡车司机协会也是这样的一个工会组织。&lt;/p>
&lt;p>看过《美国往事》的同学应该记得，美国在1920年代颁布了著名的禁酒令，在禁运私酒的这段时间，以爱尔兰裔和意大利裔为主的美国黑帮在这一时期通过地下产业迅速壮大。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gcmlugn0f7j20hs0a0dh2.jpg" alt="《美国往事》">&lt;/p>
&lt;p>黑帮控制的地下私酒产业链蓬勃发展，但是这些违法生产的私酒需要大量卡车司机来协助运输。于是，吉米·霍法领导的卡车司机协会就在那段时期和美国黑帮一起，把持着美国的利益链条。&lt;/p>
&lt;p>影片中的男主角弗兰克.希兰就是那个时期成为了一名卡车司机，并结识了黑帮大佬罗素和卡车司机协会的吉米，成为了两边势力的中间人。&lt;/p>
&lt;p>同一时期，违法私酒产业也让另一个对美国影响深远的家族默默崛起，那就是靠着贩卖私酒大赚特赚的&lt;a href="https://zh.wikipedia.org/zh-hant/%E8%82%AF%E5%B0%BC%E8%BF%AA%E5%AE%B6%E6%97%8F">肯尼迪家族&lt;/a>。肯尼迪家族也是爱尔兰后裔。有赖于黑帮势力的支持，约翰·肯尼迪在1961年成功就任美国总统。但是肯尼迪一上任就跳反了，把矛头指向了黑帮和工会，联合司法部长的弟弟罗伯特·肯尼迪一起，打击有组织犯罪和地下产业。&lt;/p>
&lt;p>电影里，吉米每次提到肯尼迪，就恨得暴跳如雷，把对方家里女性长辈都问候一遍。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gcmlsactivj20hs0a240e.jpg" alt="https://tva1.sinaimg.cn/large/4a41845fly1gcmlsactivj20hs0a240e.jpg">&lt;/p>
&lt;p>最终，通过打击犯罪赢得了民众支持的肯尼迪，却深深得罪了爱尔兰人的两大势力。在一次车队游行时，一颗子弹击中了座驾上的肯尼迪头部，瞬间，他的脑浆以放射状飞溅到几十米内的扇形区域，在电视上目睹了这一刻的美国老百姓都惊掉了下巴。与此同时，阴影中的某些人却微微翘起了嘴角，举起了酒杯。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gcmmle3gpsj20m80e3go3.jpg" alt="肯尼迪遇刺现场">&lt;/p>
&lt;p>随后的几年间，包括扣下板机的凶手和司法部长罗伯特·肯尼迪在内100多个证人，相继离奇死亡。这次总统遇刺案成了美国历史上最大的谜团和丑闻，也让调查这起案件的官员受到了强烈质疑。&lt;/p>
&lt;p>电影《爱尔兰人》中暗示，肯尼迪的死和吉米·霍法有着直接的关系。可惜吉米还没高兴多久，自己就因被指控行贿罪而逮捕入狱。&lt;/p>
&lt;p>4年后，吉米出狱，黑帮和工会的格局已经发生了天翻地覆的变化。曾经呼风唤雨的工会已经沦为了黑帮的附庸，这让吉米相当郁闷。在跪舔黑帮大佬和重振工会雄风之间，吉米毅然选择了后者。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gcmj4gdkqsj20za0j47rb.jpg" alt="">&lt;/p>
&lt;p>此时工会已经不复当年的威风，此时的黑帮也已不把吉米放在眼里。吉米和黑帮闹掰之后，身兼工会和黑帮双重身份的男主角弗兰克感到无所适从，一边是自己最好的朋友吉米，一边是恩重如山的老大罗素。最终他会选择站在哪一边呢？&lt;/p>
&lt;p>结局我就不剧透了。感兴趣的朋友请自行去片中寻找答案。&lt;/p>
&lt;p>这部电影在讲述工会和黑帮的恩怨纠葛背后，另一层深意是什么呢？那就是影片的片名：爱尔兰人。&lt;/p>
&lt;p>那是一群在自己的土地被迫害的爱尔兰人，为了寻找新生活而相互扶持，辗转抵达大洋彼岸的新大陆；而又是这样一群爱尔兰族裔，最终为了自己的利益勾心斗角，互相杀伐。其中人性的摇摆，令故事充满了戏剧的张力，成就了这部电影。&lt;/p>
&lt;p>以上，就是我对这部电影的理解。&lt;/p></description></item><item><title>番茄工作法和Keep是绝配</title><link>https://sund.site/posts/2020/2020-2-17_wfh/</link><pubDate>Mon, 17 Feb 2020 20:43:43 +0800</pubDate><guid>https://sund.site/posts/2020/2020-2-17_wfh/</guid><description>&lt;h2 id="要有路线图">要有路线图&lt;/h2>
&lt;p>平时在办公室里，大家可以面对面沟通，有问题、回复都可以迅速得到反馈，好像一个走正步的方队，每个人的节奏都可以从余光中确认。但是在家办公，这种节奏就乱掉了。&lt;/p>
&lt;p>我最近正好转到数据团队做一些数据工程的工作，急需恶补很多知识。我在网上搜到几张数据工程师知识图谱和一些&lt;a href="https://www.coursera.org/specializations/gcp-data-machine-learning">认证课程&lt;/a>。按照自己的能力，我规划了学习路线，并且用Notion记录下来。这份路线图里包含了一些书籍和网络课程，能够帮我快速上手实践，以备在复工后快速进入状态。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gbzm5fb4wrj21go1327oi.jpg" alt="https://tva1.sinaimg.cn/large/4a41845fly1gbzm5fb4wrj21go1327oi.jpg">&lt;/p>
&lt;h2 id="寻找免费的学习资源">寻找免费的学习资源&lt;/h2>
&lt;p>有了路线，就要去找学习资源，付费的电子书和网络教程很多，我想重点说说那些免费资源（抛开盗版不谈），比如著名的动物书出版商 O’Reilly 就有一大堆&lt;a href="https://www.oreilly.com/free/">免费的正版技术类电子书&lt;/a>可供下载。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gbzlq4t8fuj21is1681kx.jpg" alt="https://tva1.sinaimg.cn/large/4a41845fly1gbzlq4t8fuj21is1681kx.jpg">&lt;/p>
&lt;p>另外，&lt;strong>Youtube上的教学视频质量也非常高&lt;/strong>，对于快速上手一种工具或是搭建开发环境非常有帮助。（随便一搜就有很多成套的教学视频，不乏官方教学视频，比如 Google Cloud Platform 提供了很多教学短片）&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gbzlumpbuxj21de14m7mr.jpg" alt="https://tva1.sinaimg.cn/large/4a41845fly1gbzlumpbuxj21de14m7mr.jpg">&lt;/p>
&lt;p>我在Youtube还意外发现一些 &lt;a href="https://www.youtube.com/channel/UCFd-9jAfbuUjwDZjisOwv1w">健身Youtuber&lt;/a> 们分享的健身教学视频，也非常适合闲暇时间提高姿势水平。&lt;/p>
&lt;h2 id="任务要和时间绑定">任务要和时间绑定&lt;/h2>
&lt;p>完成一个长计划的第一步，是拆解任务。工作中同事们总强调 Tasking （拆解任务）的重要性。要保证完成计划的质量，必须把计划按步骤拆解成可执行和回顾的小任务。相信喜欢折腾GTD之类效率工具的人很清楚其中的意义。但是&lt;strong>在没有约束的家庭环境里，光拆解任务可能还不够，更重要的是把任务和时间绑定，给自己一个记录时间的习惯&lt;/strong>。&lt;/p>
&lt;h3 id="不局限于工具的番茄工作法">不局限于工具的番茄工作法&lt;/h3>
&lt;p>番茄工作法固然好，但是市面上很少真正提高效率的工具。手机上的番茄工作法App唯一给我的教训就是增加了我拿起手机的次数。所以我最后矬子里拔大个，选了Toggl 的 Mac桌面版，它自带番茄时钟可以很好的兼顾时间记录和定时提醒功能。我还尝试用NFC贴纸提高我记录时间的效率（主要记录做饭之类碎片的时间）。至于如何使用NFC贴纸，参考这篇《&lt;a href="https://sspai.com/post/57394">5 个实用生活场景，iPhone 上的 NFC 还能这么用》&lt;/a>&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gbzmdw563kj20u01400uv.jpg" alt="https://tva1.sinaimg.cn/large/4a41845fly1gbzmdw563kj20u01400uv.jpg">&lt;/p>
&lt;h2 id="利用番茄工作法的间歇时间做4分钟锻炼">利用番茄工作法的间歇时间做4分钟锻炼&lt;/h2>
&lt;p>番茄工作法每隔25分钟会有5分钟的休息时间，我通常利用这个间隙来做一组俯卧撑、平板支撑或者深蹲，Keep上有很多4分钟的燃脂训练，拿来配合番茄工作法使用效果更佳。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gbzmkewpd0j20n01ds77x.jpg" alt="https://tva1.sinaimg.cn/large/4a41845fly1gbzmkewpd0j20n01ds77x.jpg">&lt;/p>
&lt;h3 id="把平时忽略的碎片时间统计出来">把平时忽略的碎片时间统计出来&lt;/h3>
&lt;p>发呆拖延的时间、做饭的时间，这些工作忙时不太关心的碎片时间，我利用这个大长假把他们统计了一下，我在去年年底制定了一个「2020年告别外卖」的计划。因为平时工作忙，想脱离外卖自己做饭，就要格外注意挑选制作时间短，食材储存容易的饮食方案。我也在Notion里新建了一个项目，来记录做饭的时间、各种食物的优缺点（有点强迫症）。待完成这个计划时我也会整理出来。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/4a41845fly1gbzmwbctjjj20n00wu3zj.jpg" alt="https://tva1.sinaimg.cn/large/4a41845fly1gbzmwbctjjj20n00wu3zj.jpg">&lt;/p>
&lt;h3 id="给娱乐时间限量">给娱乐时间限量&lt;/h3>
&lt;p>我平时很少看电视，最近又把吃灰半年的《歧路旅人》拿出来玩，我给自己规定的是每天必须天黑才能打开游戏机，而且玩到20%电量之前必须关机休息。这样每天娱乐时间就不会超过2个小时。&lt;/p>
&lt;p>最近奥斯卡颁奖后，一批电影片单也出来了，不如趁这段时间把2019年错过的好电影也补一补。&lt;/p>
&lt;h2 id="用音乐和灯光隔离出个人空间">用音乐和灯光隔离出个人空间&lt;/h2>
&lt;p>我在几个月前发的一篇文章&lt;a href="https://mp.weixin.qq.com/s/OuZigL_Y8Ep3rLl38Hxc0A">《用一个模型理解什么是注意力的边缘》&lt;/a>里已经分析过怎么用「聚光灯效应」和背景音乐来创造专注的环境，对这部分感兴趣的同学可以去阅读一下。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>综上，充分利用假期的时间去充电吧，要给自己指定任务、要有追踪任务的工具，多利用闲暇时间锻炼、多关注平时上班时没空去关注的生活细节，给2019年错过的好东西一个补救的机会。&lt;/p></description></item><item><title>如何用七天重建小汤山医院</title><link>https://sund.site/posts/2020/2020-2-5_xiaotangshan/</link><pubDate>Wed, 05 Feb 2020 22:41:23 +0800</pubDate><guid>https://sund.site/posts/2020/2020-2-5_xiaotangshan/</guid><description>&lt;h2 id="苛刻的选址条件">苛刻的选址条件&lt;/h2>
&lt;p>在危机到来时，如何快速建成医院又尽可能降低无畏的成本。首当其冲要考虑的就是选址。选址最重要的是找到具备三个条件的地点：&lt;/p>
&lt;ul>
&lt;li>市政系统成熟&lt;/li>
&lt;li>交通便利&lt;/li>
&lt;li>周边人口稀少&lt;/li>
&lt;/ul>
&lt;p>这三点中任何一点都有大批可选择的位置，但是要求三点同时具备就非常苛刻了。并且因为是传染病医院，还要关注供电保障、排水、排气安全和对周边居民的影响。&lt;/p>
&lt;p>&lt;strong>历史回顾&lt;/strong>：2003 年，北京小汤山在历史中留下了重要一笔。它距离最近的居民点 500 米，原为小汤山疗养院所在地，附近是一大片预留的发展用地，四周环境空旷，便于机械化的施工。京密引水渠在小汤山疗养院北 4 公里，可以让污水经过专门处理，不影响到北京市水源。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbltk2mw5vj30u00kjjuu.jpg" alt="图中上方「H」型建筑群即小汤山医院病房区原址">&lt;/p>
&lt;h2 id="兼具快速与实用的模块化设计">兼具「快速」与「实用」的模块化设计&lt;/h2>
&lt;p>医院的主要功能需求：&lt;strong>&lt;a href="https://mp.weixin.qq.com/s/1n-xp71p0D8odkuZhIvfTg">医患分区分流，洁污分区分流&lt;/a>&lt;/strong>。&lt;/p>
&lt;p>为了满足疫情的需要，医院还要考虑到：施工的&lt;strong>标准化、模块化，根据需要可以不断延伸。&lt;/strong>&lt;/p>
&lt;p>&lt;strong>最终方案定为中轴对称的鱼骨状布局&lt;/strong>。&lt;/p>
&lt;p>医院由多个「H」型模块排列而成。其中，沿中轴线布置办公区域和医护人员通道，每个中心模块负责 4 个护理单元，每个护理单元内安置两列病房（ICU 病房、隔离病房、康复病房等）。&lt;/p>
&lt;p>根据选址地形和现场已有设施，模块排列数量和每个护理单元的长度都可以进行调整。每个护理单元都是独立的标准模块，一方面有利于同时施工，各单位可以独立建好自己的模块后集中拼接，尽量减少交叉作业；另一方面也可以在发生疫情恶化或失火等紧急情况时，将该单元彻底封闭，保全医院其他单元。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbltl8a0frj30u00irtcg.jpg" alt="小汤山医院设计师黄锡璆手机上保存的设计图">&lt;/p>
&lt;p>患者从病房外周进出病区，医护人员从中轴核心经层层更衣和卫生通过区进入病房进行检查、治疗和看护。这样的功能结构能够严格控制空气的洁净梯次，保障医护人员卫生安全。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbltp000lbj30u00lmtdu.jpg" alt="医院内部病人和医护人员行走路线图，图片来自南方周末">&lt;/p>
&lt;p>病房为污染区，医护工作区为半污染区，医护办公区为半清洁区，医护人员值班休息区域为清洁区。医护工作实行&lt;strong>单向通过式流程&lt;/strong>：&lt;strong>病房设有双层玻璃的送饭口，病人和医护人员的通道也各不相同，病人是通过病房门前半开放式的走廊通道进出病房，而医护人员则是从专用的工作通道进出。工作人员从清洁区到病房污染区，要经过几道的消毒，三次更衣。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbltxuh4f2j30qm0i476i.jpg" alt="当年非典时期小汤山医院医护人员向病房内递送食物">&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbltv6x3n5j30mg0qy14e.jpg" alt="网传火神山医院施工人员拍摄的内部视频，图中左侧为工作人员向病房送饭用的双层窗户">&lt;/p>
&lt;h2 id="工程实施">工程实施&lt;/h2>
&lt;p>基于模块化设计的好处，医院可以同时由 6 家施工单位同时施工。&lt;/p>
&lt;p>&lt;strong>历史回顾&lt;/strong>：在 2003 年非典时期，设计团队采用了&lt;strong>边画设计图边施工&lt;/strong>。受到场地和材料限制，每一段的设计图纸都有所不同，为了尽快出图，设计团队几乎是 24 小时接力画图。&lt;/p>
&lt;p>小汤山当时主要是用板材，各家施工队使用的材料都不相同。武汉火神山医院这次采购了大量&lt;strong>集装箱房搭建病房，统一规格，速度更快&lt;/strong>。
不过，集装箱下部的钢框架有可能导致病房与外面走廊之间出现门槛。根据小汤山医院经验，虚弱病人轮椅推行、移动式检查设备推行几率较大，要尽可能满足无障碍推行的使用需求。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1gblufb8qt8j312y0lsu0x.jpg" alt="Google 地图，2003年历史记录，地图中间上方蓝白色屋顶为小汤山医院">&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1gblugzo3a1j31360m0x6p.jpg" alt="同一位置，2019年的 Google 地图，医院原址已经变为一片树林，周边也新盖起了成片别墅">&lt;/p>
&lt;p>武汉火神山医院还&lt;strong>加装风扇来控制气流组织，使空气从中间的干净区域向两边污染区域单向流动&lt;/strong>。&lt;/p>
&lt;p>为保护医院周围的环境不受污染，医院专门新建了污水处理站。病人的衣服、床单出来了以后先通过环氧乙烷消毒，消毒以后才拿去清洗，清洗后的水再进入到污水站处理。此外还有专门的垃圾处理装置对废弃物进行焚烧处理。&lt;/p>
&lt;h2 id="人员管理">人员管理&lt;/h2>
&lt;p>小汤山医院当年出台了《院内预防感染工作规则》《出入流程》《防护守则》，共计 3 章 24 节，约 8000 字，印刷成 46 页的小册子，全院人手一册。包含了医护人员的防护穿戴、与病人的交谈距离、洗手要达到 3 分钟、会议要在室外、洗澡流程、清洁程序、垃圾处理条例、生活区行为守则等等。甚至包括交通规则：医护人员在各区之间的行走路线，在污染区面对面行走时如何避让等等。还规定：违反者将受到通报批评，严重者以军法惩处。&lt;/p>
&lt;h2 id="纪念小汤山医院最好的方式是让它成为历史">纪念小汤山医院最好的方式是让它成为历史&lt;/h2>
&lt;p>当小汤山医院的设计师黄锡璆说出「没想到当年的设计图还能用上」时，心情一定很复杂。&lt;/p>
&lt;p>我在凤凰网 7 年前录制的纪录片&lt;a href="https://www.bilibili.com/video/av85333784?from=search&amp;amp;seid=18365816744222044158" title="《非典十年祭》">《非典十年祭》&lt;/a>中看到这样一段话：&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1gblvg9vmdyj312c0k01kx.jpg" alt="">&lt;/p>
&lt;blockquote>
&lt;p>这如同金字塔一般，从上到下的公共卫生模式，原本是为了统一调配资源，抵御各类传染性流行疾病，然而，2003 年的那个春天，它完全失灵了。&lt;/p>
&lt;/blockquote>
&lt;p>纪录片的结尾处，一位医生感叹道「再也不可能（出现）像SARS那样的情况了」。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1gblvluvuu2j30u00wujuh.jpg" alt="">&lt;/p>
&lt;p>希望这用无数人命堆砌出来的经验，不要下一次面对危机时再次失灵。&lt;/p>
&lt;p>我们应该从历史中学会的，不能仅是如何重建一座医院。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1gblvjvo33aj319o0u0du6.jpg" alt="">&lt;/p></description></item><item><title>谣言的利与弊</title><link>https://sund.site/posts/2020/2020-1-27_rumour/</link><pubDate>Mon, 27 Jan 2020 13:32:46 +0800</pubDate><guid>https://sund.site/posts/2020/2020-1-27_rumour/</guid><description>&lt;p>Ted Chiang（姜峯楠）的小说《双面真相》里有个主人公吉金基，他出生于部落，从小跟着欧洲殖民者学习写字，是部落里唯一识字的人。有一天欧洲殖民者要求多个部落必须按照血缘关系合并起来，以方便殖民管理。部落长老赛维认为自己的部落和临近的部落是同一个祖先，所以应该合并在一起，但是另一个部落却不同意这种说法。&lt;/p>
&lt;p>吉金基想到欧洲人最早来到这里时采访了当地许多老人，那些如今已故的部落老人想必知道自己的部落究竟是谁的后代吧。于是，吉金基跑去殖民者的营地找到了当年的记录，根据记载，长老赛维确实记错了自己的祖先。&lt;/p>
&lt;p>回到部落后，赛维却不同意吉金基的看法，他认为吉金基的头脑已经被欧洲人同化了。「&lt;strong>欧洲人只相信纸面上的文字，而不重视此时此刻部落里人们的感受。至于部落的祖先究竟是谁并不重要，重要的是当下的部落里同族们的共同利益」。&lt;/strong>&lt;/p>
&lt;p>Ted Chiang 在后记里说，人们在「书面文化」出现之前一直延续的是「口头文化」，比起书面文化更重视文字记录的事实本身，口头文化更重视「此时此刻人们的感受」，真相可以随时修改变化，以适应人们的情感需要。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb1m6k8slj31fd0u01kx.jpg" alt="">&lt;/p>
&lt;p>谣言也是一种口头文化，他没有确凿依据，凭借人们口口相传。&lt;/p>
&lt;p>谣言承载了人们此时此刻的感受。把「不信谣，不传谣」当作一种正确的人，可能忽略了谣言的这一重作用：谣言是真相模糊环境的必要补充，是一群人，面对现实的头脑风暴。&lt;/p>
&lt;blockquote>
&lt;p>公众有权质疑、批驳任何报道乃至政府公告的真实性，公民发短信或者转发相关帖子，即使有不实之处，也应被视作自保或者行使监督权，政府部门只能用更加公开透明的信息来平息大家的忧虑，消除不实之言。 ——胡泳，《谣言，作为一种社会抗议》&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbb1mwp2ohj31900u0x43.jpg" alt="">&lt;/p>
&lt;p>同样，&lt;a href="https://www.zhihu.com/pin/1204880834290987008">知乎用户 @韦易笑 的评论&lt;/a>：&lt;/p>
&lt;blockquote>
&lt;p>不传谣本身就是一个严重的传播学悖论，一条未经证实的信息，恰恰需要通过广泛传播、反复交叉比对，最终才能证实或者证伪，去伪存真，辨邪留正。所以未经证明的消息只能称为流言而不是谣言，除非有人故意造谣，这当然有罪，明知是谣言还传播当然也不该，但自己主官判断为真又无法证伪的话，传播无可厚非，因为大部分人只有能力证明自己专业领域内的流言是否是属实，对于专业领域外的流言，只有能力传播没有能力客观鉴别。如果严格要求所有人无法证明就不能传播的话，那么消息就无法通过充分交流比对而去伪存真，大家每天说话的内容也只是不断的重复zf通稿和砖家权威的发言，从而丧失任自我辨别的能力。&lt;/p>
&lt;/blockquote>
&lt;p>你还为「不造谣，不传谣」背书，可能就要提防自己是否过度依赖权威，丧失了亲自辨别真相的能力。&lt;/p></description></item><item><title>如何练习双拼输入法</title><link>https://sund.site/posts/2020/2020-1-19_xnheulpb/</link><pubDate>Sun, 19 Jan 2020 07:21:17 +0800</pubDate><guid>https://sund.site/posts/2020/2020-1-19_xnheulpb/</guid><description>&lt;h2 id="双拼输入法是什么">双拼输入法是什么？&lt;/h2>
&lt;p>「双拼输入法」类似于我们大多人使用的全拼输入法，也是一种基于汉语拼音的汉字输入方案。&lt;/p>
&lt;p>让我们先来复习一下小学的知识😂，任何一个汉字都有对应的拼音，拼音由声母和韵母组成。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb0k5f4cidj30zw0lkq3h.jpg" alt="">&lt;/p>
&lt;p>声母除了&lt;code>zh&lt;/code>，&lt;code>sh&lt;/code>，&lt;code>ch&lt;/code>之外，都是由单个字母表示。例如「拼」字的声母&lt;code>p&lt;/code>。&lt;/p>
&lt;p>韵母通常由1到4个字母组成，例如拼字的韵母就是&lt;code>in&lt;/code>。&lt;/p>
&lt;p>通常大家用的全拼输入法，韵母部分要全部打出来（现代输入法通常可以智能联想，但是大多数情况下都需要你打出大部分字母），比如输入「拼」你需要打三个键&lt;code>p&lt;/code>，&lt;code>i&lt;/code>，&lt;code>n&lt;/code>。&lt;/p>
&lt;p>双拼输入法就是为了解决全拼输入法在输入韵母时低效率的问题。双拼的开发者试图把汉语拼音的全部韵母映射到键盘的所有按键上，这样每次输入一个汉字，只需要输入两个按键（声母+韵母）。&lt;/p>
&lt;p>例如，我把&lt;code>ing&lt;/code>映射到键盘的字母&lt;code>K&lt;/code>上，把&lt;code>ang&lt;/code>映射到字母&lt;code>H&lt;/code>上。输入「乒乓」时就是下面的效果。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb0k63svyhj30ye0nqmyb.jpg" alt="">&lt;/p>
&lt;p>现在比较流行的双拼方案有很多，我选择了比较受大家青睐的小鹤双拼方案。它的键盘布局是下面这样的（初次看你可能会觉得不适……别急，读完这篇文章学起来就会很轻松）。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb0k6aaz1wj30zu0gomym.jpg" alt="">&lt;/p>
&lt;h2 id="双拼输入法能提高打字效率吗">双拼输入法能提高打字效率吗？&lt;/h2>
&lt;p>学习之前我们通常有个疑问：这玩意真能提高打字效率？&lt;/p>
&lt;p>我带着这个疑问，找到了一个测试汉字打字速度的&lt;a href="https://dz.wubidz.cn/">网站&lt;/a>，我通过一个月的使用，对比了前后的输入速度，得出的答案让我确信写这篇文章能够帮助你通过双拼提高打字效率。（不要吐槽我每分钟字数太少，测速网站采用了古诗词作为输入，一定程度上屏蔽输入法智能联想的效果。你可以亲自去尝试一下😛）&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb0k6h6c7fj311m076q3u.jpg" alt="">&lt;/p>
&lt;p>（KPM=每分钟按键次数，BPM=每分钟退格次数）&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb0k6ldcpmj31780ni762.jpg" alt="">&lt;/p>
&lt;h2 id="开始学习小鹤双拼">开始学习小鹤双拼&lt;/h2>
&lt;p>学习知识之前，先了解它的原理会帮助我们更容易记忆它。理解原理看似是增加了额外的负担，但是死记硬背的知识往往难以形成结构化的记忆，很容易遗忘。&lt;/p>
&lt;p>学习小鹤双拼前，我们先要了解三件事：&lt;/p>
&lt;ul>
&lt;li>声母的按键规律&lt;/li>
&lt;li>韵母的按键规律&lt;/li>
&lt;li>键盘布局的规律&lt;/li>
&lt;/ul>
&lt;h2 id="声母的规律">声母的规律&lt;/h2>
&lt;p>前面提到，汉语拼音声母大多数是单个字母，除了三个特别的&lt;code>zh&lt;/code>，&lt;code>sh&lt;/code>，&lt;code>ch&lt;/code>。小鹤双拼和全拼一样，直接按字母键就可以输入对应的声母，那三个特别的声母映射到键盘的&lt;code>V&lt;/code>，&lt;code>U&lt;/code>，&lt;code>I&lt;/code>上。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb0k6qxjc2j30z40hqt9m.jpg" alt="">&lt;/p>
&lt;p>之所以映射成&lt;code>zh=V，sh=U，ch=I&lt;/code>，是考虑到两个因素：&lt;/p>
&lt;ul>
&lt;li>这三个字母（V，U，I）都没有对应声母&lt;/li>
&lt;li>这三个字母距离食指和中指都比较近&lt;/li>
&lt;/ul>
&lt;p>那有人要问了，为什么不把&lt;code>zh&lt;/code>放在&lt;code>Z&lt;/code>上，&lt;code>ch&lt;/code>放在&lt;code>C&lt;/code>上，&lt;code>sh&lt;/code>放在&lt;code>S&lt;/code>上，这样更好记忆呀？这是因为会造成输入的不一致性。比如&lt;code>O&lt;/code>对应的韵母是&lt;code>uo&lt;/code>，你输入了&lt;code>ZO&lt;/code>，那输入法就无法分辨你输入的是&lt;code>zhuo&lt;/code>（捉），还是&lt;code>zuo&lt;/code>（作）。如此一来就违背了双拼输入法一个汉字只要输入两个键的原则。&lt;/p>
&lt;p>&lt;strong>所以，声母部分，你只要记住，&lt;code>zh&lt;/code>，&lt;code>sh&lt;/code>，&lt;code>ch&lt;/code>，对应的是&lt;code>V&lt;/code>，&lt;code>U&lt;/code>，&lt;code>I&lt;/code>就可以了。其他和全拼一毛一样。&lt;/strong>&lt;/p>
&lt;h2 id="韵母的规律">韵母的规律&lt;/h2>
&lt;p>汉语拼音的韵母有一些很特殊，例如&lt;code>ua&lt;/code> 和&lt;code>ia&lt;/code>前边的声母是&lt;strong>互斥&lt;/strong>的。以&lt;code>jia&lt;/code>（加）为例，你肯定没听过&lt;code>jua&lt;/code>的组合（可能小岳岳除外😂）。所以&lt;code>ua&lt;/code>和&lt;code>ia&lt;/code>前边的声母不可能是同一个字母，那么即使把这两个韵母放在同一个按键上，也不会出现输入汉字时的混淆。&lt;/p>
&lt;p>符合这种规律的韵母一共有7对，小鹤双拼的按键分布是下面这样的。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb0k7d1dl4j30ww0fat9w.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>为了方便记忆，小鹤双拼让每个按键对应的声母和其中一个韵母能组合成有意义的汉字发音。所以你只需按口诀或文末提到的练习工具针对练习即可，其中需特殊训练的只有上面的7个按键。&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb0k7iqinjj30vm07qt9p.jpg" alt="">&lt;/p>
&lt;p>有一些汉字没有声母（零声母），这种情况只要会全拼输入法就可以一秒解决：&lt;/p>
&lt;p>单字母韵母，如： 啊＝aa 哦=oo 额=ee&lt;/p>
&lt;p>双字母韵母，如： 爱＝ai 恩=en 欧=ou&lt;/p>
&lt;p>三字母韵母，零声母+韵母所在键，如： 昂＝ah&lt;/p>
&lt;h2 id="键盘布局的规律">键盘布局的规律&lt;/h2>
&lt;p>一些不太常用的韵母，小鹤双拼的作者把它们放到了键盘的边边角角，例如&lt;code>iu&lt;/code>，&lt;code>ie&lt;/code>，&lt;code>ou&lt;/code>，我起初很容易忘记，偶尔用到也想不起这些韵母的位置。所以这三个特殊按键，我在键盘上用蓝色高亮标记起来。结合上文提到的特殊按键，这个键盘看起来就是这样三层结构：&lt;/p>
&lt;ul>
&lt;li>第一层是声母，其中特殊的（红色高亮）是&lt;code>V&lt;/code>，&lt;code>U&lt;/code>，&lt;code>I&lt;/code>&lt;/li>
&lt;li>第二层是韵母，其中特殊的（黄色高亮）是&lt;code>T&lt;/code>，&lt;code>O&lt;/code>，&lt;code>S&lt;/code>，&lt;code>K&lt;/code>，&lt;code>L&lt;/code>，&lt;code>X&lt;/code>，&lt;code>V&lt;/code>&lt;/li>
&lt;li>第三层是易忘按键（蓝色高亮），它们分别是&lt;code>Q&lt;/code>，&lt;code>P&lt;/code>，&lt;code>Z&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb0k7s2bcdj30wk0fmaba.jpg" alt="">&lt;/p>
&lt;p>你可以把这张图保存起来，放在桌面壁纸里或是打印出来放在键盘前边，练习时用来对照。&lt;/p>
&lt;h2 id="记忆工具">记忆工具&lt;/h2>
&lt;p>小鹤双拼&lt;a href="https://www.flypy.com/index.html">官网&lt;/a>提供了多种练习工具。你可以微信扫一扫这个小程序，随时用手机练习。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb0k7zwgpej307g07gq3l.jpg" alt="">&lt;/p>
&lt;p>桌面端推荐一个在线的&lt;a href="https://api.ihint.me/shuang/">网页双拼练习工具&lt;/a>，地址是 &lt;a href="https://api.ihint.me/shuang/">https://api.ihint.me/shuang/&lt;/a>。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb0k86lfwlj31op0u0n4p.jpg" alt="">&lt;/p>
&lt;h2 id="测试工具">测试工具&lt;/h2>
&lt;p>为了测试打字速度，你可以使用上文提到的&lt;a href="https://dz.wubidz.cn/">在线网页打字测速工具&lt;/a>，地址是&lt;a href="https://dz.wubidz.cn/">https://dz.wubidz.cn/&lt;/a>。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>本文以小鹤双拼为例，为你分析了汉语拼音组合原理和双拼输入法的映射规律。未来你在学习任何拼音输入法时都可以按照这种规律，以分层结构提高对键盘布局的认识。&lt;/p>
&lt;p>从练习时间角度，掌握双拼要一周左右，超过全拼打字速度也只需要两周多。所以双拼是非常值得学习的输入方案。&lt;/p>
&lt;p>目前所有平台都有比较成熟的双拼输入法App，例如iOS和Mac系统自带的双拼输入法、Google的移动端输入法Gboard。某些国产输入法，在我的测试下经常会出现「过度联想」的问题，比如输入一个字母，自动联想出一个甚至更多汉字，这和双拼输入法一个汉字两个字母的敲键节奏稍有违背，我个人倾向于在移动端使用Gboard或默认输入法。&lt;/p>
&lt;p>你若有更好的想法和推荐，欢迎在留言区留言。&lt;/p></description></item><item><title>宁波见闻</title><link>https://sund.site/posts/2020/2020-1-5_ningbo/</link><pubDate>Sun, 05 Jan 2020 20:49:47 +0800</pubDate><guid>https://sund.site/posts/2020/2020-1-5_ningbo/</guid><description>&lt;h2 id="木匠的工具箱">木匠的工具箱&lt;/h2>
&lt;p>偶然在宁波博物馆发现一个箱子。这是木匠的工具箱，有点像很多格子的单肩包。外侧可以放几把不同尺寸的刨子，内侧用来放锯子和一些长柄的工具。下层的抽屉还可以放些锉刀、凿子之类的小物件。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1galvuygesgj31hc0u0he2.jpg" alt="image-20200105185453400">&lt;/p>
&lt;p>有了它，木匠就可以拎包上门。过去很多行业的手艺人都有一套这样的工具箱。木匠比较不同的是，这个箱子本身也是木制的，这个箱子就是他展示给客户的第一印象，箱子本身代表了木匠的能力和喜好。&lt;/p>
&lt;p>现在搞技术的人，也是手艺人，但已经很少把自己的「工具箱」秀给别人看了。&lt;/p>
&lt;p>我前几天跟鲍勃聊天，他最近一直忙着装修自己家。他家全部是由他亲自设计的。虽然家具不是他做的，干活儿的也是请来的工人，但是那些方案的确是出自他的脑袋，所以说是他亲自装修也一点都没错。&lt;/p>
&lt;p>那是什么决定了哪些东西是你买来的，哪些是你自己设计的呢？重要的一定不是物品怎么被造出来，而是物品里有没有包含你的思考吧。当一堆零件通过你的智慧彼此关联在一起，产生了「整体大于局部之和」的效果，这个物品就具有了你的一部分主张。&lt;/p>
&lt;p>任何物品里都有设计者的主张，服务也不例外。&lt;/p>
&lt;p>我经常觉得宁波的地铁和餐厅的服务十分不友好：明明服务人员就在旁边站着，你向他求助，他却只会告诉你去扫一下二维码。强制你扫二维码的服务，它们背后的主张都是&lt;/p>
&lt;blockquote>
&lt;p>为了省点人力成本，就暂且给你添点麻烦吧。&lt;/p>
&lt;/blockquote>
&lt;h2 id="清淤船和asmr">清淤船和ASMR&lt;/h2>
&lt;p>经过宁波老外滩，看到清淤船在江上作业。围观的路人有几十人，都看得兴起。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwly1galyam1mk1j31400u04r6.jpg" alt="image-20200105201858038">&lt;/p>
&lt;p>看着清淤船从江里把淤泥挖出来，再倾倒在旁边的船上，莫名有种视觉ASMR的感觉。好像人天生就对「疏通」这件事会有快感（比如挖鼻孔🤣）。&lt;/p>
&lt;p>巧合的是我之前很喜欢听静电容键盘敲击的声音。好像两手紧握再松开时，空气从两手中间被挤压时发出的声音。我经过宁波博物馆附近的一处马路，突然听到汽车经过石头路面时发出的声音，竟然有些相似。&lt;/p>
&lt;p>&lt;a href="https://mp.weixin.qq.com/mp/audio?_wxindex_=0&amp;amp;scene=104&amp;amp;__biz=MzIyNzI2MTU2Mg==&amp;amp;mid=2650640682&amp;amp;idx=1&amp;amp;voice_id=MzIyNzI2MTU2Ml8yNjUwNjQwNjgx&amp;amp;sn=b99ca12aa1a7b569beffa20f9ca6dd16#wechat_redirect">点击收听&lt;/a>&lt;/p></description></item><item><title>一篇心得，开始2020年写作之旅</title><link>https://sund.site/posts/2019/2019-12-28_learn-to-write/</link><pubDate>Sat, 28 Dec 2019 18:49:56 +0800</pubDate><guid>https://sund.site/posts/2019/2019-12-28_learn-to-write/</guid><description>&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gacm51mivyj31900u0qv5.jpg" alt="iga-palacz-zG0LiuCEMvA-unsplash">&lt;/p>
&lt;p>养成写作的习惯，会使人生获益无穷。写作可以让我们避免浅显的认识，在搜索引擎几秒钟就能得到答案的时代，学会向自己提问是深度思考的第一步。我真的理清脉络了吗？是不是像我认为的那样？写作者分享思想，同时也帮助自己思考。&lt;/p>
&lt;p>写作让我们在和他人交流时懂得&lt;strong>去理解&lt;/strong>，不是急着&lt;strong>去回应&lt;/strong>。常写作的人会时刻收集素材，养成倾听的习惯。写作的人喜欢片刻的沉默，胜过表面的热闹。&lt;/p>
&lt;p>&lt;strong>会说话的人就会写作&lt;/strong>。很多人拒绝写作，是觉得自己文笔不好，其实白话口语一样能写出好文章，精巧的构思，敏锐的嗅觉，缜密的思考，哪一种写作风格都有适合自己的路。&lt;/p>
&lt;p>三个月前，我开始刻意培养写作的习惯。这篇文章，我要与你分享这段时间的心得，这些话，有的来自我个人的体会，有的是来自记录的笔记，有的出自著名作家、编剧，我把它们整理出来，希望帮你启动写作之旅。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gacmbh2ebzj316w0u0goo.jpg" alt="matt-artz-pY_AZJfdbHQ-unsplash">&lt;/p>
&lt;h2 id="写文章的关键是什么">写文章的关键是什么？&lt;/h2>
&lt;p>诗人彼得·迈因克说，文学的表现力来自&lt;strong>专注、巧妙和精细&lt;/strong>。&lt;/p>
&lt;p>每篇文章都要&lt;strong>专注于一点，这一点就是主题&lt;/strong>，内容都在围绕这一点展开。想象一本书带给过你的感受，那就是它传达给你的主题，论文里它是论点，故事里它是基调，评论里它是观点。&lt;/p>
&lt;p>文章还要&lt;strong>巧妙地搭建结构&lt;/strong>，像电影导演的运镜，把观众的视线引向你希望的方向，带领读者走向你预设的终点。&lt;/p>
&lt;p>好的&lt;strong>文笔是精细的提炼&lt;/strong>，字斟句酌的金句，给读者的是惊喜，是&lt;strong>寻常的陌生感&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gacm9oidbcj31960u0tmr.jpg" alt="laurynas-mereckas-bn3sUs9JUck-unsplash">&lt;/p>
&lt;h2 id="如何寻找主题">如何寻找主题？&lt;/h2>
&lt;p>&lt;strong>关注每个细节，每个引起你兴趣、兴奋、疑惑、恐惧、异物感的东西&lt;/strong>。读书是最简单的方法，除此之外，留心生活中有趣的短文、诗句、格言、广告、寓言、祈祷、标语、微博、短信……都是灵感的源泉。不把自己的生活局限在网络上，线下和朋友交流，参加有趣的活动、认识有趣的人、体验不一样的生活，都能让你产生写作的冲动。&lt;/p>
&lt;p>&lt;strong>不断向自己提问&lt;/strong>，即便是再小的问题，也有无限挖掘下去的潜力。不断提出问题尝试去回答！搜索网络、求助他人、翻阅资料，总之在写出答案之前，你一定是深思熟虑过，不要给读者向你提问的机会，穷尽所有可能的路径、绞尽脑汁，这样的文章才是系统性思考过的、有价值的，对得起自己和读者的。&lt;/p>
&lt;p>一旦养成这样的习惯，不只是写作，生活的一切都从日复一日的重复中苏醒过来了。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gacm628ehij31900u0hdt.jpg" alt="alejandro-escamilla-y83Je1OC6Wc-unsplash">&lt;/p>
&lt;h2 id="如何搭建文章的结构">如何搭建文章的结构？&lt;/h2>
&lt;p>有了主题，接下来的任务是布局，美感出自秩序。生活是个局，工作也是个局，你的文章更是让读者短暂逃离现实的局。&lt;/p>
&lt;p>首先，&lt;strong>开头请一定要激发读者强烈的兴趣&lt;/strong>，可以设置一个谜题让读者自行去文中寻找答案；也可以是一个具体的场景，让读者身临其境后逐渐察觉异样。请看小说《追风筝的人》的开头：&lt;/p>
&lt;blockquote>
&lt;p>我成为今天的我，是在1975年某个阴云密布的寒冷冬日，那年我十二岁。&lt;/p>
&lt;/blockquote>
&lt;p>是不是让人很好奇，想要读下去。即使你的文章是知识分享，也要注重故事性，从古至今流传下来的道理，都蕴含在故事里。&lt;/p>
&lt;p>其次，&lt;strong>不要倾倒细节，要有一个看不见的线牵引着读者&lt;/strong>，可以是时间、空间、疑问。如果你要抛出一个观点，就全文都以这个观点为核心，让所有文字都通向那个观点；如果你要构思一个的故事，请把故事的结构隐藏起来，让读者自行去发现。&lt;/p>
&lt;p>例如在《白夜行》中，两位主角活在各自的世界里，东野圭吾用并行故事线构成了看不见的线索，让读者自行脑补两人关系，画出故事的来龙去脉。所以，请把发现真理的过程交给读者。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gacm5wjsaaj31mz0u0wt1.jpg" alt="delfi-de-la-rua-vfzfavUZmfc-unsplash">&lt;/p>
&lt;p>最后，&lt;strong>既要让文字满足读者期望，又不可预测&lt;/strong>。这要求乍看有点奢侈。人们不喜欢在故事里重复生活，也不喜欢完全脱离生活的故事。请不要平铺直叙，更不要太跳脱，要给读者制造舒适区，再打破它。读文章就像谈恋爱：「男人彻底地懂得了一个女人之后，是不会爱她的」。（出自张爱玲的短篇小说）&lt;/p>
&lt;h2 id="如何锻炼文笔">如何锻炼文笔？&lt;/h2>
&lt;p>&lt;strong>文笔是锦上添花，开始写作前请不要纠结&lt;/strong>，尤其是知识分享、论述观点类文章，比文笔更重要的是逻辑。&lt;/p>
&lt;p>第二，&lt;strong>一句自我介绍，一条微博，都是最小粒度的写作&lt;/strong>。每次发微博、Twitter、朋友圈，都请字斟句酌，变成语言的艺术家。&lt;/p>
&lt;blockquote>
&lt;p>有些词语的周围需要全然安静，给它们足够的空间，就好比照片，有些照片周围不需要陪衬。&lt;/p>
&lt;p>——阿摩司·奥兹&lt;/p>
&lt;/blockquote>
&lt;p>每次写作，&lt;strong>请有意识地删除多余的副词、形容词，如果写故事，把那些形容感受的词（如「沮丧」、「快乐」）替换成具体的动作和神态&lt;/strong>。原研哉在《设计中的设计》说，「我们通常所说的五感，是非常不准确的，用指尖轻轻触碰的触感，和用手用力按压的触感肯定是不一样的」。所以，&lt;strong>请去描写感受，不要概括感受&lt;/strong>。&lt;/p>
&lt;p>最后，&lt;strong>请熟练使用口语写作，避免官方用词&lt;/strong>。尤其练习使用俗语、方言、俚语或其他习语。在我们国家，经常看到：「只有……才能」、「坚决落实」、「时刻牢记」。请把这些短语从脑袋里清出去，除非你打算写反乌托邦题材……&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gacm5b3k75j31900u0b29.jpg" alt="reuben-juarez-C4sxVxcXEQg-unsplash">&lt;/p>
&lt;h2 id="写在最后">写在最后&lt;/h2>
&lt;p>上面这些技巧，都是写作的外功，要理解它的内功，还是要长期保持写作者的心态。写作是一种自我重建——这句话出自新京报的一篇文章《纪念王小波》，我非常喜欢下面这段话，最后分享给你：&lt;/p>
&lt;blockquote>
&lt;p>对一个人来说，过去那种统一式教育所打造的自我，是一种童稚状态，人只有通过自我的重建，才能走向成熟。这种重建是一种孤独的旅程，一旦开始，就注定没有终点，你将作为「一个人」而不是「我们」中的一员，来面对世界。&lt;/p>
&lt;/blockquote></description></item><item><title>互联网曾经有另一种可能</title><link>https://sund.site/posts/2019/ted-nelson/</link><pubDate>Sun, 15 Dec 2019 16:42:22 +0800</pubDate><guid>https://sund.site/posts/2019/ted-nelson/</guid><description>&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9xipmwzxxj313s0oaqm6.jpg" alt="《Computer Lib》">&lt;/p>
&lt;p>&lt;em>1965年，泰德·尼尔森（Ted Nelson）在提交给美国计算机协会的论文中提到一种将各种内容链接在一起的技术——超文本（Hypertext），如今超文本俨然已是互联网大厦的基石。但人们熟知的超文本和当初尼尔森预想的样子却有着天壤之别——在尼尔森的脑海中，一个失落的平行世界里，有着万维网的另一种可能。&lt;/em>&lt;/p>
&lt;h2 id="泰德尼尔森">泰德·尼尔森&lt;/h2>
&lt;p>尼尔森从小就是个爱幻想的孩子。深受导演父亲的影响，尼尔森酷爱写作，但他厌恶线性、渐进式的叙事结构，他希望所有资料都以一种混乱的，流动的形式保存起来。这样，每当他需要这些资料时，他就可以随时重建它们。如今已经80岁的尼尔森仍保存着数千小时自己的录音和录像，以备后人理解他的想法。这些录音和录像，同样也是没有目录结构的……&lt;/p>
&lt;h2 id="层级结构是邪恶的">层级结构是邪恶的&lt;/h2>
&lt;p>尼尔森把对传统结构的抵制延续到了计算机时代。1960年，尼尔森在哈佛读研究生期间试图自己编写一个拥有「并排比较」、「版本回溯」和「按大纲修改」功能的写作工具，但因为非科班出身和学业繁忙，最终放弃了开发。当时哈佛大学正在开发一套计算机辅助教学系统，尼尔森觉得那种线性的、机械的教学系统，是对计算机和教学的双重侮辱。&lt;strong>思维应该沿着不同的路径探索，而不是以结构定义好的方式&lt;/strong>。&lt;/p>
&lt;p>尼尔森在90年代曾对苹果公司的 Macintosh 操作系统也持有同样的评价：&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>
&lt;p>在我看来，Macintosh 和 PC 没有差别。Macintosh 的交互做得更好，但是它和 PC 都是一样的概念结构，都是由 PARC 用户界面（PARC User Interface, PUI）与普通的层级架构目录（即如今所说的「文件夹」）组成。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>他们告诉你文件是分层级的；最基础的程序就是文字处理、数据库与电子表格；你必须使用「应用」；你必须费力地把自己真正想做的事处理成层级架构的文件，用「特定的应用」打开它们。实际上，这些陈述都夹杂着谎言。他们描述了计算机的现况，但没说它可以是什么样，又应该是什么样。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>——摘自《离线 OFFLINE》ISSUE 23，上都计划——失落的超文本，泰德·尼尔森语录&lt;/p>
&lt;/blockquote>
&lt;h3 id="尼尔森的超文本设想">尼尔森的超文本设想&lt;/h3>
&lt;p>时间回到1965年，尼尔森把自己的设想——一个由「超文本」和「压缩列表」技术构成的非顺序写作系统，发表在了全国计算机协会的论文中。起初这篇论文并没有引起太多人关注，但超文本这个词却意外被历史保留了下来。尼尔森在不久之后发起了名为「上都计划」的项目。上都（Xanadu）的名字来自诗人&lt;a href="https://baike.baidu.com/item/%E6%9F%AF%E5%8B%92%E5%BE%8B%E6%B2%BB/7281438?fromtitle=%E6%9F%AF%E5%B0%94%E5%BE%8B%E6%B2%BB&amp;amp;fromid=2108499">萨缪尔·柯勒律治（Samuel Taylor Coleridge）&lt;/a>在他的诗中幻想的忽必烈在元上都修建的雄伟宫殿。&lt;/p>
&lt;blockquote>
&lt;p>忽必烈汗在上都造建，富丽堂皇的穹顶宫殿，伴有圣河阿尔佛，穿过深不可测的岩洞，一直流入无光之海&lt;/p>
&lt;p>——萨缪尔·柯勒律治&lt;/p>
&lt;/blockquote>
&lt;p>在尼尔森的构想中，上都计划是一个拥有非线形结构的交叉索引系统——&lt;/p>
&lt;ul>
&lt;li>&lt;strong>任何媒体内容双向链接&lt;/strong>，可以在平行文本之间自由跳转，一直追溯到内容的源头&lt;/li>
&lt;li>&lt;strong>拥有深度的版本管理&lt;/strong>，每次对文本的修改都以版本号记录下来，以便追溯变更历史&lt;/li>
&lt;li>&lt;strong>版权授权机制&lt;/strong>，由于历史可追溯，所以内容理论上都可以追溯到原作者&lt;/li>
&lt;li>&lt;strong>可视化的差异对比&lt;/strong>，不同版本的内容可以比较差异，基于原文的修改可以同步到引文&lt;/li>
&lt;li>&lt;strong>创作者可以基于已有内容进行增量出版&lt;/strong>，类似滚动更新机制&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga0umu3r7uj30zk0ixb1i.jpg" alt="较早时期设计的 Xanadu 系统">&lt;/p>
&lt;p>尼尔森认为，&lt;strong>层级的目录结构是一种专制&lt;/strong>。创作者应该时刻与媒体内容保持联系，而不应该关心它保存在哪。在尼尔森的理想里，文件夹是罪恶的，基于文件夹的树形目录结构更是丑陋。它代表了人类根深蒂固的层级观念在虚拟世界的投影。建立于层级观念之上，思维只会被束缚，&lt;strong>真正的计算机，应该给予人类自由&lt;/strong>。&lt;/p>
&lt;p>尼尔森更不喜欢别人用基于超文本概念创造出来的HTML（HyperText Markup Language，超文本标记语言），尼尔森批评道：&lt;/p>
&lt;blockquote>
&lt;p>它（HTML）的链接容易失效且只能单向链出，它的引文无法追溯，没有版本控制，也没有版权管理系统。&lt;/p>
&lt;/blockquote>
&lt;p>几经辗转，在资金等各方面条件都极其匮乏的情况下，上都计划在2014年终于发布了一个功能不完备的演示版本，我们可以在浏览器访问&lt;a href="http://xanadu.com/">上都计划的官网&lt;/a>查看它的最新状态。尼尔森还开通 Youtube 频道 &lt;a href="https://www.youtube.com/channel/UCr_DXJ7ZUAJO_d8CnHYTDMQ">TheTedNelson&lt;/a> 给大众布道，可惜截止到我写下这些字的时候，订阅人数还不足6000，在中文世界更是鲜有人报道。&lt;/p>
&lt;p>如今的万维网已技术沉淀多年，尼尔森的计划在不少专业人士看来，如柯勒律治的诗一般，只是天方夜谭。&lt;/p>
&lt;blockquote>
&lt;p>超文本不是技术，是文学。文学是指那些我们包装并存储的信息（一开始是书籍、报纸和杂志，现在还有电影、录音、CD-ROM 等）。未来的文学类型决定了人类将被如何记录和理解。这些还轮不到「技术专家」来操心。&lt;/p>
&lt;p>——《离线 OFFLINE》ISSUE 23，上都计划——失落的超文本，泰德·尼尔森语录&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9xj9jfbq1j30zk0hsdl8.jpg" alt="OpenXanadu，推迟了54年之后的 Demo">&lt;/p>
&lt;h3 id="对当今互联网的启发">对当今互联网的启发&lt;/h3>
&lt;p>在现在的互联网技术体系内，尼尔森的理想几乎不可能成为现实。但就像&lt;a href="https://book.douban.com/subject/25985021/">《人类简史》&lt;/a>里的尼安德特人，种族虽然消亡，基因却融入了智人的血脉。上都计划以另一种形式融入了现在互联网的产品中。&lt;/p>
&lt;p>上都计划在当时提出的概念是相当超前的，我们可以在很多工具中找到它的影子。&lt;/p>
&lt;p>它给我的第一印象是一个文字处理的IDE（集成开发环境），它具备了当代IDE的大部分特性，并且非常有前瞻性的提出了基于版本的授权机制，这和现在不少基于区块链-智能合约的版权管理项目有异曲同工之妙。&lt;/p>
&lt;p>同时，上都计划也在试图打造一个类似 &lt;a href="https://www.literatureandlatte.com/scrivener/overview">Scrivener&lt;/a> 卡片或&lt;a href="https://www.yinxiang.com/blog/blog/2019/07/18/%E5%85%A8%E6%96%B0%E3%80%8C%E7%B4%A0%E6%9D%90%E5%BA%93%E3%80%8D%E5%8A%9F%E8%83%BD%E4%B8%8A%E7%BA%BFios%E5%8F%8Amac%E7%AB%AF/">印象笔记素材库&lt;/a>的非线性写作环境，泰德·尼尔森在很早就预见到当时计算机书写环境的弊端，并对后来微软和苹果推出的办公软件嗤之以鼻。他有着那批60年代「老极客」的开放精神，推崇 Unix-like 「一切皆文本」的管理方式和滚动增量更新的系统机制。&lt;/p>
&lt;p>不少人会第一时间想到 &lt;a href="https://www.notion.so/desktop">Notion&lt;/a>，它也有着尼尔森所谓的非层级、链接一切媒体内容的能力。不可否认 Notion 的确优秀，但它本质还是基于 web 技术的链接跳转，它并不符合尼尔森的&lt;strong>对内容双向索引&lt;/strong>的要求。尼尔森的终极理想，是一个有版本控制的互联网。&lt;/p>
&lt;h2 id="写在最后">写在最后&lt;/h2>
&lt;p>写这篇文章前，我又翻看了&lt;a href="https://www.weibo.com/theoffline?is_all=1">《离线》&lt;/a>在第23期关于上都计划的介绍，结合我之前写的那篇&lt;a href="https://sspai.com/post/57735">《我们的隐私被谁拿走了？斯诺登的新书告诉我们的真相》&lt;/a>，赫然发现不同时代的 Hackers 想要打造的乌托邦和现实世界之间存在一个巨大的鸿沟，那里面是理性的力量想要改造混乱世界的强烈冲动。可现实往往不遂人愿，假如尼尔森的上都计划被用来煽动仇恨、传播犯罪，那时他又将怎样面对呢？理想终究要面对各种不确定的因素考验吧。但尼尔森对互联网种种弊端的质疑，仍然对现在的我们有启发。&lt;/p>
&lt;p>上都计划固然脱离现实，但它的存在本身就是对僵化世界的反抗，犹如古希腊哲学家描绘的理想乡——凡人仰望那绮丽的幻境，模仿它的样子改造自己的家园。&lt;/p></description></item><item><title>我们的隐私被谁拿走了</title><link>https://sund.site/posts/2019/permanent-record/</link><pubDate>Sun, 08 Dec 2019 02:41:29 +0800</pubDate><guid>https://sund.site/posts/2019/permanent-record/</guid><description>&lt;p>斯诺登的自传《永久记录》已经上架各大阅读平台。这本书让斯诺登的名字从棱镜门之后又一次出现在了公众视野里。书里按时间线叙述了他的童年和工程师父亲学习计算机，到他加入中情局，最后曝光棱镜计划出逃俄罗斯的全过程。这本书是一个青年成长为公民，并用自己的勇气揭露科技霸权的心路历程。我特别注意到这部书里提到了一个概念——个人信息的&lt;strong>元数据&lt;/strong>，元数据是一个人在网络上留下的痕迹，不管是对情报机构，还是对商业公司，都是要极力获取的重要信息。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9pm9nt8joj30u016y45h.jpg" alt="《永久记录》">&lt;/p>
&lt;h2 id="元数据是我的聊天内容或个人资料吗">元数据是我的聊天内容或个人资料吗？&lt;/h2>
&lt;p>元数据不是你聊天的内容也不是你的资料，更不是你在网上发布了什么消息，元数据是更底层的数据，斯诺登在书里这样描述它：&lt;/p>
&lt;blockquote>
&lt;p>最直接理解（元数据）的方式是活动数据：你在设备上从事活动、手机自动运行的记录。举例来说，手机元数据可能包括：来电日期与时间、通话时长、来电号码，通话位置……&lt;/p>
&lt;/blockquote>
&lt;p>通过分析你不同设备的元数据，监视者能得知你昨晚入睡与今早起床的时间、每天逛了哪些地方、在哪里待了多久，以及你接触过的对象有谁，谁又与你联系过。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9p9pylzx3j31900u0e81.jpg" alt="">&lt;/p>
&lt;h2 id="为什么你的元数据如此重要">为什么你的元数据如此重要？&lt;/h2>
&lt;p>事实上，元数据不仅仅赋予了数据监视者全面窥探你隐私的权利，在2002年斯皮尔伯格拍摄的电影《少数派报告》中有这样的桥段（有剧透）：未来的某一天，人类能够利用计算机预测可能的犯罪，并在「嫌疑犯」准备实施犯罪前进行抓捕，幕后黑手利用这一机制构陷男主角，使其成为系统认定的抓捕对象。&lt;/p>
&lt;p>科幻故事离我们太远，你可能觉得现实中没有这样的系统。那么请看一些事实吧：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.gov.cn/fuwu/2018-10/22/content_5333353.htm">我国征信系统已为9.7亿自然人建信用档案&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://newspaper.jcrb.com/2019/20191125/20191125_004/20191125_004_4.htm">无偿献血、公租房申请、ETC欠费、乱闯红灯、频繁跳槽等行为纳入个人征信系统&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.qdaily.com/articles/47431.html">中国安装了1.76亿个监控摄像头，这市场还在增长&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.zhihu.com/question/64794171">社交软件 Instagram 被怀疑窃听用户麦克风&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.xinhuanet.com/world/2019-08/15/c_1210242325.htm">Facebook 承认监听用户语音，将语音资料转录为文字&lt;/a>&lt;/li>
&lt;li>……&lt;/li>
&lt;/ul>
&lt;p>斯诺登在《永久记录》中提到，美国中央情报局的监控系统，可以随时打开全球任何人的摄像头、麦克风和查看电脑上正在做的事、调查他的上网记录、孩子的入学申请……一些中情局同事甚至用截取到的女性裸照作为内部的「流通货币」彼此交换。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9oqelxc04j31120rttc1.jpg" alt="">&lt;/p>
&lt;h2 id="机器并不像人一样学习人工智能也没有真正的智能">机器并不像人一样学习，人工智能也没有真正的智能&lt;/h2>
&lt;p>下面我想站在另一个角度审视当年的棱镜门事件。现代信息技术发明了一些词汇方便我们理解技术的含义，比如人工智能、机器学习，其中最有迷惑性的是「预测」。王垠的文章&lt;a href="https://www.yinwang.org/blog-cn/2019/09/14/machine-vs-human">《机器与人类视觉能力的差距》&lt;/a>解释了机器所谓「识别」并不是真的「理解」。用斯诺登的话说：&lt;strong>计算机的预测，仅仅是对数据的一种操弄。&lt;/strong> 就像《少数派报告》的故事一样，最终决定机器的预测结果是否正确的关键，还在于人——掌控着机器的那些人。&lt;strong>技术名词在迷惑我们的同时，赋予了科技公司和大型机构更多权力，冠以科技发展之名&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>每个人都是潜在的罪犯：尽管我们自己没有察觉到，但多数人的生活绝不是黑白分明的，我们会任意穿越马路、未做好垃圾分类、在人行道骑自行车，甚至非法下载盗版等。换句话说，一旦法律贯彻到底，所有人都会变成罪犯。&lt;/p>
&lt;p>——爱德华·斯诺登，《永久记录》&lt;/p>
&lt;/blockquote>
&lt;h2 id="怎么保护我的元数据个人隐私">怎么保护我的元数据（个人隐私）？&lt;/h2>
&lt;p>如果你也意识到了个人隐私的重要性，那么是时候做点什么保护自己了。在当下，个人想要完全隐藏自己的上网行为几乎是不可能的。这也是为什么美国爆出棱镜门之后，全世界各国都把保护个人信息提上了政府议程。但是我们仍然可以通过一些手段，提高监视者作恶的成本。我为你整理了一些工具和上网习惯，它们只是给你提供一种思路，希望你能不局限于这些手段，在便利和隐私之间寻求到属于自己的平衡。&lt;/p>
&lt;h3 id="使用反追踪的浏览器插件">使用反追踪的浏览器插件&lt;/h3>
&lt;p>每当你点击一个网站页面，大部分网站会悄悄给百度、Google 等公司发送你的上网行为信息，&lt;a href="https://chrome.google.com/webstore/detail/privacy-badger/pkehgijcmpdhfbdbbnkijodmdjhbjlgp">隐私獾（Privacy Badger）&lt;/a>这个浏览器插件能帮你屏蔽掉广告和用户行为追踪。&lt;/p>
&lt;h3 id="确保所有通讯数据都有加密">确保所有通讯数据都有加密&lt;/h3>
&lt;p>从棱镜门之后，全世界大部分网站都提供了 Https 方式的数据加密访问，如果你访问的陌生网站没有支持 Https，请尽量不要把任何个人信息交给它。&lt;/p>
&lt;p>聊天软件是除了浏览器之外第二大上网工具，&lt;a href="https://yitianshijie.net/">一天世界&lt;/a>曾经整理了一个聊天软件安全性的表格，请参考选择适合自己的聊天工具（「人生最痛苦的是梦醒了无路可走」——鲁迅）&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9oqs2klvuj30xa0te44r.jpg" alt="聊天软件安全性">&lt;/p>
&lt;h3 id="尽量不填写真实的个人信息">尽量不填写真实的个人信息&lt;/h3>
&lt;p>很多网站都要你提供个人信息，请遵守「如非必要，一律虚构」的原则。&lt;/p>
&lt;p>最近微信更新了一个保护隐私的功能，你可以在&lt;a href="https://www.appinn.com/wechat-random-avatar/">微信第三方登录时选择随机生成的昵称和头像&lt;/a>，不妨试试。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9oq1bdydwj30u01md0u2.jpg" alt="图片来自小众软件">&lt;/p>
&lt;h3 id="去除照片-exif-信息">去除照片 EXIF 信息&lt;/h3>
&lt;p>你拍摄的照片里隐含了你的位置和设备信息，有新闻报道犯罪分子利用照片 EXIF 信息追踪女性家庭住址。提供类似功能的&lt;a href="https://sspai.com/post/27007">工具&lt;/a>很多，日常用微信传照片给陌生人，记得不要发送原图。&lt;/p>
&lt;h3 id="尽量不用公共-wifi">尽量不用公共 WiFi&lt;/h3>
&lt;p>值得一提的是，自己家的 WiFi 也时不时换一下密码。现在随便下载个黑客软件进入你家 WiFi 截取你流量搞个&lt;a href="https://baike.baidu.com/item/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB">中间人攻击&lt;/a>根本没有技术含量。&lt;/p>
&lt;h3 id="盯紧摄像头">「盯紧」摄像头&lt;/h3>
&lt;p>以前某个国产社交软件后台启动摄像头，并把视频传到网络上。现在都能搜到当年泄露的部分女孩子只穿内衣，在不知情时拍摄的视频。请在非必要时，不给任何 App 摄像头、麦克风或任何读取你敏感信息的权限。&lt;/p>
&lt;h3 id="dns-over-https">DNS over HTTPS&lt;/h3>
&lt;p>虽然你访问网站的流量是被 HTTPS 加密了，但是你访问任何网站前，你的设备会请求 DNS 服务器解析网站域名（好比邮寄信件时，邮局把你的邮编解析成真实的地区），这些信息被不法分子（？）拦截篡改，会误导你访问到不相关的地址上去。所以最近 Firefox 和 Chrome 两家浏览器都内置了 DNS over HTTPS 功能，开启后加密所有 DNS 域名解析流量。但是前提是你的 DNS 服务器也支持，你可以尝试 Cloudflare 的服务，其DNS地址为 &lt;code>1.1.1.1&lt;/code>。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9oq7u3eu9j316g0rsq5c.jpg" alt="爱德华·斯诺登">&lt;/p>
&lt;h2 id="斯诺登用了哪些工具">斯诺登用了哪些工具&lt;/h2>
&lt;p>作为中情局的高级技术人员，斯诺登自然有一套更加严密的工具来保护自己。普通人虽然用不到，但有更高匿名需求的人可以参考一下。&lt;/p>
&lt;h3 id="匿名通信的洋葱路由-torhttpszhwikipediaorgwikitor">&lt;a href="https://zh.wikipedia.org/wiki/Tor">匿名通信的洋葱路由 Tor&lt;/a>&lt;/h3>
&lt;p>它可以利用 Tor 节点帮你隐藏掉 mac 和 ip 地址，但是也并不是无懈可击，比如伪装的 Tor 节点就可以暴露你的全部流量，所以一般要配合代理使用。不建议没技术背景的人尝试。&lt;/p>
&lt;h3 id="关机即焚的操作系统-tailshttpszhwikipediaorgzh-hanstails_e6938de4bd9ce7b3bbe7bb9f">&lt;a href="https://zh.wikipedia.org/zh-hans/Tails_(%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)">关机即焚的操作系统 Tails&lt;/a>&lt;/h3>
&lt;p>这个系统所有的外部通信均强制通过 Tor 进行传送，此系统设计为使用 Live DVD 或者 Live USB 进行引导，且不让计算机在非显式行为下留下数据痕迹。&lt;/p>
&lt;h3 id="双向加密电子邮件服务-lavabithttpslavabitcom">&lt;a href="https://lavabit.com/">双向加密电子邮件服务 Lavabit&lt;/a>&lt;/h3>
&lt;p>电子邮件默认是不加密的，很多人都不知道这件事。斯诺登在联系记者时，让记者配合他，一起使用了 Lavabit 来双向加密电子邮件。&lt;/p>
&lt;h3 id="不使用固定的-wifi">不使用固定的 WiFi&lt;/h3>
&lt;p>斯诺登自己开发了一套系统，可以自动劫持附近 WiFi 的流量。这好比，你寄送一封信，但是你不想让别人知道你是谁、寄给了谁，于是你把这封信塞进别人信封里寄出去……原理要更复杂，斯诺登在把丑闻资料传递给记者时，就独自开车在附近街区，使用随机 WiFi 夹带自己的信息发送给记者，以此保护自己的行踪不被中情局监控到。&lt;/p>
&lt;h3 id="多份数据防止单点故障">多份数据，防止「单点故障」&lt;/h3>
&lt;p>斯诺登将多份机密资料交给多名记者。目的是防止某个记者因为特殊原因在他被捕前没有及时将丑闻公之于众。他这份缜密和勇气，真的不是寻常人能够做到的。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9oqabzz2ej31bs0rtt9h.jpg" alt="">&lt;/p>
&lt;h2 id="写在最后">写在最后&lt;/h2>
&lt;p>我们在使用互联网提供的种种便利的同时，也应时刻记得，那些我们上传的照片、发布的信息，都存储在不属于我们的服务器上，我们所有分享在网络上的一切，本质上都不属于我们。&lt;/p>
&lt;blockquote>
&lt;p>在美国革命时期，这被叫做「自由」；在互联网革命时期，这被叫做「隐私」。&lt;/p>
&lt;/blockquote></description></item><item><title>Kevin Kelly's Hacking 和 《列子天瑞》的盗亦有道</title><link>https://sund.site/posts/2019/what-is-hacking/</link><pubDate>Thu, 05 Dec 2019 23:15:43 +0800</pubDate><guid>https://sund.site/posts/2019/what-is-hacking/</guid><description>&lt;p>&lt;a href="https://kk.org/">凯文凯利&lt;/a>在《失控》中有一句话：&lt;/p>
&lt;blockquote>
&lt;p>The nature of life is to delight in all possible loopholes. Every creature is in some way hacking a living by reinterpreting the rules.&lt;/p>
&lt;/blockquote>
&lt;p>生命的本性就是喜爱一切可利用的「漏洞」，每个造物都在通过重新诠释规则来谋求生存。&lt;/p>
&lt;p>无独有偶，&lt;a href="https://baike.baidu.com/item/%E5%88%97%E5%AD%90%C2%B7%E5%A4%A9%E7%91%9E">《列子·天瑞》&lt;/a>里有一个故事。宋国的向氏问齐国的国氏，如何变得富裕。国氏就说：「吾善为盗。始吾为盗也，一年而给，二年而足，三年大穰」，向氏一听原来诀窍就是盗，就去学着入室偷窃，结果被抓住问罪，家里的财物都被没收了。&lt;/p>
&lt;p>向氏气冲冲地跑去质问国氏，国氏解释说了下面这段话。&lt;/p>
&lt;blockquote>
&lt;p>吾闻天有时，地有利。吾盗天地之时利……夫禾稼、土木、禽兽、鱼鳖，皆天之所生，岂吾之所有？然吾盗天而亡殃。&lt;/p>
&lt;/blockquote>
&lt;p>原来国氏所谓「盗」，并不是盗窃财物，而是盗天地之时利。这里的盗字，正好对应了英语里的 &amp;ldquo;Hacking&amp;rdquo;。凯文凯利的 &amp;ldquo;hacking a living by reinterpreting the rules&amp;rdquo;，正是列子所谓「万物自天成，盗者本无心」。&lt;/p></description></item><item><title>为 Mac OS 10.15 开启 HiDPI，让 2K 显示器更舒适</title><link>https://sund.site/posts/2019/macbook-hidpi/</link><pubDate>Sun, 24 Nov 2019 16:11:00 +0800</pubDate><guid>https://sund.site/posts/2019/macbook-hidpi/</guid><description>&lt;p>以前手抖买了台 Dell P2416D 显示器，接上 Macbook 发现原生的分辨率设置在 2K 显示器上字体很小，换成 1080P 分辨率显示效果又特别模糊。上网查了一下发现可以为 Macbook 强行开启 HiDPI。下文的教程结合了 Github 上用户&lt;a href="https://github.com/xzhih">ZeRo° Xu&lt;/a> 在 &lt;a href="https://github.com/xzhih/one-key-hidpi">一键开启HiDPI脚本&lt;/a> 里的 &lt;a href="https://github.com/syscl/Enable-HiDPI-OSX/issues/49">Github Issue&lt;/a> 和一篇博文 &lt;a href="https://www.smslit.top/2019/01/02/mac_hidpi/">《为 mac 连接的 2k 显示器开启 HiDPI》&lt;/a>。&lt;/p>
&lt;h2 id="什么是-hidpi">什么是 HiDPI&lt;/h2>
&lt;p>引用自 Github 用户 &lt;a href="https://github.com/xzhih">ZeRo° Xu&lt;/a> ：&lt;/p>
&lt;blockquote>
&lt;p>它使用横纵 2 个物理像素也就是 4 个物理像素来显示 1 个像素区域，结果就是图像的细节得到翻倍、更清晰、边缘更平滑。&lt;/p>
&lt;p>拿 13 寸的 MacBook Pro 举例，它的屏幕物理分辨率是 2560 x 1600，所以原生的 HIDPI 分辨率就是 1280x800。更高的一档 1440x900 hidpi 缩放分辨率，则是虚拟出一个 2880x1800 的分辨率，再进行软缩放输入。所以你能发现苹果的电脑总是有很高的分辨率。&lt;/p>
&lt;p>好了，既然你的屏幕是 1080p，本身就没有那么多像素去合成 HIDPI，如果以原生的显示计算，你这屏幕的 1080p 分辨率应该是 960x540，这么低的分辨率你是没法用的，所以就有了这个脚本。&lt;/p>
&lt;p>这个脚本的功能是虚拟出比你的屏幕物理分辨率更高的假分辨率，也就是你看到的 3360 x 1888，这样你就可以使用 1680 x 944 hidpi 这个缩放分辨率了。&lt;/p>
&lt;p>如果你要开启 1080p 的 HIDPI 分辨率，就虚拟一个 3840 x 2160 的假分辨率，然后 MacOS 会使用 4 个像素来显示 1 个像素区域，也就是和你物理分辨率一样的 1080p 分辨率，开不开启看起来没任何区别，最大的效果就是显卡压力增大系统变卡、截图可以得到高分辨率图像。&lt;/p>
&lt;/blockquote>
&lt;h2 id="自动配置-hidpi">自动配置 HiDPI&lt;/h2>
&lt;p>上文 &lt;a href="https://github.com/xzhih/one-key-hidpi">链接&lt;/a> 里提到一键配置脚本，你不妨先按照脚本的步骤开启 HiDPI 试试。但是脚本并没有适配所有显示器的情况（至少我的 Dell P2416D 使用后无效），所以就有了下面的步骤。&lt;/p>
&lt;h2 id="手动配置-hidpi">手动配置 HiDPI&lt;/h2>
&lt;p>本教程测试环境：&lt;/p>
&lt;ul>
&lt;li>笔记本：MacBook Pro (Retina, 15-inch, Mid 2015)&lt;/li>
&lt;li>显示器：Dell P2416D&lt;/li>
&lt;li>操作系统：MacOS Catalina (Version 10.15.1)&lt;/li>
&lt;/ul>
&lt;h3 id="0-安装-rdm">0. 安装 RDM&lt;/h3>
&lt;p>相信很多人已经装过这个工具了，它是用来修改显示分辨率的，如果没装，请在&lt;a href="https://avi.alkalay.net/software/RDM/">RDM下载页面&lt;/a>安装它。&lt;/p>
&lt;h3 id="1-关闭-mac-的-sip">1. 关闭 Mac 的 SIP&lt;/h3>
&lt;p>SIP 是苹果公司为防止你胡乱篡改系统文件用的保护机制，请先按照下面步骤把它关闭，以便后续操作：&lt;/p>
&lt;ol>
&lt;li>关机（最好先手机拍个照把这4步记录下来）&lt;/li>
&lt;li>按&lt;code>command（⌘）+ R&lt;/code>+电源键开机，自动进入恢复模式&lt;/li>
&lt;li>选择上边菜单栏的&lt;code>实用工具&lt;/code>中的&lt;code>终端&lt;/code>&lt;/li>
&lt;li>输入命令&lt;code>csrutil disable&lt;/code>&lt;/li>
&lt;/ol>
&lt;p>最后终端显示 「Successfully……」 等一大堆文字就说明你成功了。你可以输入&lt;code>reboot&lt;/code>重启。等下文的全部设置都完成后，你如果想恢复 SIP，就重复步骤 1 到 3，在第 4 步输入&lt;code>csrutil enable&lt;/code>就好了。&lt;/p>
&lt;h3 id="2-开启-macos-的-hidpi-选项">2. 开启 macOS 的 HiDPI 选项&lt;/h3>
&lt;p>再次重启后进入系统，打开终端输入&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">sudo defaults write /Library/Preferences/com.apple.windowserver.plist DisplayResolutionEnabled -bool true
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-查询你的外接显示器的编号">3. 查询你的外接显示器的编号&lt;/h3>
&lt;p>这一步相当重要，先介绍两个命令&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback">ioreg -l | grep &amp;#34;DisplayVendorID&amp;#34;
ioreg -l | grep &amp;#34;DisplayProductID&amp;#34;
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这两条命令用来查询你的显示器供应商 ID &lt;code>DisplayVendorID&lt;/code> 和产品 ID &lt;code>DisplayProductID&lt;/code>。接下来你要找到你的显示器对应的&lt;code>DisplayVendorID&lt;/code>和&lt;code>DisplayProductID&lt;/code>：&lt;/p>
&lt;ol>
&lt;li>拔掉显示器的 HDMI 或者 DP 线&lt;/li>
&lt;li>分别输入上面两个命令之后&lt;code>return(↩)&lt;/code>，每个命令会返回一个带有数字的结果。那个数字就是 macbook 默认的&lt;code>DisplayVendorID&lt;/code>和&lt;code>DisplayProductID&lt;/code>了&lt;/li>
&lt;li>接入显示器&lt;/li>
&lt;li>再分别输入那两个命令，每个命令会分别返回两条带有数字的结果。对比刚才 macbook 默认的结果，另一个数字就是你显示器的&lt;code>DisplayVendorID&lt;/code>和&lt;code>DisplayProductID&lt;/code>了&lt;/li>
&lt;li>把这两个数字分别转成对应的 16 进制数，用这个&lt;a href="https://tool.oschina.net/hexconvert">进制转换工具&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>现在，回到桌面，新建一个文件夹命名为&lt;code>DisplayVendorID-[你刚才查到的DisplayVendorID的16进制数]&lt;/code>，例如&lt;code>DisplayVendorID-10ac&lt;/code>。&lt;/p>
&lt;p>之后在这个刚建好的文件夹下增加一个文件，命名为&lt;code>DisplayProductID-[你刚才查到的DisplayProductID的16进制数]&lt;/code>，例如&lt;code>DisplayProductID-a0c3&lt;/code>。&lt;/p>
&lt;h3 id="4-为你的显示器生成-plist-文件">4. 为你的显示器生成 plist 文件&lt;/h3>
&lt;p>到 &lt;a href="https://comsysto.github.io/Display-Override-PropertyList-File-Parser-and-Generator-with-HiDPI-Support-For-Scaled-Resolutions/">这个网站&lt;/a> ，在左侧的空里分别输入显示器型号，DisplayProductID 和 DisplayVendorID，注意填16进制的数字，并且检查下后边10进制的数字是不是和你刚才命令查到的一致。如果需要添加自己额外的分辨率，直接在下边新建一条分辨率配置就行。最后，复制右边生成 XML 格式文本，粘贴到刚才新建的文件里。（也可以直接从网站下载文件，去掉文件名后缀 &lt;code>.plist&lt;/code> ）&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g9bg60hippj30nm0rqwha.jpg" alt="显示器配置" style="zoom:50%;" />&lt;/p>
&lt;p>XML 文件类似下边这样：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="cp">&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span>
&lt;span class="cp">&amp;lt;!DOCTYPE plist PUBLIC &amp;#34;-//Apple//DTD PLIST 1.0//EN&amp;#34; &amp;#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;#34;&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;plist&lt;/span> &lt;span class="na">version=&lt;/span>&lt;span class="s">&amp;#34;1.0&amp;#34;&lt;/span>&lt;span class="nt">&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;dict&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;key&amp;gt;&lt;/span>DisplayProductID&lt;span class="nt">&amp;lt;/key&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;integer&amp;gt;&lt;/span>41156&lt;span class="nt">&amp;lt;/integer&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;key&amp;gt;&lt;/span>DisplayVendorID&lt;span class="nt">&amp;lt;/key&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;integer&amp;gt;&lt;/span>4268&lt;span class="nt">&amp;lt;/integer&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;key&amp;gt;&lt;/span>scale-resolutions&lt;span class="nt">&amp;lt;/key&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;array&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;data&amp;gt;&lt;/span>AAAKAAAABaAAAAABACAAAA==&lt;span class="nt">&amp;lt;/data&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;data&amp;gt;&lt;/span>AAAFAAAAAtAAAAABACAAAA==&lt;span class="nt">&amp;lt;/data&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;data&amp;gt;&lt;/span>AAAPAAAACHAAAAABACAAAA==&lt;span class="nt">&amp;lt;/data&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;data&amp;gt;&lt;/span>AAAHgAAABDgAAAABACAAAA==&lt;span class="nt">&amp;lt;/data&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;data&amp;gt;&lt;/span>AAAMgAAABwgAAAABACAAAA==&lt;span class="nt">&amp;lt;/data&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;data&amp;gt;&lt;/span>AAAGQAAAA4QAAAABACAAAA==&lt;span class="nt">&amp;lt;/data&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;data&amp;gt;&lt;/span>AAAKAgAABaAAAAABACAAAA==&lt;span class="nt">&amp;lt;/data&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;data&amp;gt;&lt;/span>AAAKrAAABgAAAAABACAAAA==&lt;span class="nt">&amp;lt;/data&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;data&amp;gt;&lt;/span>AAAFVgAAAwAAAAABACAAAA==&lt;span class="nt">&amp;lt;/data&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/array&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/dict&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/plist&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="4-复制-plist-配置文件到系统配置目录">4. 复制 plist 配置文件到系统配置目录&lt;/h3>
&lt;p>这一步就是把刚才新建的配置文件复制到你系统目录里，你直接复制通常会提示你系统目录是「只读」的，不允许你胡作非为。所以你先要在终端执行下面的命令：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">sudo mount -uw /
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，你就可以复制到系统的文件夹了。（这个命令重启后失效）&lt;/p>
&lt;p>接下来打开系统文件夹&lt;code>/System/Library/Displays/Contents/Resources/Overrides/&lt;/code>，你会发现一大堆跟你刚才文件夹命名相似的目录。把你新建的文件夹丢进去，和它们混在一起，假装它原来就是其中一员。重启。&lt;/p>
&lt;h3 id="5-修改分辨率">5. 修改分辨率&lt;/h3>
&lt;p>重启之后又进入系统，首先打开 RDM，你会在菜单栏看见它：&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g995pjfs3aj30io0h4gz1.jpg" alt="rdm-shot" style="zoom:50%;" />&lt;/p>
&lt;p>Main Display 和 Display 2 就分别是你的外接显示器和 macbook 的显示器分辨率设置（位置有可能对掉，自己尝试一下）。带有 ⚡️ 符号的分辨率设置项就是开启 HiDPI 后新增出来的。如果你像我一样是 2K 显示器，可以给显示器选择&lt;code>1920x1080⚡️&lt;/code>那个配置。是不是比原生分辨率的 UI 和字体更大更清晰了。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>本文教你强行开启 macbook 的 HiDPI 设置，并针对 2K 显示器新增了配置文件到系统配置目录里，最后用 RDM 自由设置适合你显示器的分辨率。至于 HiDPI 的原理，请自行搜索，此处不再赘述。&lt;/p>
&lt;p>希望本文对你有帮助，也欢迎你留言反馈。&lt;/p></description></item><item><title>抛弃笔记本，完全用标签管理笔记有什么需要注意的</title><link>https://sund.site/posts/2019/all-tag-in-evernote/</link><pubDate>Mon, 18 Nov 2019 13:49:00 +0800</pubDate><guid>https://sund.site/posts/2019/all-tag-in-evernote/</guid><description>&lt;p>日常工作中经常会出现这样的情况：&lt;/p>
&lt;ol>
&lt;li>小张怎么也想不起来上次收藏的一篇健身饮食相关的文章，到底是在印象笔记的「健身」分类下，还是在「健康」或者「饮食」分类下，跨分类的文章太多，小张感到头秃&lt;/li>
&lt;li>小李用标签管理文档，但是每次查询标签时，总是犹豫到底应该搜索&lt;code>时间管理&lt;/code>还是&lt;code>效率&lt;/code>，亦或是&lt;code>工作流&lt;/code>，标签实在太多，小李很恼火&lt;/li>
&lt;/ol>
&lt;p>这两种情况都属于整理方法不科学，给检索时造成了麻烦。&lt;/p>
&lt;h2 id="检索分类的难题">检索分类的难题&lt;/h2>
&lt;p>在正式介绍整理方法前，不得不先声明一个事实：**完全无重叠的分类是不可能实现的。**以小张为例，小张是一个健身教练，他在「健身方法」分类下有教会员如何管理「睡眠」、「饮食」和「健身动作」，同时小张也热爱生活，他在「生活」分类下有「财务知识」，并在「睡眠」和「饮食」里记录自己的睡眠和饮食习惯。这就造成了「睡眠」和「饮食」同时存在于个人生活和健身方法两个分类里。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g909mdd42bj30dj08ddfx.jpg" alt="如何打标签-分类">&lt;/p>
&lt;p>像小张这样的情况几乎不可避免，分类作为一种整理方法，就免不了出现上图中重叠的部分。什么是分类？**分类就是预先设计好一堆插槽，再把不同的东西分门别类放进对应的插槽里。**小张在检索「饮食」相关的内容时，他的分类系统失效了，同一个东西可以属于不同插槽。小张此时必须用「个人生活 + 饮食」或是「健身 + 饮食」的扩展分类形式才能得到想要的结果。由此可见，&lt;strong>分类失效最简单的解决办法是扩展分类&lt;/strong>，比如增加两个子分类「生活饮食」和「健身饮食」。但是由于文档日积月累，这种小分类越来越多，越来越难管理；而一些分类里只存了1、2篇文档，根本没必要单独开个分类。&lt;/p>
&lt;p>小张的头秃越来越严重了，为了帮助像小张这样的分类困难症，人们想出了两种不同的办法：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>用标签解决重叠部分&lt;/strong>，比如&lt;code>饮食&lt;/code>就可以作为标签，在「健身」分类下的文章如果贴着&lt;code>饮食&lt;/code>就代表它属于健身相关的饮食，同时这个标签也可以贴到「个人生活」下的文章里。&lt;/li>
&lt;li>**通通用标签，**把&lt;code>个人生活&lt;/code>变成标签，一篇文章如果同时贴有&lt;code>个人生活&lt;/code>和&lt;code>饮食&lt;/code>，那它就是生活方面的饮食，不是健身的饮食知识。具体的做法会在后面章节讲解。&lt;/li>
&lt;/ol>
&lt;h2 id="遵守使用原则">遵守使用原则&lt;/h2>
&lt;p>不管哪种方式，即便有了标签和分类的双管齐下，也要有使用的原则，否则滥用的结果比不分类更麻烦。这回我们从原点出发，先思考一下人类检索信息的方式。&lt;/p>
&lt;p>通常&lt;strong>检索信息有两种方式：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>&lt;strong>通过树形的层级体系，自顶向下一层层检索&lt;/strong>&lt;/li>
&lt;li>&lt;strong>通过碎片的记忆，用关键词和关联性，自底向上检索&lt;/strong>&lt;/li>
&lt;/ol>
&lt;p>基于这两种常见的检索方式，我们约定一种分类和标签的使用原则：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>谨慎扩展新分类，分类之间尽量不重叠&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>标签尽量不可拆分，标签之间组合使用&lt;/strong>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>分类的创建成本高，检索成本低&lt;/strong>，所以分类只有数量少，重叠部分少，才能提高自顶向下查找的命中率。&lt;/p>
&lt;p>&lt;strong>标签创建成本低，但是检索成本高&lt;/strong>，所以标签可以是跨类别的，标签越具体，组合越丰富，关键词命中率越高。&lt;/p>
&lt;p>基于这两种原则去管理分类和标签，就可以保证你的检索体系不崩溃的同时，检索效率最高。比如我先搜索「健身」分类，发现文章太多，于是我加上&lt;code>饮食&lt;/code>相关的标签，就可以轻松过滤掉大部分信息。标签越具体，组合越详细，过滤效果越好。&lt;/p>
&lt;p>另外，假设我只记得文章的模糊内容，也可以直接搜索标签或内容。&lt;/p>
&lt;h2 id="完全标签化的思路">完全标签化的思路&lt;/h2>
&lt;p>现在流行一种管理方式，抛弃分类，完全用标签管理。拿印象笔记为例，在这篇 &lt;a href="https://medium.com/@thomashoneyman/using-evernote-the-right-way-ef61f530d1ad">《Using Evernote (the right way)》&lt;/a> 的文章中，作者抛弃了常见的笔记本分类法，完全用标签来整理笔记。笔记本只保留「收件箱」、「收藏夹」和「废纸篓」。这种方式免去了整理笔记本的麻烦，但同时，造成了检索时必须依赖标签。作者为了解决这一难题，提出了一种被我称之为**「给标签分类」（ 原文是 Organize Tags）**的做法。&lt;/p>
&lt;p>其实给标签分类的做法非常常见，以 &lt;a href="https://www.douban.com/">豆瓣&lt;/a> 为例，你肯定见过下边的标签分类方式：&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g91dwdctqwj30hw0wqq5h.jpg" alt="douban">&lt;/p>
&lt;p>**这种方式的好处就是：你既可以直接在搜索栏搜索具体的标签，也可以通过标签分类先筛选出标签，再点击标签明层缩小筛选范围。**这就解决了标签不好逐层检索的问题。&lt;/p>
&lt;p>仍然以印象笔记为例，我们该如何改造它，使之成为完全标签化的系统呢？&lt;/p>
&lt;p>首先，把现有笔记的标签归入对应的父类标签。比如新建一个&lt;code>信息管理&lt;/code>，然后把&lt;code>项目管理&lt;/code>、&lt;code>时间管理&lt;/code>、&lt;code>思维导图&lt;/code>、&lt;code>信息检索&lt;/code>全部拖到&lt;code>信息管理&lt;/code>标签下，使之成为父标签。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g91dw8hj6hj307m090jre.jpg" alt="006y8mN6gy1g90dkrc0utj307m090q37">&lt;/p>
&lt;p>之后，按照「我是谁，从哪来，到哪去」的原则补充所有遗失的标签。&lt;/p>
&lt;ol>
&lt;li>我是谁，笔记属于哪个知识点、具体的知识类型&lt;/li>
&lt;li>从哪来，笔记的来源，如果是网页剪藏，印象笔记会自带来源信息&lt;/li>
&lt;li>到哪去，笔记的用途，比如进行中的某个项目&lt;/li>
&lt;/ol>
&lt;p>这样，一篇笔记的标签看起来是这样：&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g90dnvno5pj316g07qgne.jpg" alt="标签命名">&lt;/p>
&lt;p>这里的来源我直接使用了印象笔记自带的信息。标签的用途如果不明确也可以忽略。知识点要遵循具体，尽量不可拆分的原则。父类别标签的存在，是为了避免开头中小李遇到的问题，标签太多时，检索无从下手。文章有了父类别标签，你就多了一种筛选笔记的方式：直接在标签管理界面点选父标签来缩小筛选范围。&lt;/p>
&lt;p>完成了这些，我们下次检索笔记，就可以用两种方式：&lt;/p>
&lt;ol>
&lt;li>通过父标签 &amp;gt; 子标签的方式逐层检索&lt;/li>
&lt;li>通过搜索框输入标签名直接检索&lt;/li>
&lt;/ol>
&lt;p>如果你不是印象笔记用户，也可以采用一些迂回的手段，比如建立一张标签父子关系的笔记，来作为查找目录。&lt;/p>
&lt;p>看到这里你也许已经发现，这种完全标签化的方式其实只不过是把分类变成了标签，它同样存在父标签之间范围重叠的问题，所以一样要遵循前文的分类和标签的使用原则。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>本文先分析了检索分类的难题——分类之间的重叠造成添加和检索时的不便。之后按照分类和标签两种归类方式的区别，提出了创建和使用分类、标签的原则，即谨慎分类，组合标签。之后介绍了一种完全标签化的管理信息方式。它的本质仍然是通过分类 + 标签的组合，提高检索效率。&lt;/p>
&lt;p>希望本文对你有所帮助，也欢迎在评论区留言发表你的观点。&lt;/p></description></item><item><title>注意力的边缘</title><link>https://sund.site/posts/2019/attention-model/</link><pubDate>Thu, 14 Nov 2019 15:29:00 +0800</pubDate><guid>https://sund.site/posts/2019/attention-model/</guid><description>&lt;p>阅读几分钟就忍不住打开微信；&lt;/p>
&lt;p>计划在家办公却浏览了一上午购物网站；&lt;/p>
&lt;p>周末去咖啡馆学习，被来回走动到人打扰到无法专心。&lt;/p>
&lt;p>这些问题我们经常会遇到，好的外部环境可以让人长时间保持精神的专注，大大提高我们工作、学习的效率。反之各种外界干扰会时不时跳出来打断你的注意力。那么你要怎么应对这些干扰呢？&lt;/p>
&lt;p>接下来我会分享一种认知模型——&lt;strong>注意力模型&lt;/strong>，它帮助你分析你的注意力被谁「偷」走了。&lt;/p>
&lt;h2 id="注意力有边缘">注意力有边缘&lt;/h2>
&lt;p>我在最近阅读《&lt;a href="https://book.douban.com/subject/27133266/">交互的未来&lt;/a>》这本书时，了解到了注意力模型。书的作者认为，人的注意力有&lt;strong>边缘&lt;/strong>。我们不可能将全部注意力放在多件事上，&lt;strong>处于我们注意力中心的事物最容易被我们感知，而处于注意力边缘的事物，往往被我们的视线边缘、听觉、嗅觉等知觉感受到&lt;/strong>。因此，位于注意力中心的事物感知最清晰，所以反馈也更迅速。&lt;/p>
&lt;p>以此为基础，作者把注意力划分为三个等级，下面以常见的汽车驾驶室为例，看看司机的注意力是怎样分配的：&lt;/p>
&lt;ul>
&lt;li>前方路况占据了驾驶员视觉中心，是主要注意力&lt;/li>
&lt;li>在视觉边缘的反光镜和仪表盘，以及触觉反馈的方向盘和脚踏板，是次级注意力&lt;/li>
&lt;li>双闪、应急灯、收音机等设备，周围的环境音共同构成了第三级注意力&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8coq07izhj30zm0mah8s.jpg" alt="Untitled-81b16b63-34f5-4ac5-aef1-8f98cffa1300">&lt;/p>
&lt;p>由此，注意力的三个等级可以归纳为：&lt;/p>
&lt;ul>
&lt;li>主要注意力与视觉相关，且是直接的，例如司机对路面所给予的注意，或者台式计算机用户对计算机所给予的注意。&lt;/li>
&lt;li>次要注意力的对象则较远，例如，人们对无需直接关注就能感觉到的声音或振动信号所给予的注意。&lt;/li>
&lt;li>第三级注意力的对象则是注意范围边缘的声音、光线或环境振动等。&lt;/li>
&lt;/ul>
&lt;p>当一个司机在驾驶时，如果有人跟他不断交谈，那么司机的注意力模型就变成了：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">主要注意力&lt;/th>
&lt;th style="text-align:center">次要注意力&lt;/th>
&lt;th style="text-align:center">第三级注意力&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">前窗的视觉，路况和车辆位置的意识&lt;/td>
&lt;td style="text-align:center">后视镜、仪表盘、脚踏板等&lt;/td>
&lt;td style="text-align:center">和乘客的谈话内容&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>司机的第三级注意力被乘客的谈话内容占据，所以周围的环境音就被阻断了。那假设这辆车使用了屏幕触摸式导航系统，那么司机在使用导航系统时，主要注意力就被阻断了。所以在非自动驾驶的汽车里使用触摸操控在交互上是糟糕的设计。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">主要注意力&lt;/th>
&lt;th style="text-align:center">次要注意力&lt;/th>
&lt;th style="text-align:center">第三级注意力&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">触摸屏操作&lt;/td>
&lt;td style="text-align:center">后视镜、仪表盘、脚踏板等&lt;/td>
&lt;td style="text-align:center">和乘客的谈话内容&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="使用电子设备的注意力模型">使用电子设备的注意力模型&lt;/h2>
&lt;p>接下来，我们一起回到日常生活中。在一般情况下，我们在工作和学习时，注意力的状态是这样：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">主要注意力&lt;/th>
&lt;th style="text-align:center">次要注意力&lt;/th>
&lt;th style="text-align:center">第三级注意力&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">电子屏幕、书本上的内容&lt;/td>
&lt;td style="text-align:center">屏幕边缘的时间和菜单，不时弹出的通知栏，视线边缘来回走动的人&lt;/td>
&lt;td style="text-align:center">环境光和声音，提示音，久坐后座椅、桌子的不适感&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>看到这里，你头脑中理想的学习环境是不是下面这样呢？&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">主要注意力&lt;/th>
&lt;th style="text-align:center">次要注意力&lt;/th>
&lt;th style="text-align:center">第三级注意力&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">电子屏幕、书本上的内容&lt;/td>
&lt;td style="text-align:center">未被占用&lt;/td>
&lt;td style="text-align:center">未被占用&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>次级注意力未被占用并不一定是件好事。我们大脑里偶尔冒出来的思绪经常把注意力牵扯到其他事情上。对平时专注力差的人，更会时不时主动寻找手机，看看微信，突然想起某款口红型号，马上登录淘宝……&lt;/p>
&lt;p>所以，&lt;strong>专注的重点在于合理分配注意力的中心和边缘，让它们既不互相阻断，又不给思绪留出太多遐想空间。&lt;/strong>&lt;/p>
&lt;h2 id="用平静的方式占领注意力的边缘">用平静的方式，占领注意力的边缘&lt;/h2>
&lt;p>想象现在你坐在周末的咖啡馆里准备阅读一本书，但是嘈杂的环境无法让你沉下心来：飞奔的小朋友发出持续的笑声，不时从你身边划过；隔壁桌相亲的一男一女举止暧昧，任谁都不能不关心他们接下来的进展；为了防止顾客久坐而专门设计的座椅让你的臀部和背部永远处于找不到理想接触面积的状态；这时，手机锁屏界面显示「你收到了一条通知」……&lt;/p>
&lt;p>下面，你应该做什么呢？&lt;/p>
&lt;p>或许是扔掉手机换一家咖啡馆，亦或者在夺门而出前亲吻隔壁桌的女生，在男生惊慌的眼神里转身跑向门口，并在出门前绊倒跑过来的小朋友……&lt;/p>
&lt;p>这肯定是不行的。&lt;/p>
&lt;p>首先，你要关掉自己手机的一切通知，或者直接打开&lt;a href="https://support.apple.com/zh-cn/HT204321">勿扰模式&lt;/a>。大多手机 App 都想尽办法留住更多用户的时间，所以&lt;strong>真正变成手机的主人，是你提升一切行动力和专注力的先决条件。&lt;/strong>&lt;/p>
&lt;p>第二步，你要屏蔽掉视觉污染，让视线边缘不会有吸引你注意力的物体。我会在下一小节中告诉你&lt;strong>聚光灯&lt;/strong>的妙用。&lt;/p>
&lt;p>最后，你要屏蔽掉声音的干扰，戴上耳机，播放点柔和的音乐。除此之外，舒适的座椅和柔软的靠垫都会安抚你的触觉神经。&lt;/p>
&lt;p>你的注意力应该像下面这样：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:center">主要注意力&lt;/th>
&lt;th style="text-align:center">次要注意力&lt;/th>
&lt;th style="text-align:center">第三级注意力&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:center">电子屏幕、书本上的内容&lt;/td>
&lt;td style="text-align:center">不容易吸引注意力的物体，较暗的周围环境&lt;/td>
&lt;td style="text-align:center">轻柔的旋律，舒适的倚靠感&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="用聚光灯营造舞台感">用聚光灯营造舞台感&lt;/h2>
&lt;p>次级注意力会时不时把视觉中心夺走。许岑在自己的新书&lt;a href="https://book.douban.com/subject/34464459/">《上手》&lt;/a>中，提出使用聚光灯来营造极大提升专注力的舞台感办公环境。从注意力模型的角度说，次级注意力被较暗的环境包围时，更不容易阻断视觉注意力。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8covpkgpsj30v40ite2e.jpg" alt="Untitled-4ffaba46-bd44-4794-8495-79d75a1ab83e">&lt;/p>
&lt;p>市面上很多光线柔的台灯或是显示器灯，兼顾了保护视力和聚光灯的作用。比较知名的有少数派曾经发过的&lt;a href="https://sspai.com/post/43034">《这是我今年买得最值的硬件 — WiT Genie》&lt;/a>和《&lt;a href="https://sspai.com/post/45870">夹在显示器上的台灯，美观实用的完美照明解决方案：明基 ScreenBar Plus 屏幕挂灯》&lt;/a>，前者还详细讲解了照明亮度、频闪对视力的影响。&lt;/p>
&lt;h2 id="容易被忽视的第三级注意力">容易被忽视的第三级注意力&lt;/h2>
&lt;p>很多人喜欢使用降噪耳机来屏蔽环境音，我认为实际效果因人而异，像我这种脑中经常会冒出异想的人，大脑很难在安静的环境里不自我放飞。即便是躺在床上装睡时……这也是为什么我提倡占领注意力的边缘而不是留出真空，思想是长翅膀的鸟，空间太大就很容易飞到莫名的地方去。&lt;/p>
&lt;p>我占领注意力边缘的方式是听音乐。有人会觉得听音乐干扰注意力，无法专心工作。有的人则相反，觉得听音乐是必要的「陪伴」。是干扰还是陪伴，这取决于音乐是激昂还是舒缓，歌词是陌生还是熟悉，音量是小还是大。熟悉的旋律和歌声需要你更少的注意力去理解，音乐也就不会轻易越迁到高一级注意力阻断你的工作，较小的音量可以保证它只存在于你的第三级注意力中。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8cow0ac1uj319f0u0txh.jpg" alt="Untitled-ccf52f38-3854-4adc-bc45-a8a4b29b0942">&lt;/p>
&lt;p>网易云音乐有很多歌单适合工作学习时听，比如我曾经整理过一个&lt;a href="http://music.163.com/playlist/133513964/131429/?userid=131429">《看书就好好看书》&lt;/a>，里面有94首小提琴曲和日系轻音乐。&lt;/p>
&lt;p>可是常听还是会腻，所以&lt;a href="https://www.pandora.com">潘多拉电台&lt;/a>弥补了我想时不时换换口味的需要，它的推荐歌曲和自主学习能力是我试用过的 App 里体验最好的。你也可以使用网页版的潘多拉电台打造一套属于自己的工作学习 BGM。&lt;/p>
&lt;h3 id="适宜阅读的舒适触感">适宜阅读的舒适触感&lt;/h3>
&lt;p>对于一个喜欢阅读的人，我坚信最适合人类阅读的姿势是半躺着。一个舒适的躺椅或是床头靠垫使你在阅读时不至于频繁更换姿势，配合舒适的暖色灯光，睡前阅读会成为你的习惯。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g8cow6h8mnj30u00u0x6r.jpg" alt="Untitled-50eb39e5-17de-4a5d-b633-28f6055ed7ba">&lt;/p>
&lt;p>相信读到这里你已经知道了自己有哪些外部环境需要改善。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>本文首先介绍注意力模型，注意力分三个等级：中心是主要注意力、边缘分别是次级注意力和第三级注意力。接下来我建议你使用聚光灯、背景音乐和舒适的倚靠感来平静地占领注意力的各个「阵地」，让你的内心沉浸工作和学习中。&lt;/p>
&lt;p>文中对注意力的控制局限于外部环境，实际上，人的内因往往起着更关键的作用，有很多调节注意力的方法，如建立大纲模型、思维导图法。也有很多逐步提高注意力的工具，比如&lt;a href="https://zh.wikipedia.org/zh-hans/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95">番茄工作法&lt;/a>和最近很流行的&lt;a href="https://sspai.com/post/56866">用 NFC 贴纸自动化记录时间&lt;/a>。在此不详细展开，读者可以根据链接自行寻找适合自己的方法。&lt;/p>
&lt;p>希望本文对你有所帮助。你可以在我的微信公众号「电波障害」看到更多文章。&lt;/p></description></item><item><title>Ricoh GR2 参数设置心得</title><link>https://sund.site/posts/2019/ricoh-gr2-settings/</link><pubDate>Thu, 14 Nov 2019 14:46:00 +0800</pubDate><guid>https://sund.site/posts/2019/ricoh-gr2-settings/</guid><description>&lt;h2 id="常用相机术语">常用相机术语&lt;/h2>
&lt;p>&lt;strong>包围曝光&lt;/strong>：同时使用不同曝光参数或滤镜拍摄三张照片或是合成一张。&lt;/p>
&lt;p>&lt;strong>NR&lt;/strong>：即降噪功能，如感光度 ISO NR，低速快门 NR。&lt;/p>
&lt;p>&lt;strong>ND 滤镜&lt;/strong>：即减光镜，减少进光量，延长曝光时间，用于拍摄云彩，溪流等长曝光场景。&lt;/p>
&lt;p>&lt;strong>AF&lt;/strong>：自动对焦（Auto Focus）。&lt;/p>
&lt;p>&lt;strong>AE&lt;/strong>：自动曝光（Auto Exposure）。&lt;/p>
&lt;h2 id="半按快门警告图标">半按快门警告图标&lt;/h2>
&lt;p>&lt;strong>抖动警告（!((📷))）&lt;/strong>：快门速度过慢，照片质量会因为微微抖动而模糊。可以改善周围环境亮度或是手动提高快门速度。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/images/main/image-20220820184826880.png" alt="">&lt;/p>
&lt;p>&lt;strong>自动曝光警告（!AE）&lt;/strong>：快门速度太快，可能照片会发暗。可以调低快门速度或是增大光圈等。&lt;/p>
&lt;p>&lt;img src="https://raw.staticdn.net/stevedsun/stevedsun.github.io/master/images/main/image-20220820184847600.png" alt="">&lt;/p>
&lt;h2 id="各项参数的对抖动曝光噪点的影响">各项参数的对抖动、曝光、噪点的影响&lt;/h2>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>参数&lt;/th>
&lt;th>增加参数值对进光量的影响&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>光圈（F）&lt;/td>
&lt;td>提高&lt;/td>
&lt;td>手动对焦模式或者快拍模式下，光圈越小，【超焦距】带来的取景深度越大&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>快门速度越快&lt;/td>
&lt;td>降低&lt;/td>
&lt;td>快门速度 1/250 适合抓拍，1/60 为通常的安全快门&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ISO&lt;/td>
&lt;td>提高&lt;/td>
&lt;td>800 以内画质较好，超过 800 噪点明显变强&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>曝光补偿（EV）&lt;/td>
&lt;td>提高&lt;/td>
&lt;td>影响亮度，非自动档可用，本质是增减相机控制光圈、快门、ISO 的比例时的权重，通常拍摄雪景和较黑的物体时候需要调节&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>白平衡（WB）&lt;/td>
&lt;td>无影响&lt;/td>
&lt;td>影响色彩&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>白平衡补偿（B：G）&lt;/td>
&lt;td>无影响&lt;/td>
&lt;td>手动增减白平衡权值，可以做出胶片等效果&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>效果（D:C:S）&lt;/td>
&lt;td>无影响&lt;/td>
&lt;td>影响滤镜效果，可以拍出风格强烈的作品&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ND 滤镜（开）&lt;/td>
&lt;td>降低&lt;/td>
&lt;td>在强光状态下打开 ND 滤镜可以降低 3 档进光量，即使在白天也能用慢门或者大光圈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>闪光灯（开）&lt;/td>
&lt;td>提高&lt;/td>
&lt;td>在白天背光和夜晚都可以提高近景中被摄体的亮度&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="景深标尺nd-滤镜曝光补偿的技巧">景深标尺、ND 滤镜、曝光补偿的技巧&lt;/h2>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8s7jpj44nj319j0u0tgf.jpg" alt="4A78E115-0550-4D08-A4DE-672EE9D0E6EB">&lt;/p></description></item><item><title>Nintendo Switch 联机优化策略</title><link>https://sund.site/posts/2019/nintendo-switch-network-opt/</link><pubDate>Mon, 07 Oct 2019 22:18:00 +0800</pubDate><guid>https://sund.site/posts/2019/nintendo-switch-network-opt/</guid><description>&lt;h2 id="简单方法">简单方法&lt;/h2>
&lt;p>首先介绍下Nintendo Switch在哪里设置网络，如下图，设置界面=&amp;gt;互联网设置里，可以修改IP，DNS等常用网络配置。修改之后点击「链接测试」，可以测试你的NAT和下载、上传速度。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7pz8xft9ej31i30u0ng9.jpg" alt="1">&lt;/p>
&lt;h3 id="首先设置路由器的wifi类型为5g">首先：设置路由器的WIFI类型为5G&lt;/h3>
&lt;p>因为NS对2.4GHz的Wifi优化非常差，所以一般玩家都选择设置Wifi类型为5GHz，5G的缺点是穿墙能力差，但是速度很快，所以建议把NS放在离路由器不太远的位置。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7pzbkstq4j30vy0l2mz4.jpg" alt="image-20191007215608157">&lt;/p>
&lt;h3 id="最简单粗暴的方法购买加速器">最简单粗暴的方法：购买加速器&lt;/h3>
&lt;p>购买加速器是最省心省力的方案，以网易UU加速器为例，加速后可以把NAT从D上升到B或A，完全可以满足大部分延迟要求较低游戏的需要。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7pyt6dxbij31aw0qokjl.jpg" alt="image-20191007213820867">&lt;/p>
&lt;p>Mac版UU加速器目前还处于免费测试阶段，可以随意使用。按照提示配置NS上的IP和DNS即可。但是如果想让联机速度突破A，甚至小于30ms延迟，就要结合第二部分「进阶方法」中的内容了。&lt;/p>
&lt;h3 id="最方便的方法dns优化">最方便的方法：DNS优化&lt;/h3>
&lt;p>这也是最多人的办法，以「Splatoon2」为例，四川电信在不使用任何加速器的情况下，单单设置了合适的DNS，就可以流畅体验乌贼娘了。注意这种方法在晚上8～10点高峰期间有一定概率掉线。下面提供一些我常用的DNS，不同地区效果不同，需要自己尝试。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">218.102.23.228 &lt;span class="c1"># 一般用作日本eshop下载游戏，速度提升明显&lt;/span>
203.198.7.66
168.126.63.1 &lt;span class="c1"># 著名韩国DNS节点，Splatoon2 联机常用&lt;/span>
168.126.63.2 &lt;span class="c1"># 同上&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="进阶方法">进阶方法&lt;/h2>
&lt;p>进阶方法可以最大限度的提升你的网络通信效率。&lt;/p>
&lt;h3 id="路由器设置优化">路由器设置优化&lt;/h3>
&lt;p>路由器有两处可优化的地方：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>设置路由器DMZ，所谓DMZ就是隔离区，简单理解为外网可以直接访问你DMZ中指定的IP。现在把你主机的IP放入DMZ中，这样牺牲一定安全性的同时换来延迟的进一步降低。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7pyoqpcpsj311s0ccgow.jpg" alt="image-20191007213358497">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开启路由器的「Full Cone NAT」。以pandavan固件为例，在防火墙设置中可以找到。其他路由器也一定有类似的设置，耐心找一下。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7pyq72iu5j311w0m8q5q.jpg" alt="image-20191007213535337">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="电信宽带改为桥接方式">电信宽带改为桥接方式&lt;/h3>
&lt;p>中国电信宽带默认使用光猫拨号上网。这样普通用户免去很多麻烦的同时，也增加了NAT联机的延迟。解决办法就是把宽带连接方式改为「桥接」。&lt;/p>
&lt;p>所谓桥接，就是不使用电信提供的光猫进行拨号上网，而是直接由你自己的路由器拨号，这样可以一定程度降低延迟。中国电信网上营业厅可以直接修改，也可以自己打客服电话或去营业厅办理（只要告诉业务人员，我要把宽带连接方式改为桥接）。&lt;/p>
&lt;p>修改之后的十几分钟内时间，你的网络会断开，此时你必须用自己的宽带账号和密码在路由器上（注意不是光猫）重新登录宽带上网。我使用桥接+DNS修改，在未使用加速器的情况下，就可以把NAT直接从D提升为A。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6gy1g7pz96eo7pj31hs0u07gp.jpg" alt="2">&lt;/p></description></item><item><title>8月做了什么</title><link>https://sund.site/posts/2019/aug-routine/</link><pubDate>Mon, 02 Sep 2019 15:52:58 +0800</pubDate><guid>https://sund.site/posts/2019/aug-routine/</guid><description>&lt;p>准备新开一个话题，用每个月的总结替代年度总结。这是第一篇。&lt;/p>
&lt;p>最近国内国际上大事不断，在这个历史转折点当口，每个从互联网汲取信息的人都应该有点独立思考能力。「第一性原理」（first principles thinking）是伊隆·马斯克在TED演讲时回答「为什么能够在不同的领域都能够取得成功？」时给出的答案。第一性原则要求我们剔除用「比较」来权衡事物好坏的思维方式，转而选择一层层向下探求本质，再由本质反推出认识。这里有篇&lt;a href="https://neilkakkar.com/A-framework-for-First-Principles-Thinking.html">博客文章&lt;/a>做了细致的讲解。&lt;/p>
&lt;h2 id="有什么发现">有什么发现&lt;/h2>
&lt;p>&lt;strong>七龙珠里的元气弹&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6m8onj2xij30sg0jx0ui.jpg" alt="EBX-IqpUYAEkJTP?format=jpg&amp;name=medium">&lt;/p>
&lt;p>这是一群香港示威者把激光笔的光束汇聚到一张反光板上，以干扰警方行动。像七龙珠里孙悟空把大家的力量汇聚起来形成超大元气弹的画面。非常有想象力。&lt;/p>
&lt;p>&lt;strong>Hacker News 和 开发者头条、掘金的差别&lt;/strong>&lt;/p>
&lt;p>国内两大技术新闻「开发者头条」和「掘金」的文章主要以技术理论和工程实践为主。这两者都在一定程序上模仿国外的Hacker News，但是Hacker News除了技术和工程实践，更多的是对政治、经济、文化的深度思考。&lt;/p>
&lt;p>在某种程度上，中国的技术人被阉割了右脑。右脑有赋予行为合理化的能力。国内的技术「场」，就是一个你只需要关心技术本身而不需要关心社会、文化影响的环境。&lt;/p>
&lt;p>&lt;strong>人生五十年，如梦又似幻&lt;/strong>&lt;/p>
&lt;p>前不久上一家公司的老板因为癌症去世了，年仅51岁。在50岁之前，他拥有纳斯达克上市的公司，在北京核心商圈有一栋办公楼。我想起《影武士》里织田信长唱的那首歌：&lt;/p>
&lt;blockquote>
&lt;p>人生五十年，与天地长久相较，如梦又似幻。一度得生者，岂有不灭者乎？&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>白领快乐水&lt;/strong>&lt;/p>
&lt;p>元气森林苏打气泡水，0热量、苏打、气泡。这几个元素加起来就是现在办公室一族的全部追求了。这是一种真正的「现代饮料」。&lt;/p>
&lt;p>&lt;strong>马里奥创造家2&lt;/strong>&lt;/p>
&lt;p>这是个创造快乐的游戏，拥有它的朋友可以玩玩我制作的地图：9PB-WGX-WVF&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6m8pb1q5fj30qm0dg17n.jpg" alt="image-20190902163956190">&lt;/p>
&lt;p>&lt;strong>任意听播客&lt;/strong>&lt;/p>
&lt;p>这个网站&lt;a href="https://getpodcast.xyz">https://getpodcast.xyz&lt;/a>可以把最受欢迎的中文博客添加到任意你常用的podcast客户端。&lt;/p>
&lt;p>&lt;img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6m8phqnqhj31cn0u07k1.jpg" alt="image-20190902164259542">&lt;/p>
&lt;h2 id="看过的书">看过的书&lt;/h2>
&lt;p>&lt;strong>《非暴力沟通》&lt;/strong>&lt;/p>
&lt;p>一本讲沟通的书，越是亲近的人，越应该认真的对待「沟通」这件事。但是我们日常生活中往往会采取相反的做法。&lt;/p>
&lt;p>&lt;strong>《交互的未来》&lt;/strong>&lt;/p>
&lt;p>原离线的主编Bob推荐的书，&lt;del>内容其实挺一般的&lt;/del>。里面有一个很有趣的思考，自动扶梯在故障时会变成普通的扶梯。这种能够出故障时「自我降级」的设计原则，其实生活中很常见，比如电动牙刷，蓝牙音箱，WIFI智能插座。你还能想到哪些身边的设备呢？&lt;/p>
&lt;h2 id="言叶">言叶&lt;/h2>
&lt;blockquote>
&lt;p>Note that I do not claim that all of this makes me more productive, merely that it makes things more searchable.&lt;/p>
&lt;/blockquote>
&lt;p>usesthis网站对 Paul Ford 的&lt;a href="https://usesthis.com/interviews/paul.ford/">采访&lt;/a>。知识管理体系中，相比于高效性，「可搜索性」或许更加重要。&lt;/p>
&lt;blockquote>
&lt;p>梅毒这种可怕的疾病在不同的国家被称作不同的名字。在俄罗斯，它被称作波兰病；在波兰，它被称作德国病；在德国，它被称作法国病；在法国，它被称作意大利病；在意大利，他们称之为法国病。&lt;/p>
&lt;/blockquote>
&lt;p>推特网友@peterlu&lt;/p>
&lt;blockquote>
&lt;p>做个世俗眼中的成年人吧！&lt;/p>
&lt;/blockquote>
&lt;p>这是《勇者斗恶龙》改编电影的台词。该电影被日本观众广泛吐槽——想要逃离生活去看电影，却被导演教做人。&lt;/p>
&lt;blockquote>
&lt;p>那你认为是什么原因，让你无法主动提出话题呢？&lt;/p>
&lt;p>是因为你对对方没兴趣。&lt;/p>
&lt;/blockquote>
&lt;p>《凪的新生活》台词。为什么我们善于倾听又照顾别人感受，却仍然给人一种不会聊天的感觉。&lt;/p>
&lt;blockquote>
&lt;p>它告诉我，无论看上去多么沉闷的工作都可以是自我表达的场所，也都可以呈现出品质的光辉。&lt;/p>
&lt;/blockquote>
&lt;p>李如一的《一天世界》博客：&lt;a href="https://blog.yitianshijie.net/2019/08/23/leakage/">https://blog.yitianshijie.net/2019/08/23/leakage/&lt;/a>&lt;/p>
&lt;h2 id="联系我">联系我&lt;/h2>
&lt;p>如果你有什么有趣的发现想跟我分享，欢迎邮件至 &lt;a href="mailto:sund.chn@gmail.com">sund.chn@gmail.com&lt;/a>&lt;/p></description></item><item><title>制定一个人的日本旅行计划</title><link>https://sund.site/posts/2019/jp-travel/</link><pubDate>Thu, 11 Apr 2019 13:19:04 +0800</pubDate><guid>https://sund.site/posts/2019/jp-travel/</guid><description>&lt;p>独自一个人出国旅行有很多不方便，但作为交换，那份无拘无束的自由和旅途中的不期而遇完全值得这种付出。为了进一步降低不便，提高旅行体验，我从三个方面制定旅行计划：&lt;/p>
&lt;ul>
&lt;li>前期准备。这部分没有技术含量，网上很多攻略，我列举出来供参考&lt;/li>
&lt;li>路线规划。这部分使用了一些技巧和工具，是我自己总结的经验&lt;/li>
&lt;li>学习基本礼貌用语，地名和礼仪。这部分内容会增强你的旅行体验&lt;/li>
&lt;/ul>
&lt;p>带图原文： &lt;a href="https://mp.weixin.qq.com/s/rAZcFmW-96CrOkvQY4N04w">https://mp.weixin.qq.com/s/rAZcFmW-96CrOkvQY4N04w&lt;/a>&lt;/p>
&lt;h2 id="旅行计划">旅行计划&lt;/h2>
&lt;h3 id="-前期准备">&amp;gt; 前期准备&lt;/h3>
&lt;p>这部分都是固定套路，没有技巧。很多其他攻略都有，我整理出来供参考。&lt;/p>
&lt;p>&lt;em>护照&lt;/em>&lt;/p>
&lt;p>日本不接受个人申请，所以只能去淘宝找最近的旅行社申请。我在成都，所以找了一家信誉比较高的重庆旅行社（送签重庆日本领馆）。把必备的材料邮寄过去。大概10~20天出签。&lt;/p>
&lt;p>机票和酒店都不需要你提供，旅行社会解决。你只要安静等待出签。&lt;/p>
&lt;p>&lt;strong>使用工具&lt;/strong>：淘宝。&lt;/p>
&lt;p>&lt;em>机票&lt;/em>&lt;/p>
&lt;p>公认体验最好的是全日空航空(官网：&lt;a href="https://www.ana.co.jp/zh/cn/">https://www.ana.co.jp/zh/cn/&lt;/a>)。全日空的餐食和服务质量都非常高。建议提前两个月预订机票，在官网搜索计划旅行时间前后的日期，很大概率可以3~5折价格订到往返的机票。&lt;/p>
&lt;p>&lt;strong>使用工具&lt;/strong>: 全日空官方网站&lt;/p>
&lt;p>&lt;em>酒店&lt;/em>&lt;/p>
&lt;p>因为日本的民宿不被官方承认，所以airbnb之类的民宿出现纠纷是没有保障的。建议在Booking上预订酒店。和式酒店(日本传统风格的榻榻米地板的酒店)往往没有独立卫浴和床，所以价格会便宜很多，追求舒适的话建议订正常的酒店，想体验日本民风或者喜欢和很多外国人一起过集体生活的，可以考虑一些青年旅社和和式酒店，不建议考虑胶囊旅馆，体验非常差。&lt;/p>
&lt;p>另外，建议先读完本文&amp;quot;规划路线&amp;quot;部分，再预订酒店。&lt;/p>
&lt;p>&lt;strong>使用工具&lt;/strong>：Booking App&lt;/p>
&lt;p>&lt;em>电话卡&lt;/em>&lt;/p>
&lt;p>淘宝可以买到很便宜的日本7天4G流量卡。如果单人旅行的话，比随身wifi要方便不少。&lt;/p>
&lt;p>&lt;strong>使用工具&lt;/strong>：淘宝&lt;/p>
&lt;p>&lt;em>地铁券&lt;/em>&lt;/p>
&lt;p>西瓜卡(Suica)是关东地区的常用地铁卡。不但可以坐地铁还可以在便利店买东西，可以直接在日本机场购买。&lt;/p>
&lt;p>&lt;img src="http://img6.16fan.com/201510/28/113242h6rxvuqmvz3pqijy.jpg-700" alt="img">&lt;/p>
&lt;p>具体的购买方法见自动贩卖机。&lt;/p>
&lt;p>&lt;img src="http://img6.16fan.com/201510/28/114059iesz1ea7pe7duswg.png-700" alt="img">&lt;/p>
&lt;p>众所周知日本的交通比较贵。这里要好好说下技巧，日本很多针对外国游客的福利，比如东京地铁三日券，可以在72小时内任意乘坐地铁，非常划算。&lt;/p>
&lt;p>&lt;strong>使用工具&lt;/strong>：东京地铁网站，包括购买地铁票的方法和详细地图：&lt;a href="https://www.tokyometro.jp/tcn/ticket/travel/index.html">https://www.tokyometro.jp/tcn/ticket/travel/index.html&lt;/a>。&lt;/p>
&lt;p>如果怕到日本后找不到购买的地方，也可以在淘宝提前购买好。&lt;/p>
&lt;p>&lt;em>景点票&lt;/em>&lt;/p>
&lt;p>日本的大部分室外景点是不要钱的。很多观光路线有缆车、登山电车需要买票。建议提前上网查好目标城市的观光票是否有通票(比如我去箱根前，在东京新宿可以买到箱根2日周游券，可以乘坐所有缆车、电车等交通工具，参观所有景点免票)。这会省下很多钱，还能免去多次买票的麻烦。&lt;/p>
&lt;p>日本的城市都各自的宣传网站。可以登录上去查看旅行优惠和景点信息。&lt;/p>
&lt;p>&lt;strong>使用工具&lt;/strong>：搜索引擎搜索城市的官网。&lt;/p>
&lt;p>&lt;em>货币&lt;/em>&lt;/p>
&lt;p>建议在出发前至少兑换3万日元随身携带。注意日本商店找零大量使用硬币，所以有一个能装硬币的小钱袋是必须的（建议当地买一个）！另外日本兑换货币的地方主要是7-11便利店，而东京大阪这种大城市7-11便利店更是随处可见。所以不需要太担心。购物的话银联卡和Visa卡基本随处可用。&lt;/p>
&lt;p>&lt;strong>使用工具&lt;/strong>：有些银行兑换外币需要提前申请。到营业厅时记得随身携带身份证。&lt;/p>
&lt;h3 id="-规划路线">&amp;gt; 规划路线&lt;/h3>
&lt;p>我使用&amp;quot;看板&amp;quot;的方式来规划旅行路线。具体方法就是把想去的城市和旅行景点全部写在便签纸上（也可以用电子看板”Trello“），按照地区把同一个地区范围的景点贴在一起。一个人一天最多走2~3个地区，每个地区1~2个景点（不建议行程制定的太匆忙）。按照这个原则，我制定了4步路线规划方案：&lt;/p>
&lt;ol>
&lt;li>从每个地区挑出自己最想去的2、3个景点。&lt;/li>
&lt;/ol>
&lt;p>注意有些景点需要在官方提前预订（比如东京的皇居）。&lt;/p>
&lt;ol start="2">
&lt;li>
&lt;p>将这些景点标记在地图上。我使用的工具是Google My Map(&lt;a href="https://www.google.com/maps/d/u/0/">https://www.google.com/maps/d/u/0/&lt;/a>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>用Google Map搜索地铁路线，规划一天2~3个地区的行程。(比如第一天去浅草、上野、东京大神宫，那么先找好酒店到这些景点的地铁路线，算好坐车时间)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>按照前3步设计好每一天的行程，写成清单。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>至此，你已经有了完备的可执行旅行计划。女生可以出发前把计划清单发给家人，有备无患。&lt;/p>
&lt;h3 id="-学习基本礼貌用语地名和礼仪">&amp;gt; 学习基本礼貌用语，地名和礼仪&lt;/h3>
&lt;p>这部分可以网上搜下，&lt;/p>
&lt;ul>
&lt;li>礼貌用语。学会说&amp;quot;你好&amp;quot;、&amp;ldquo;谢谢&amp;rdquo;、&amp;ldquo;对不起&amp;quot;就足够了。用得最多的是すみません(si mi ma se en)，&amp;ldquo;打扰一下，对不起&amp;rdquo;。&lt;/li>
&lt;li>地名。因为机场买票，问路经常要用日语地名，所以在Google地图上提前找好地名的罗马音(就是英文发音)，比如浅草的英文(Asakusa)，日语发音就是英文发音。&lt;/li>
&lt;li>礼仪。参拜神社、餐饮的礼仪。如果当地没有熟人，建议提前网上学一下，可以增加很多乐趣。&lt;/li>
&lt;/ul>
&lt;p>除了上面提到的三点，如果是吃货可以了解下当地有名的饭店，如果喜欢拍照，也可以搜下知名的摄影地点。&lt;/p>
&lt;h3 id="回顾">回顾&lt;/h3>
&lt;p>人生中会经历很多次旅行，对于独自旅行的人，旅行中会遇到很多不确定因素。旅行之后把这些因素总结起来作为回顾，帮助下次旅行制定更加合理的计划。&lt;/p></description></item><item><title>跨过真实和虚无的河</title><link>https://sund.site/posts/2018/csqstz/</link><pubDate>Thu, 04 Oct 2018 13:25:55 +0800</pubDate><guid>https://sund.site/posts/2018/csqstz/</guid><description>&lt;p>两个月前在亚马逊买村上春树《刺杀骑士团长》的简体中文版电子书，译者是大名鼎鼎林少华先生。我对林少华的了解，源自高中时期看的《挪威的森林》，林先生那晦涩的翻译和故弄玄虚的修辞让年少无知的我看得头昏脑涨。读了几章《刺杀骑士团长》后，唤起了我不愉快的青少年回忆，真的还是无法接受这种「不忠实于原著」的翻译风格呀。在这种心态下，最终还是去淘宝买了两册赖明珠的台译版来看。所以下面要讲的内容，都是基于台湾繁中版本的翻译。&lt;/p>
&lt;h2 id="主要人物-剧透">主要人物 （剧透）&lt;/h2>
&lt;p>&lt;strong>我&lt;/strong> ：青年画家，和妻子离婚后住进了朋友雨田政彦父亲过去生活过的山中别墅里，意外发现了著名画家雨田具彦藏在阁楼的画作《刺杀骑士团长》。后来机缘巧合认识了附近别墅居住的富豪免色先生和山下的秋川麻里惠一家。&lt;/p>
&lt;p>&lt;strong>雨田具彦&lt;/strong> ：朋友雨田政彦的父亲，90岁高龄的画家，已经失去神志住在疗养院里。年轻在维也纳留学期间和恋人组织刺杀纳粹军官的活动，恋人被纳粹迫害致死，自己则因家族关系而苟且偷生回到国内。其弟弟也因参军入伍，在南京大屠杀期间留下心理创伤，回国后自杀。雨田具彦独居在主人公后来居住的山中别墅里，直到神志不清被儿子送去疗养院。&lt;/p>
&lt;p>&lt;strong>骑士团长&lt;/strong> : 在我无意中打开了山后被石头封住的井后，突然出现在我的画室里的自称是「Idea」（简中翻译为理念）的灵体。长的和雨田具彦画作里的骑士团长一模一样，只是身高只有60公分。本作中只有三个人能看见骑士团长——我、羽田具彦、秋川麻里惠。&lt;/p>
&lt;p>&lt;strong>秋川麻里惠&lt;/strong> ： 青春期刚刚发育的少女，童年在山中长大，拥有敏锐的洞察力。其母亲曾经是免色先生的女友，在和免色分手前两人发生关系。在生下麻里惠之后因毒蜂蛰咬过敏而死。后麻里惠和姑姑秋川苼子一起住在山里。免色一直认为麻里惠有可能是他的亲生女儿。&lt;/p>
&lt;p>&lt;strong>免色&lt;/strong> ： 富豪，生活井井有条，是自控力非常强又有能力控制住周围一切的男人。独居在附近的白色别墅里，常年用望远镜窥探秋川麻里惠一家的生活。&lt;/p>
&lt;h2 id="光即是影影即是光">光即是影，影即是光&lt;/h2>
&lt;p>《刺杀骑士团长》的故事源自莫扎特版的歌剧《唐璜》。讲的是风流成性的唐璜（台译：唐·乔万尼）在勾引骑士团长的女儿被发现后，在和骑士团长决斗中杀死了骑士团长，最后遭报应堕入地狱的故事。&lt;/p>
&lt;p>正如书中所说，Idea是一种类似观念的东西，比如爱本身不是Idea，但是产生爱的东西就是Idea。我把它理解为「本我」，林少华说，书中出现的洞穴——井，在日语里和英文的「本我」谐音。所以我认为，书中多次出现的「骑士团长」也许是各个人物的内心本我的写照。年轻的雨田具彦对恋人、弟弟的死去充满自责和愧疚，又因为政治、家庭的原因无法对人诉说自己的痛苦，便将自己化身故事里的唐璜，刺杀了骑士团长，希望自己替代爱人和弟弟堕入地狱。&lt;/p>
&lt;p>值得注意的是，书里反复出现的元素「窥探」和「封闭的空间」。书中几处「窥探」的描写：&lt;/p>
&lt;ul>
&lt;li>在名为《刺杀骑士团长》的画作里，有一个从地下打开盖子窥探的长脸男&lt;/li>
&lt;li>用望远镜窥探麻里惠生活的免色&lt;/li>
&lt;li>仿佛暗中窥探我，我假想中的「开斯巴鲁森林人汽车的男人」&lt;/li>
&lt;li>最后躲在衣柜里窥探免色的秋川麻里惠&lt;/li>
&lt;/ul>
&lt;p>他们每个人都在好奇心的驱使下窥探别人（却在过程中窥探到了自己）。在漆黑的封闭空间里，意识和肉体剥离，仿佛灵魂出窍般看到了自己真实的内心。后山的洞穴之于我，曾经关押过的拘留所之于免色先生，衣柜之于秋川麻里惠，都是窥探到自己内心世界的封闭空间。&lt;/p>
&lt;p>如果按照我上面的理解，故事的脉络就是这样：主人公、免色、麻里惠、雨田具彦都是被自己内心折磨的、介于「真实和虚无之间」的人。主人公一方面觉得自己深爱妻子，另一方面怨恨妻子的背叛，自己却又与人妻发生关系，是介于背叛与被背叛的人。免色是能力超强控制一切的男人，却无法得知疑似女儿的麻里惠是否和自己有血缘关系，于是免色也是介于掌控和失控的男人。麻里惠不必说，对自己身世一无所知，介于「免色先生的女儿」和「不是免色先生女儿」两种身份之间。雨田具彦则纠结于年轻时的自己，在失去爱人和兄弟的痛苦中即是人人知晓的画家，又是一个无法告知任何人内心感受的孤独老人。&lt;/p>
&lt;p>每一个人都在真实和虚无之间徘徊。整个故事就是围绕村上春树构建起来的世界展开。光即是影，影即是光。真实和虚无互为存在的依据。&lt;/p>
&lt;p>中间的过程不再赘述，好奇的看官可以读到这里就打住，去买一本书，自己来细细品味。如果你不想读长篇小说或者已经读完只想看看我怎么理解，那么请继续往下看。&lt;/p>
&lt;p>故事给出了几种人的结局。&lt;/p>
&lt;p>为了拯救失踪的秋川麻里惠，主人公「我」按照「骑士团长」的提示，在雨田具彦的病床前重演了《刺杀骑士团长》中的一幕，目睹了我亲手杀死了「骑士团长」的雨田具彦内心终于释然，几天后安详辞世。几十年来萦绕在老人心头的痛苦、自责、愧疚被我一刀捅破，产生怨恨的种子不复存在。&lt;/p>
&lt;p>在杀死骑士团长过程中引出了地板下窥探的「长脸男」（也是画作中出现的人物），「我」搬开地上的盖板进入了隐喻的地下世界。在经过真实和虚无之河时，「我」把秋川麻里惠的护身符（企鹅挂饰）留给河中间的摆渡人当做船资后，「我」独自爬进漫长的洞穴（此处和主人公小时候与妹妹爬进富士山附近的风洞的回忆呼应），在战胜了「双重隐喻」后，在漆黑的封闭空间里，内心终于决定和妻子和解（也终于与自己和解）。&lt;/p>
&lt;p>至于什么是「双重隐喻」，书中提到是骑士团长提醒主人公要小心的一种危险的存在。会吞噬那些意志不坚定的人。在我理解，这是内心本我和现实互相影响时，不要让自以为的真实改变了本我的一种比喻（姑且这么解释吧）。&lt;/p>
&lt;p>回到秋川麻里惠的故事线，因为「我」把麻里惠的护身符留给了「真实与虚无之河」的摆渡人，所以麻里惠的身份永远介于真实和虚无之间，也就是说，麻里惠到底是不是免色的女儿永远成了谜。故事的最后章节，麻里惠躲在免色家衣橱里看到的「好像是免色却是不是免色」的人影，就是免色探求麻里惠真实身份的本我的隐喻。麻里惠紧紧抓住衣柜里的女人衣服（其实是她生母留在免色家，被免色珍藏起来的衣物），并且被「骑士团长」告知：「衣服会保护你」。这恰恰说明，免色在故事的最后，内心依然是爱着麻里惠的生母，所以最后放弃了探求麻里惠的真实血缘身份。不去打扰麻里惠平静的生活。这也是「我」在地下世界做出的决定和真实世界产生了某种联系，最后拯救了麻里惠平静的生活，让真相永远隐藏起来。&lt;/p>
&lt;p>免色先生最后和麻里惠的姑姑笙子热恋，似乎不再关心麻里惠的身世了……这是我唯一觉得村上春树有点草率的处理。&lt;/p>
&lt;h2 id="题外话">题外话&lt;/h2>
&lt;p>在读完《刺杀骑士团长》上册后，我正好休年假去日本旅行，期间在箱根的山里住了一宿民宿。箱根距离书中主人公居住的小田原市不远，在山里吹着风听雨声时，真的有种置身小说里的感觉。我住的那间和屋非常简陋，风一吹四周的窗子和木板拉门都会吱吱嘎嘎作响。晚间寂静无人的乡村里还能隐约听到风铃的声音，像极了书里主人公在深夜听到后山摇铃声的场景。只有日本的作家才能写出这样的故事，用那种日本人细腻、敏感的神经，探索人心里不易察觉的感受。也希望林少华老师晚年幸福，不要再接手村上春树的作品翻译工作了。:)&lt;/p></description></item><item><title>《Python源码剖析》第三部分——Python虚拟机进阶</title><link>https://sund.site/posts/python-3/</link><pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate><guid>https://sund.site/posts/python-3/</guid><description>&lt;h2 id="python-环境初始化">Python 环境初始化&lt;/h2>
&lt;p>进程启动后创建PyInterpreterObject，PyInterpreterObject里面维护了全局module映射表&lt;code>interp-&amp;gt;modules&lt;/code>，该表默认初始化为__buildin__模块，&lt;/p>
&lt;h2 id="python-的-import-机制">Python 的 import 机制&lt;/h2>
&lt;blockquote>
&lt;p>Python虚拟机在执行“import A”时，会为package A创建一个module对象，同时会在该module维护的dict中添加两个表示元信息的属性：&lt;strong>name__和__path&lt;/strong>。而Python虚拟机从A/&lt;strong>init&lt;/strong>.py中执行“import mod1”时，也会为mod1创建一个module对象，同时也会设置__name__属性，但是这时就不设置__path__属性了。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>package是由module聚合而成。更清楚的表述是：module属于一个package。我们不能说，module1属于module2。我们前面已经看到，module的路径实际上是一种树状结构，从图14-11中可以看到，在这个树状结构中，module的父节点只能是package，而不可能是另一个module。&lt;/p>
&lt;/blockquote>
&lt;h2 id="gil">GIL&lt;/h2>
&lt;p>Python虚拟机使用一个全局解释器锁（Global Interpreter Lock，GIL）来互斥线程对python虚拟机的使用。&lt;/p>
&lt;p>注意这里GIL是解释器一级的互斥锁，也就是同一时间只能有一个线程占用python解释器。所以&lt;strong>GIL是用来让操作系统中分配的多个线程互斥的使用python解释器的，是建立在系统线程调度基础之上的一套C API互斥机制&lt;/strong>，是比操作系统线程资源更大粒度的锁。&lt;/p>
&lt;p>Python的线程是基于操作系统原生线程的，所以python的线程不是「虚拟出来的」。&lt;/p>
&lt;blockquote>
&lt;p>那么究竟Python会在众多的等待线程中选择哪一个幸运儿呢？答案是，不知道。没错，对于这个问题，Python完全没有插手，而是交给了底层的操作系统来解决。也就是说，Python借用了底层操作系统所提供的线程调度机制来决定下一个进入Python解释器的线程究竟是谁。&lt;/p>
&lt;/blockquote>
&lt;p>GIL在C里对应的结构：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="p">[&lt;/span>&lt;span class="n">thread_nt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">NRMUTEX&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">LONG&lt;/span> &lt;span class="n">owned&lt;/span> &lt;span class="p">;&lt;/span>
&lt;span class="n">DWORD&lt;/span> &lt;span class="n">thread_id&lt;/span> &lt;span class="p">;&lt;/span>
&lt;span class="n">HANDLE&lt;/span> &lt;span class="n">hevent&lt;/span> &lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">NRMUTEX&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">PNRMUTEX&lt;/span> &lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>owned&lt;/code>初始化为-1，表示锁可用，否则为不可用。&lt;code>thread_id&lt;/code>代表线程id，最后一个是平台相关的变量，win32上是一个event内核对象。&lt;/p>
&lt;h2 id="多线程---标准调度">多线程 - 标准调度&lt;/h2>
&lt;blockquote>
&lt;p>当Python启动时，是并不支持多线程的。换句话说，Python中支持多线程的数据结构以及GIL都是没有创建的，Python之所以有这种行为是因为大多数的Python程序都不需要多线程的支持&lt;/p>
&lt;/blockquote>
&lt;p>书中指出，由于python的多线程标准调度机制是有代价的，所以默认单线程不初始化GIL。&lt;/p>
&lt;ol>
&lt;li>主线程启动后，会用&lt;code>ident = PyThread_start_new_thread(t_bootstrap, (void*) boot);&lt;/code>函数调用操作系统内核接口创建子线程，然后主线程挂起等待&lt;code>obj.done&lt;/code>。注意，此时主线程中持有GIL。&lt;/li>
&lt;li>主线程等待的这段时间里，子线程将自己的线程id等信息设置好，通知内核对象&lt;code>obj.done&lt;/code>，唤醒等待中的主线程。此刻，主线程和子线程都同时由操作系统调度，但是主线程一直持有着GIL。&lt;/li>
&lt;li>子线程继续执行后进入python解释器，发现需要等待获取GIL。此时子线程主动将自己挂起(而不是由操作系统挂起)。这样就进入了两个线程通过GIL调度的阶段。&lt;/li>
&lt;li>主线程被唤醒后，继续执行，直到python内置的时钟计时器&lt;code>_Py_Ticker&lt;/code>结束才将自己挂起，让出GIL(&lt;code>_Py_Ticker&lt;/code>会在每次执行一条字节码后自动减1，初始默认为100)。&lt;/li>
&lt;/ol>
&lt;p>通过上面4步，python的两个线程就完成了从系统调度上升到python标准GIL调度的流程。&lt;/p>
&lt;h2 id="阻塞调度">阻塞调度&lt;/h2>
&lt;p>如同上面流程介绍的，标准调度是python使用软件时钟调度线程，那么有时候python的线程会自我阻塞，比如&lt;code>raw_input()&lt;/code>、&lt;code>sleep()&lt;/code>等函数，这时python就会使用阻塞调度的方式。&lt;/p>
&lt;ol>
&lt;li>主线程调用&lt;code>sleep(1)&lt;/code>后，调用&lt;code>Py_BEGIN_ALLOW_THREADS&lt;/code>立刻释放GIL，然后调用操作系统的sleep操作。此时主线程就由操作系统自动管理。&lt;/li>
&lt;li>子线程拿到GIL。此时主线程和子线程同时可被操作系统调度。操作系统在执行一段时间子线程后会挂起，调度主线程，发现主线程sleep没结束就挂起主线程，就继续唤醒子线程执行。&lt;/li>
&lt;li>当主线程sleep结束，操作系统唤醒主线程。主线程调用&lt;code>Py_END_ALLOW_THREADS&lt;/code>再次申请GIL，重新进入python标准调度流程。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>可见python在保证线程安全的前提下，允许线程在某些时刻脱离GIL标准调度流程。&lt;/strong>&lt;/p>
&lt;p>其中&lt;code>Py_BEGIN_ALLOW_THREADS&lt;/code>和&lt;code>Py_END_ALLOW_THREADS&lt;/code>两个负责释放和等待GIL的宏的实现如下。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="p">[&lt;/span>&lt;span class="n">ceval&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="cp">#define Py_BEGIN_ALLOW_THREADS { \
&lt;/span>&lt;span class="cp"> PyThreadState *_save; \
&lt;/span>&lt;span class="cp"> _save = PyEval_SaveThread();
&lt;/span>&lt;span class="cp">#define Py_END_ALLOW_THREADS PyEval_RestoreThread(_save); \
&lt;/span>&lt;span class="cp"> }
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="p">[&lt;/span>&lt;span class="n">ceval&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="n">PyThreadState&lt;/span>&lt;span class="o">*&lt;/span> &lt;span class="n">PyEval_SaveThread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="kt">void&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">PyThreadState&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tstate&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">PyThreadState_Swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">NULL&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">interpreter_lock&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">PyThread_release_lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">interpreter_lock&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">tstate&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="kt">void&lt;/span> &lt;span class="n">PyEval_RestoreThread&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">PyThreadState&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tstate&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">interpreter_lock&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">err&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">errno&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">PyThread_acquire_lock&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">interpreter_lock&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">errno&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">err&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">PyThreadState_Swap&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tstate&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="用户级互斥">用户级互斥&lt;/h2>
&lt;p>用户级的互斥锁利用操作系统的互斥机制实现，同时要考虑防止和GIL形成死锁。所以过程与阻塞调度类似需要使用&lt;code>Py_BEGIN_ALLOW_THREADS&lt;/code>和&lt;code>Py_END_ALLOW_THREADS&lt;/code>这两个宏。&lt;/p>
&lt;ol>
&lt;li>线程a调用lock对象加锁，lock对象内部调用系统互斥机制，同时执行&lt;code>Py_BEGIN_ALLOW_THREADS&lt;/code>释放GIL防止死锁。&lt;/li>
&lt;li>线程b获得GIL，执行到某处释放锁，lock对象内部调用系统机制释放锁，同时底层调用了&lt;code>Py_END_ALLOW_THREADS&lt;/code>等待GIL。&lt;/li>
&lt;li>线程a被系统唤醒，获取GIL，一气呵成。&lt;/li>
&lt;/ol>
&lt;h2 id="子线程的销毁">子线程的销毁&lt;/h2>
&lt;blockquote>
&lt;p>在线程的全部计算完成之后，Python将销毁线程。需要注意的是，Python主线程的销毁与子线程的销毁是不同的，因为主线程的销毁动作必须要销毁Python的运行时环境，而子线程的销毁则不需要进行这些动作。&lt;/p>
&lt;/blockquote>
&lt;h2 id="内存管理">内存管理&lt;/h2>
&lt;p>大块内存管理直接调用C的malloc和free接口，小块内存分配则由python的内存池管理机制调度。&lt;/p>
&lt;h3 id="小块内存管理的对象">小块内存管理的对象&lt;/h3>
&lt;p>Python的内存块叫block，每个block大小不同，都是8的整数倍。管理block的叫pool，一个pool是4K。pool管理&lt;strong>相同大小&lt;/strong>的一堆block。pool对象的szindex变量保存了这个pool对应的block大小。&lt;/p>
&lt;blockquote>
&lt;p>，一个pool可能管理了100个32个字节的block，也可能管理了100个64个字节的block，但是绝不会有一个管理了50个32字节的block和50个64字节的block的pool存在&lt;/p>
&lt;/blockquote>
&lt;p>Python对于内存块的管理类似对象的策略，每次内存分配一整个block，回收时先将不用的Block加入闲置的队列里等待重新利用，不是直接回收。(惰性回收策略)&lt;/p>
&lt;p>管理多个pool的数据对象是arena。下图可见，pool结构是一次性分配好一块内存，而arena则是通过指针连向一块pool。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/2duvofnkP9LEO8x.jpg" alt="">&lt;/p>
&lt;p>而python维护一个名叫arenas的数组，数组元素就是arena对象。arena之间通过由两条链表相连。它们分别是：&lt;/p>
&lt;ul>
&lt;li>&lt;em>unused_arena_objects&lt;/em> 是单向量表，指向未分配pool的arena&lt;/li>
&lt;li>&lt;em>usable_arenas&lt;/em> 是双向链表，表示已经分配了pool的arena&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/duFq5I6lWACjQyw.jpg" alt="">&lt;/p>
&lt;blockquote>
&lt;p>当一个arena的area_object没有与pool集合建立联系时，这时的arena处于“未使用”状态；一旦建立了联系，这时arena就转换到了“可用”状态。对于每一种状态，都有一个arena的链表。“未使用”的arena的链表表头是unused_arena_objects、arena与arena之间通过nextarena连接，是一个单向链表；而“可用”的arena的链表表头是usable_arenas、arena与arena之间通过nextarena和prevarena连接，是一个双向链表。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>Pool是python管理内存的对象，arena虽然更上层，但是arena内的pool集合可能管理32字节的block，也可能管理64字节的block，所以arena无法决定销毁和分配内存。Python仍然以pool为单位管理内存开销。(pool有size概念，arena没有size概念)&lt;/strong>&lt;/p>
&lt;p>Pool有三种状态full、empty和used。其中full不需要连接起来，其他两种状态会被freepools和usedpools连接起来方便管理。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/mZr1P7ocQYbpCFB.jpg" alt="">&lt;/p>
&lt;h3 id="arena的分配">arena的分配&lt;/h3>
&lt;p>arena可以指向32位pool集合，也可以指向64位pool集合。分配内存的过程如下：&lt;/p>
&lt;ol>
&lt;li>先在usable_arenas链表上找可用的arena，然后找到符合要求的pool&lt;/li>
&lt;li>如果没有可用的arena，则从arenas数组里摘下来新的arena，放在usable_arenas里，然后初始化pool&lt;/li>
&lt;li>从usedpools链表里找可用的blocks&lt;/li>
&lt;li>usedpools没有可用的pool，就从freepools链表分配一个empty状态的pool&lt;/li>
&lt;/ol>
&lt;h3 id="python编译时指定内存上限">Python编译时指定内存上限&lt;/h3>
&lt;blockquote>
&lt;p>当Python在WITH_MEMORY_LIMITS编译符号打开的背景下进行编译时，Python内部的另一个符号会被激活，这个名为SMALL_MEMORY_LIMIT的符号限制了整个内存池的大小，同时，也就限制了可以创建的arena的个数。在默认情况下，不论是Win32平台，还是unix平台，这个编译符号都是没有打开的，所以通常Python都没有对小块内存的内存池的大小做任何的限制。&lt;/p>
&lt;/blockquote>
&lt;h3 id="小块内存管理的流程">小块内存管理的流程&lt;/h3>
&lt;p>&lt;em>(此部分摘自书中代码注释)&lt;/em>&lt;/p>
&lt;ol>
&lt;li>如果申请的内存小于SMALL_REQUEST_THRESHOLD，使用Python的小块内存的内存池。否则，转向malloc&lt;/li>
&lt;li>根据申请内存的大小获得对应的size class index&lt;/li>
&lt;li>如果usedpools中可用的pool，使用这个pool来分配block&lt;/li>
&lt;li>分配结束后，如果pool中的block都被分配了，将pool从usedpools中摘除&lt;/li>
&lt;li>如果usedpools中没有可用的pool，从usable_arenas中获取pool&lt;/li>
&lt;li>如果usable_arenas中没有就“可用”的arena，开始申请arena&lt;/li>
&lt;li>从usable_arenas的第一个arena中获取一个pool&lt;/li>
&lt;li>获取pool成功，进行init pool的动作，将pool放入used_pools中，并返回分配得到的block&lt;/li>
&lt;li>获取pool失败，对arena中的pool集合进行初始化，然后转入goto到init pool的动作处，初始化一个特定的pool&lt;/li>
&lt;/ol>
&lt;h3 id="python-25对多次分配小内存造成内存泄漏的处理">Python 2.5对多次分配小内存造成内存泄漏的处理&lt;/h3>
&lt;p>在2.5之前版本，Python的arena从来不释放pool。这就造成反复分配小内存后造成的arena太多而内存无法回收。&lt;/p>
&lt;p>2.5之后的处理办法：arena有两种状态，unused和usable。上文已经介绍过。&lt;/p>
&lt;ol>
&lt;li>如果arena中所有的pool都是empty的，释放pool集合占用的内存。arena变成unused状态，从usable_arenas剔除&lt;/li>
&lt;li>如果arena初始化了新的pool，arena变成usable状态，从usable_arenas链表中顺序查找位置插入该arena。注意，usable_arenas是有序链表(按照arena中pool的个数排序，pool多的arena排前边，pool少的排后边)&lt;/li>
&lt;li>这样，再有分配内存的请求时，先从usable_arenas表头顺序查，排在前边pool多的arena就被利用的充分，pool少的arena就更有可能变成unused状态，容易被释放掉。达到节省内存的目的&lt;/li>
&lt;/ol>
&lt;h3 id="内存池全景">内存池全景&lt;/h3>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/1Lh6u4awv8ZyQ9H.jpg" alt="">&lt;/p>
&lt;h2 id="python垃圾回收机制">Python垃圾回收机制&lt;/h2>
&lt;p>除了计数器，python还是使用了标记-清除，分代回收机制。&lt;/p>
&lt;h3 id="标记---清除">标记 - 清除&lt;/h3>
&lt;h4 id="三色模型">三色模型&lt;/h4>
&lt;p>根据系统内所有对象的引用情况建立有向图，沿着有向图从根开始的逐层染色，黑色代表该节点所有引用都检查过了，灰色表示节点是可达的，当所有灰色节点都变为黑色，检查结束。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/2a1kYDnyT4fBQxP.jpg" alt="">&lt;/p>
&lt;h3 id="python-中的标记清除">Python 中的标记清除&lt;/h3>
&lt;p>Python的对象由三大部分组成，PyGC_Head，PyObject_Head和本体。其中PyObject_Head里存计数器用来标记当前节点是否可回收，但是对于循环引用的情况，就需要PyGC_Head里的refs，python会根据一些触发条件进行三色模型的标记，某个对象的「可达次数」标记在PyGC_Head里，当这个可达次数为0时，代表对象不可达，也就需要回收之。PyGC_Head之间有一条双向链表连接了所有对象，将他们纳入内存回收管理系统里。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/UT5ry697VXINBQp.jpg" alt="">&lt;/p>
&lt;h4 id="流程">流程&lt;/h4>
&lt;ol>
&lt;li>在垃圾收集的第一步，就是遍历可收集对象链表，将每个对象的gc.gc_ref值设置为其ob_refcnt值。&lt;/li>
&lt;li>接下来的动作就是要将环引用从引用中摘除。&lt;/li>
&lt;li>有一些container对象的&lt;code>PyGC_Head.gc.gc_ref&lt;/code>还不为0，这就意味着存在对这些对象的外部引用，这些对象，就是开始标记 - 清除算法的root object集合。&lt;/li>
&lt;/ol>
&lt;h3 id="分代回收">分代回收&lt;/h3>
&lt;blockquote>
&lt;p>这种以空间换时间的总体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就称为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小，也就是说，活得越长的对象，就越可能不是垃圾，就应该越少去收集。&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/mQuPrwyD73ZjhBv.jpg" alt="">&lt;/p>
&lt;blockquote>
&lt;p>Python采用了三代的分代收集机制，如果当前收集的是第1代，那么在开始垃圾收集之前，Python会将比其“年轻”的所有代的内存链表（当然，在这里只有第0代）整个地链接到第1代内存链表之后，这个操作是通过gc_list_merge实现的。&lt;/p>
&lt;/blockquote>
&lt;h3 id="总结">总结&lt;/h3>
&lt;ol>
&lt;li>将比当前处理的“代”更年轻的“代”的链表合并到当前“代”中&lt;/li>
&lt;li>在待处理链表上进行打破循环的模拟，寻找root object&lt;/li>
&lt;li>将待处理链表中的unreachable object转移到unreachable链表中，处理完成后，当前“代”中只剩下reachable object了&lt;/li>
&lt;li>如果可能，将当前“代”中的reachable object合并到更老的“代”中&lt;/li>
&lt;li>对于unreachable链表中的对象，如果其带有&lt;code>__del__&lt;/code>函数，则不能安全回收，需要将这些对象收集到finalizers链表中，因此，这些对象引用的对象也不能回收,也需要放入finalizers链表中&lt;/li>
&lt;li>处理弱引用（weakref），如果可能，调用弱引用中注册的callback操作&lt;/li>
&lt;li>对unreachable链表上的对象进行垃圾回收操作&lt;/li>
&lt;li>将含有&lt;code>__del__&lt;/code>操作的实例对象收集到Python内部维护的名为garbage的链表中，同时将finalizers链表中所有对象加入old链表中&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>注意，如果对象拥有&lt;code>__del__&lt;/code>方法，就不能通过垃圾回收来自动回收&lt;/strong>，所以要慎重使用这个方法。&lt;/p></description></item><item><title>《Python源码剖析》第二部分——Python虚拟机基础</title><link>https://sund.site/posts/python-2/</link><pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate><guid>https://sund.site/posts/python-2/</guid><description>&lt;h2 id="python执行环境">Python执行环境&lt;/h2>
&lt;blockquote>
&lt;p>在编译过程中，这些包含在Python源代码中的静态信息都会被Python编译器收集起来，编译的结果中包含了字符串，常量值，字节码等在源代码中出现的一切有用的静态信息。在Python运行期间，这些源文件中提供的静态信息最终会被存储在一个运行时的对象中，当Python运行结束后，这个运行时对象中所包含的信息甚至还会被存储在一种文件中。这个对象和文件就是我们这章探索的重点：PyCodeObject对象和pyc文件。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在程序运行期间，编译结果存在于内存的PyCodeObject对象中；而Python结束运行后，编译结果又被保存到了pyc文件中。当下一次运行相同的程序时，Python会根据pyc文件中记录的编译结果直接建立内存中的PyCodeObject对象，而不用再次对源文件进行编译了。&lt;/p>
&lt;/blockquote>
&lt;p>从文章摘录可见，python生成的不是编译后的文件，而是&lt;code>.py&lt;/code>文件对应的静态信息——PyCodeObject，这里包括了字节码指令序列、字符串、常量。每个名字空间(类、模块、函数)都对应一个独立的PyCodeObject。(python连编译后的文件里存的都是个对象！)&lt;/p>
&lt;p>不被import的py文件不会生成pyc。标准库里有py_compile等方法也可以生成pyc。&lt;/p>
&lt;p>&lt;strong>import机制&lt;/strong> 导入某个模块时，先查找对应的pyc，如果没有pyc就生成然后import这个pyc。(所以实际导入的并不是py文件，而是py文件编译后的PyCodeObject)。&lt;/p>
&lt;p>&lt;strong>PyFrameObject&lt;/strong> Python程序运行时的「执行环境」。参考操作系统执行可执行文件的过程。Python也是将函数对应的执行环境封装成栈帧的形式加载进内存。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">_frame&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">PyObject_VAR_HEAD&lt;/span>
&lt;span class="k">struct&lt;/span> &lt;span class="n">_frame&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">f_back&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//执行环境链上的前一个frame
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">PyCodeObject&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">f_code&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//PyCodeObject对象
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">PyObject&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">f_builtins&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//builtin名字空间
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">PyObject&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">f_globals&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//global名字空间
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">PyObject&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">f_locals&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//local名字空间
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">PyObject&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">f_valuestack&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//运行时栈的栈底位置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">PyObject&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">f_stacktop&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//运行时栈的栈顶位置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">……&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">f_lasti&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//上一条字节码指令在f_code中的偏移位置
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">f_lineno&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="c1">//当前字节码对应的源代码行
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="err">……&lt;/span>
&lt;span class="c1">//动态内存，维护（局部变量+cell对象集合+free对象集合+运行时栈）所需要的空间
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">PyObject&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">f_localsplus&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">PyFrameObject&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Python标准库的&lt;code>sys._getframe()&lt;/code>可以动态的在程序执行时获取当前内存中活跃的PyFrameObject信息。&lt;/p>
&lt;h2 id="legb-规则">LEGB 规则&lt;/h2>
&lt;p>即python作用域的查找顺序是&lt;code>local&lt;/code>-&lt;code>enclosing&lt;/code>-&lt;code>global&lt;/code>-&lt;code>buildin&lt;/code>。看下面代码：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">g&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="k">print&lt;/span> &lt;span class="n">a&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="k">print&lt;/span> &lt;span class="n">a&lt;/span> &lt;span class="o">//&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span> &lt;span class="o">//&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="k">print&lt;/span> &lt;span class="n">a&lt;/span>
&lt;span class="n">g&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码在[1]处会抛出异常，原因是python在编译阶段就把静态数据(局部变量、全局变量、字节码)放入pyc里，执行到&lt;code>f()&lt;/code>里时，查找到&lt;code>a&lt;/code>是在local作用域里定义的而不是global里，但是此时local的a还没赋值，所以就会抛出异常。由此可见，&lt;strong>python作用域信息是在静态编译时就处理好了的&lt;/strong>。&lt;/p>
&lt;h2 id="python-虚拟机运行框架">Python 虚拟机运行框架&lt;/h2>
&lt;blockquote>
&lt;p>运行时环境是一个全局的概念，而执行环境实际就是一个栈帧，是一个与某个Code Block对应的概念。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>在PyCodeObject对象的co_code域中保存着字节码指令和字节码指令的参数，Python虚拟机执行字节码指令序列的过程就是从头到尾遍历整个co_code、依次执行字节码指令的过程。&lt;/p>
&lt;/blockquote>
&lt;p>由上文引用可见，python在编译阶段将代码块的字节码保存在PyCodeObject的co_code属性里，然后在执行阶段从头到尾遍历这个co_code属性解读字节码。&lt;/p>
&lt;p>&lt;strong>Python运行时环境&lt;/strong> Python在运行时用PyInterpreterState结构维护进程运行环境，PyThreadState维护线程运行环境，PyFrameObject维护栈帧运行环境，三者是依次包含关系，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/GHImB214fvxSXgk.png" alt="">&lt;/p>
&lt;p>Python虚拟机就是一个「软CPU」，动态加载上述三种结构进内存，并模拟操作系统执行过程。程序执行后，先创建各个运行时环境，再将栈帧中的字节码载入，循环遍历解释执行。&lt;/p>
&lt;h2 id="python字节码">Python字节码&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="mi">0&lt;/span> &lt;span class="n">LOAD_CONST&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">3&lt;/span> &lt;span class="n">STORE_NAME&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>例如python的一条语句&lt;code>i=1&lt;/code>可以解释为下面两行字节码，最左边的第1列数字代表这行字节码在内存中的偏移位置，第2列是字节码的名字(CPU并不关心名字，它只是根据偏移量读出字节码，所以这个名字是方便阅读用的)，第3列是字节码的参数，如&lt;code>LOAD_CONST&lt;/code>对应的数据在变量&lt;code>f-&amp;gt;f_code-&amp;gt;co_consts&lt;/code>里，0就是这个参数位于&lt;code>f-&amp;gt;f_code-&amp;gt;co_consts&lt;/code>的偏移量。最后一列的括号里是从参数里取到的value。&lt;/p>
&lt;h2 id="python-的异常抛出机制">Python 的异常抛出机制&lt;/h2>
&lt;p>异常处理的操作都在&lt;code>Python/traceback.c&lt;/code>文件里，python每次调用一层函数，就创建改函数对应的PyFrameObject对象来保存函数运行时信息，PythonFrameObject里调用PyEval_EvalFrameEx循环解释字节码，如果抛出异常就创建PyTraceBackObject对象，将对象交给上一层PyFrameObject里的PyTracebackObject组成链表，最后返回最上层PyRun_SimpleFileExFlags函数，该函数调用PyErr_Print遍历PyTraceBackObject链表打印出异常信息。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/9bEUBjYov8mZy3s.jpg" alt="">&lt;/p>
&lt;h2 id="函数对象的实现">函数对象的实现&lt;/h2>
&lt;p>PyFunctionObject是函数对象。在python调用函数时，生成PyFunctionObject对象，该对象的f_global指针用来将外层的全局变量传递给函数内部，然后在&lt;code>ceval.c&lt;/code>文件的&lt;code>fast_function&lt;/code>里解出PyFunctionObject对象里携带的信息，创建新的PyFrameObject对象(上文说过这个对象是维护运行时环境的)，最后调用执行字节码的函数&lt;code>PyEval_EvalFrameEx&lt;/code>执行真正函数字节码。&lt;/p>
&lt;p>&lt;strong>Python执行一段代码需要什么？&lt;/strong> 从书中描述可见，python执行一段代码需要做几件事：&lt;/p>
&lt;ul>
&lt;li>从源码编译出 PyCodeObject 保存变量和字节码&lt;/li>
&lt;li>执行阶段，从PyCodeObject里取出信息交给 PyFrameObject，执行 PyEval_EvalFrameEx 解释字节码&lt;/li>
&lt;li>如果遇到函数调用，就把函数对应的代码段从 PyCodeObject 存入 PyFunctionObject 对象，然后把这个函数对象通过参数传给新创建的 PyFrameObject ，在内层空间执行 PyEval_EvalFrameEx 解释字节码&lt;/li>
&lt;li>将结果或异常存入 PyFrameObject 的变量( 异常是存入f_blockstack里，外层判断f_blockstack里的数据是被except捕获还是没有捕获而继续下一步操作) 抛给外层&lt;/li>
&lt;/ul>
&lt;p>值得注意的是，&lt;strong>python在执行阶段，将对函数参数的键值查找，转换为索引查找&lt;/strong>，即在转换PyCodeObject为PyFrameObject时，将参数信息按位置参数、键参数按照一定顺序存储在f_localsplus变量中，再用索引来查找对应参数，而需要查找键值。这样提高了运行时效率。下图是&lt;code>foo('Rboert', age=5)&lt;/code>在内存中的存储形式。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/IGy8JTzZpgmN6sL.jpg" alt="">&lt;/p>
&lt;h2 id="闭包的实现">闭包的实现&lt;/h2>
&lt;p>Python在编译阶段就把函数闭包内层和闭包外层使用的变量存入PyCodeObject中：&lt;/p>
&lt;ul>
&lt;li>co_cellvars：通常是一个tuple，保存嵌套的作用域中使用的变量名集合；&lt;/li>
&lt;li>co_freevars：通常也是一个tuple，保存使用了的外层作用域中的变量名集合。&lt;/li>
&lt;/ul>
&lt;p>在执行阶段，PyFrameObject的f_localsplus中也为闭包的变量划分的内存区域，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/fUB4wC36dAc7rqt.jpg" alt="">&lt;/p>
&lt;h2 id="元类">元类&lt;/h2>
&lt;p>元类&lt;code>&amp;lt;type type&amp;gt;&lt;/code>和其他类的关系如下图：&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/N76woqSlmR28Oyt.jpg" alt="">&lt;/p>
&lt;p>&lt;strong>可调用性（callable）&lt;/strong> ，只要一个对象对应的class对象中实现了“&lt;strong>call&lt;/strong>”操作（更确切地说，在Python内部的PyTypeObject中，tp_call不为空）那么这个对象就是一个可调用的对象，换句话说，在Python中，所谓“调用”，就是执行对象的type所对应的class对象的tp_call操作。&lt;/p>
&lt;h2 id="descriptor">Descriptor&lt;/h2>
&lt;blockquote>
&lt;p>在PyType_Ready中，Python虚拟机会填充tp_dict，其中与操作名对应的是一个个descriptor
对于一个Python中的对象obj，如果obj.__ class__对应的class对象中存在__get__、__set__和__delete__三种操作，那么obj就可称为Python一个descriptor。&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>如果细分，那么descriptor还可分为如下两种：&lt;/p>
&lt;/blockquote>
&lt;ol>
&lt;li>data descriptor : type中定义了__get__和__set__的descriptor；&lt;/li>
&lt;li>non data descriptor : type中只定义了__get__的descriptor。
在Python虚拟机访问instance对象的属性时，descriptor的一个作用是影响Python虚拟机对属性的选择。从PyObject_GenericGetAttr的伪代码可以看出，Python虚拟机会在instance对象自身的__dict__中寻找属性，也会在instance对象对应的class对象的mro列表中寻找&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;ol>
&lt;li>Python虚拟机按照instance属性、class属性的顺序选择属性，即instance属性优先于class属性；&lt;/li>
&lt;li>如果在class属性中发现同名的data descriptor，那么该descriptor会优先于instance属性被Python虚拟机选择&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/1xKk3IVPdjWb8iB.jpg" alt="">&lt;/p>
&lt;h3 id="引申python-黑魔法-descriptor-描述器">引申：Python 黑魔法 Descriptor (描述器)&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="http://www.jianshu.com/p/250f0d305c35">http://www.jianshu.com/p/250f0d305c35&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html">http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="bound-method和unbound-method">Bound Method和Unbound Method&lt;/h2>
&lt;p>假设有下面两种对类方法的调用：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">A&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">object&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">pass&lt;/span>
&lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">A&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="c1"># [1]&lt;/span>
&lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="c1"># [2]&lt;/span>
&lt;span class="n">A&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># [3]&lt;/span>
&lt;span class="n">func&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>
&lt;span class="n">func&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在代码[1]里，实例a调用类方法f，python底层会自动完成实例a和类方法f之间的绑定动作(调用&lt;code>func_ descr_get(A.f, a, A)&lt;/code>，将实例地址和函数对象PyFunctionObject封装到一个PyMethodObject)，而代码[2]里直接通过A调用，则f为非绑定的PyMethodObject，里面没有实例信息，需要传入a。&lt;/p>
&lt;p>比较绑定方法与非绑定方法可知，通过[1]的方式每次都要绑定一次实例，开销非常大，下图比较的是[1]和[3]两种方式，绑定操作的执行次数。&lt;/p>
&lt;p>&lt;img src="https://i.loli.net/2021/03/05/TpCcdaYmHlQnXzE.jpg" alt="">&lt;/p>
&lt;p>结论： &lt;strong>调用类实例绑定的方法时，如果方法执行次数非常多，最好将方法赋值给一个变量，防止重复绑定增加开销&lt;/strong>&lt;/p></description></item><item><title>《Python源码剖析》第一部分——Python对象基础</title><link>https://sund.site/posts/python/</link><pubDate>Wed, 12 Jul 2017 00:00:00 +0000</pubDate><guid>https://sund.site/posts/python/</guid><description>&lt;h2 id="python的对象初始化">Python的对象初始化&lt;/h2>
&lt;blockquote>
&lt;p>在Python中，对象就是为C中的结构体在堆上申请的一块内存，一般来说，对象是不能被静态初始化的，并且也不能在栈空间上生存。唯一的例外就是类型对象，Python中所有的内建的类型对象（如整数类型对象，字符串类型对象）都是被静态初始化的。&lt;/p>
&lt;/blockquote>
&lt;p>python 的对象不像 C 是分配在栈、堆、data segment等位置，而是全部分配在堆上！只有python内置类型在初始化时候才是被C语言层静态初始化。&lt;/p>
&lt;p>PyObject内部就两样：引用计数器、类型对象指针。&lt;/p>
&lt;p>类型对象的定义：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="n">_typeobject&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">PyObject_VAR_HEAD&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">tp_name&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* For printing, in format &amp;#34;&amp;lt;module&amp;gt;.&amp;lt;name&amp;gt;&amp;#34; */&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">tp_basicsize&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tp_itemsize&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="cm">/* For allocation */&lt;/span>
&lt;span class="cm">/* Methods to implement standard operations */&lt;/span>
&lt;span class="n">destructor&lt;/span> &lt;span class="n">tp_dealloc&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">printfunc&lt;/span> &lt;span class="n">tp_print&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="err">……&lt;/span>
&lt;span class="cm">/* More standard operations (here for binary compatibility) */&lt;/span>
&lt;span class="n">hashfunc&lt;/span> &lt;span class="n">tp_hash&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">ternaryfunc&lt;/span> &lt;span class="n">tp_call&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="err">……&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">PyTypeObject&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>PyObject_VAR_HEAD&lt;/code>是可变类型的头信息，其中除了&lt;code>PyObject_HEAD&lt;/code>的内容外，额外添加了一个代表该对象元素数量的整型。从上边代码可见，python的类型也是一个可变对象。&lt;/p>
&lt;h2 id="python的多态">Python的多态&lt;/h2>
&lt;p>Python中所有类型在初始化后，在C语言层面都使用同一种指针&lt;code>PyObject *&lt;/code>，所以python实现多态就非常容易。任何函数的参数都是一个PyObject类型指针，也就不存在编译器需要判断函数参数类型。&lt;/p>
&lt;h2 id="python对象内存池">Python对象内存池&lt;/h2>
&lt;p>Python为了避免频繁的释放对象，采用了内存池的机制，在对象引用计数为0时，不会释放内存，而是将内存交还给内存池供python重新分配使用。&lt;strong>每一种python类型，都有特定的内存池机制。&lt;/strong>&lt;/p>
&lt;h2 id="整数对象">整数对象&lt;/h2>
&lt;p>-5至257之间的小整数，存储在「小整数数组」里，这个数组Python自动创建，每次创建一个小整数，就指向这个数组里对应的PyIntObject值并把PyIntObject的计数加1。(因此在-5到257之间的数实际指向同一片内存空间，整数-5和-5的内存地址肯定是一样的)&lt;/p>
&lt;p>大整数则由一个叫&lt;code>block_list&lt;/code>的链表管理，每次分配一个大整数就在&lt;code>free_list&lt;/code>(一个指向空闲内存block的指针)里拿出一个节点并把&lt;code>free_list&lt;/code>后移一个&lt;code>block&lt;/code>。关于&lt;code>free_list&lt;/code>是如何把尚未分配的内存和已被释放的内存链接起来的，可以参见书中113页的插图理解。&lt;/p>
&lt;p>值得注意的是，python用于分配给整型的堆内存是不会自行销毁的，而是不断复用。也就是说，&lt;strong>同一时间如果同时使用的整型太多，会消耗大量内存，并且这些内存在python关闭之前一直被python持有着。&lt;/strong>&lt;/p>
&lt;h2 id="字符串对象">字符串对象&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">typedef&lt;/span> &lt;span class="k">struct&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">PyObject_VAR_HEAD&lt;/span>
&lt;span class="kt">long&lt;/span> &lt;span class="n">ob_shash&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">ob_sstate&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kt">char&lt;/span> &lt;span class="n">ob_sval&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="n">PyStringObject&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在Python源码中的注释显示，预存字符串的hash值(为了节省字符串比较的时间)和这里的intern机制将Python虚拟机的执行效率提升了20%。&lt;/p>
&lt;p>&lt;strong>intern机制&lt;/strong> 将新建的字符串缓存在一个PyDictObject里，相同的字符串共用同一内存。&lt;/p>
&lt;p>单一字符的字符串，除了用intern缓存外，还会缓存在系统自带的一个字符串缓冲池里：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="k">static&lt;/span> &lt;span class="n">PyStringObject&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">characters&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">UCHAR_MAX&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">];&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>&lt;code>+&lt;/code>操作符和&lt;code>join&lt;/code>的效率问题&lt;/strong> &lt;code>+&lt;/code>连接n个操作符会创建n-1次临时空间，&lt;code>join&lt;/code>会直接处理一个list里的字符串，只分配一次内存。节省开销。&lt;/p>
&lt;h2 id="列表对象">列表对象&lt;/h2>
&lt;p>参见C++ vector对象的存储方式。&lt;/p>
&lt;h2 id="字典对象">字典对象&lt;/h2>
&lt;p>Python使用散列表(时间复杂度O(1))而非红黑树(时间复杂度O(logN))来存储map结构。&lt;/p>
&lt;p>**Hash冲突(碰撞)**不同的值映射到相同的键时，就产生了冲突。一般解决办法有：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>开链法(哈希桶)：
&lt;img src="https://i.loli.net/2021/03/05/bQuAwlOTUIXkJ7x.gif" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开放定址法：
hash一次没有命中就再hash一次，直到找到为止……(二次探测)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>小于8个元素的Dict，python使用PyDIctObject内部的smalltable数组保存元素内容。&lt;/p>
&lt;p>PyDictObject对String类型的key做了特殊对待——简化了计算hash函数的过程(正常情况下key值是一个&lt;code>PyObject *&lt;/code>对象，需要做大量类型判断，但是对PyStringObject就省了)。&lt;/p>
&lt;p>**装载率(使用的空间/预先分配的空间)**大于2/3时，hash冲突的概率会急速升高，这时python就会动态分配更多的空间。与其他类型一样，如果装载率太小，也会自动缩减分配的空间。&lt;/p>
&lt;blockquote>
&lt;p>在确定新的table的大小时，通常选用的策略是时新的table中entry的数量是现在table中Active态entry数量的4倍，选用4倍是为了使table中处于Active态的entry的分布更加稀疏，减少插入元素时的冲突概率……所以当table中Active态的entry数量非常大时，Python只会要求2倍的空间，这次又是以执行速度来交换内存空间。&lt;/p>
&lt;/blockquote>
&lt;p>注意这段话，执行速度和内存大小是反比关系，划分的空间越大，执行一次查找就越费时，所以分配的内存空间不是越大越好。&lt;/p>
&lt;p>PyDictObject也使用了同PyListObject一样的缓冲池方式。参考列表对象部分内容。&lt;/p>
&lt;p>&lt;em>&lt;strong>笔者总结：从上面的各种类型的处理规律可以总结出Python遵循的原则：小变量缓存，大变量尽量整块分配内存，回收变量时不释放内存而是尽量复用，预分配的空间既要满足需要又不能太大(太大就缩减)&lt;/strong>&lt;/em>&lt;/p></description></item><item><title>一些投资知识</title><link>https://sund.site/posts/investment/</link><pubDate>Thu, 19 Jan 2017 13:25:55 +0800</pubDate><guid>https://sund.site/posts/investment/</guid><description>&lt;h2 id="资产配置">资产配置&lt;/h2>
&lt;p>债、股、基金等综合配置。基金有的偏股，有的偏债，有的偏另类。看清楚哪些基金适合自己。&lt;/p>
&lt;p>每种理财产品、基金都是有一些底层资产构成。&lt;/p>
&lt;h3 id="什么是底层资产">什么是底层资产&lt;/h3>
&lt;ul>
&lt;li>债类资产(固定收益资产)&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>这类资产风险取决于平台投资的内容，债务主体(国家、公司、个人)。风险最低。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>股类资产(高风险、高收益)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>另类资产(最高风险、最高收益)&lt;/p>
&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>如房地产、农产品、黄金、原油、文玩收藏、比特币等。&lt;/p>
&lt;/blockquote>
&lt;h3 id="理财风险等级">理财风险等级&lt;/h3>
&lt;p>银行理财的风险级别分成1-5级，在合同里会标识出来，比如R1-R5，谨慎型产品(R1)、稳健型产品(R2)、平衡型产品(R3)、进取型产品(R4)、激进型产品(R5)。&lt;/p>
&lt;p>一般R1-R2是可以认为比较稳健、基本不会亏本的，R5就比较危险了。&lt;/p>
&lt;h3 id="固定收益类资产低风险">固定收益类资产(低风险)&lt;/h3>
&lt;ul>
&lt;li>国债(3%左右)&lt;/li>
&lt;li>银行定期存款(小城乡银行利息高，国家有50万以内存款的保险)&lt;/li>
&lt;li>网络银行存款(微众银行，五年期定存年化5%)&lt;/li>
&lt;li>银行理财(保本类3-5%，非保本类高一点点)&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>结构性理财比非结构性理财高些。(既然买银行理财就是图安全，所以要买保本或风险低的。
&lt;a href="http://www.chinawealth.com.cn/zzlc/index.shtml">中国理财网&lt;/a>可以查看风险和收益，是权威的半官方类网站。银行T+0产品随时可以到帐，适合大量临时性资金的理财)&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>保险理财。虽然名字叫保险，但是本身没有保障功能，是保险公司包装出来的理财产品。&lt;/li>
&lt;li>信托、券商资产管理计划&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;ul>
&lt;li>信托。信托的本质也是债券。信托产品底层就是债券。信托公司包装后卖给你。所以评估风险标准仍然是信托公司本身的实力。如中信信托、平安信托比较强大，本身风险较低。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;blockquote>
&lt;ul>
&lt;li>券商的资产管理计划。100万起，风险和收益都比信托高。本质上是企业债券。但是借款规模大，企业运营不景气时风险高。&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;ul>
&lt;li>P2P。现在买要比之前风险低，推荐资产是小资产(如个人消费、小买卖等)。P2P在理财中占比不要超过20%比较好。知名度比较高的平台：陆金所、人人贷、有利网、小赢、桔子理财、积木盒子等等。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>财经信息来源：财联社，财新网
读研报推荐迈博汇金。又叫慧博投研资讯。网址是http://www.microbell.com/newweb/web/search?index=0&lt;/p>
&lt;/blockquote>
&lt;h3 id="浮动收益类资产">浮动收益类资产&lt;/h3>
&lt;p>&lt;strong>基金&lt;/strong>&lt;/p>
&lt;p>&lt;em>理财工具&lt;/em>&lt;/p>
&lt;ul>
&lt;li>蚂蚁聚宝&lt;/li>
&lt;li>&lt;a href="http://fund.chinastock.com.cn/jjpj/">基金评价报表&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>&lt;em>分类&lt;/em>&lt;/p>
&lt;ul>
&lt;li>货币基金。风险最低，如余额宝就是。收益很低，流动性强。&lt;/li>
&lt;li>债券基金。风险较低。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>债基按风险分为：&lt;/p>
&lt;ul>
&lt;li>一级债基。风险低，纯买债券。&lt;/li>
&lt;li>二级债基。80%买债券，20%买股票。(推荐定投，进可攻退可守)&lt;/li>
&lt;li>混合偏债基金。&lt;/li>
&lt;li>可转债基金。&lt;/li>
&lt;/ul>
&lt;p>买债基适合选择成立时间长，收益稳定的。
年底或资金紧张时，金融机构赎回债券，会导致债基市场低迷。从长期(10年)看，债基仍然保持上升趋势。&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>股票基金。&lt;/li>
&lt;li>另类基金。挂钩房地产、黄金等。&lt;/li>
&lt;/ul>
&lt;p>封闭式基金平时不可以购买，会在特定时段开放购买，需要常查看基金公告。&lt;/p>
&lt;p>&lt;strong>股票&lt;/strong>&lt;/p>
&lt;p>理财工具：雪球、华泰证券、巨潮咨询(看企业年报等)、迈博汇金&lt;/p>
&lt;p>Wind 金融数据。&lt;/p>
&lt;blockquote>
&lt;p>炒股的原则：花一段时间选定一些熟悉标的公司，特定去研究它。不要听消息或听股神建议炒股。&lt;/p>
&lt;/blockquote>
&lt;h3 id="房地产">房地产&lt;/h3>
&lt;p>投资房产的标准是看城市法制程度(办事是否需要找关系)，年轻人就业率。&lt;/p>
&lt;h3 id="理财规划工具">理财规划工具&lt;/h3>
&lt;p>好规划网、七分钟理财。&lt;/p>
&lt;p>资产盘点：财余管家&lt;/p>
&lt;h3 id="关于定投">关于定投&lt;/h3>
&lt;p>定投可以磨平金融市场波动造成的影响，适合投资长期稳定上升的资产。3年内持续下跌的资产不适合定投。&lt;/p></description></item><item><title>Python2 中字符类型的一些坑</title><link>https://sund.site/posts/py-str/</link><pubDate>Wed, 11 Jan 2017 11:09:00 +0000</pubDate><guid>https://sund.site/posts/py-str/</guid><description>&lt;h2 id="问题">问题&lt;/h2>
&lt;p>有一道面试题是这样的：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;China&amp;#39;&lt;/span>
&lt;span class="n">b&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;China&amp;#39;&lt;/span>
&lt;span class="n">c&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="sa">u&lt;/span>&lt;span class="s1">&amp;#39;中国&amp;#39;&lt;/span>
&lt;span class="n">d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s1">&amp;#39;中国&amp;#39;&lt;/span>
&lt;span class="c1"># 1&lt;/span>
&lt;span class="k">print&lt;/span> &lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="si">%s&lt;/span>&lt;span class="s1"> &lt;/span>&lt;span class="si">%s&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">b&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># 2&lt;/span>
&lt;span class="k">print&lt;/span> &lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="si">%s&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">c&lt;/span>
&lt;span class="c1"># 3&lt;/span>
&lt;span class="k">print&lt;/span> &lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="si">%s&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="n">d&lt;/span>
&lt;span class="c1"># 4&lt;/span>
&lt;span class="k">print&lt;/span> &lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="si">%s&lt;/span>&lt;span class="s1"> &lt;/span>&lt;span class="si">%s&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>判断打印后的效果。&lt;/p>
&lt;p>先说正确答案，只有最后一行会报错。&lt;/p>
&lt;h2 id="分析">分析&lt;/h2>
&lt;p>在Python2里，默认的字符类型是&lt;code>str&lt;/code>，这个&lt;code>str&lt;/code>和Python3的&lt;code>str&lt;/code>完全不同，Python2的&lt;code>str&lt;/code>类型是8位的ascii序列。Python2在处理&lt;code>str&lt;/code>类型转换时遵循这样的规则：&lt;strong>如果被处理的&lt;code>str&lt;/code>型变量值小于7位，就可以和&lt;code>unicode&lt;/code>类型混用。可以做&lt;code>+&lt;/code>连接，格式化等操作，同unicode享受同样的待遇。&lt;/strong>&lt;/p>
&lt;p>Python2在格式化字符时，会把&lt;code>str&lt;/code>格式化为&lt;code>str&lt;/code>，如果字符串里混入了&lt;code>unicode&lt;/code>，就会把其他字符都转化为&lt;code>unicode&lt;/code>。所以这道题里1处的a，b两个值混合后的字符就是一个unicode字符串，c和d单独格式化后仍保留了自己的格式。但是Python2在格式化代码位置4时，发现c是unicode而d不是，就会尝试按照上面的混用规则，格式化d为unicode类型，但是d的值&lt;code>'中国'&lt;/code>显然是一个大于7位的&lt;code>str&lt;/code>，因此Python2抛出UnicodeDecodeError。&lt;/p>
&lt;p>在Python3里，&lt;code>str&lt;/code>类型则变成了一个纯unicode字符，也就是说Python3里的&lt;code>str&lt;/code>等价于Python2里的&lt;code>unicode&lt;/code>类型。Python3里为了清晰明了，使用&lt;code>bytes&lt;/code>代表8位ascii序列。除此之外，Python3严格禁止混用两种类型。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;ul>
&lt;li>使用Python2处理字符串，尤其是中文字符串，最好前边加上u&lt;/li>
&lt;li>Python2里不要混用&lt;code>str&lt;/code>和&lt;code>unicode&lt;/code>，如果处理文本时，先将全部数据格式化成unicode&lt;/li>
&lt;li>能用Python3尽量不用Python2 &lt;del>(废话)&lt;/del>&lt;/li>
&lt;/ul>
&lt;h2 id="参考资料">参考资料：&lt;/h2>
&lt;ul>
&lt;li>《Effective Python》 Brett Slatkin.&lt;/li>
&lt;li>不愿意透露姓名的某厂面试官&lt;/li>
&lt;/ul></description></item><item><title>Python yield关键字的底层实现</title><link>https://sund.site/posts/py-yield/</link><pubDate>Wed, 28 Dec 2016 18:00:00 +0000</pubDate><guid>https://sund.site/posts/py-yield/</guid><description>&lt;p>这几天面试被问到类似的问题，顺便看了看Python的源码，参考网上的教程，总结一下yield关键字在C层面是如何实现的。&lt;/p>
&lt;h2 id="举个栗子">举个栗子&lt;/h2>
&lt;p>我们先看一个python生成器函数的例子：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">dis&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">dis&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">func&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="n">i&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;span class="k">yield&lt;/span> &lt;span class="n">i&lt;/span>
&lt;span class="k">print&lt;/span> &lt;span class="n">i&lt;/span>
&lt;span class="n">dis&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">a&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="n">func&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">a&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">next&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用python的库dis可以直接查看python虚拟机运行的字节码。&lt;code>dis(func)&lt;/code>的打印如下：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-fallback" data-lang="fallback"> 6 0 LOAD_CONST 1 (4)
3 STORE_FAST 0 (i)
7 6 LOAD_FAST 0 (i)
9 YIELD_VALUE
10 POP_TOP
8 11 LOAD_FAST 0 (i)
14 PRINT_ITEM
15 PRINT_NEWLINE
16 LOAD_CONST 0 (None)
19 RETURN_VALUE
&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们猜测其中第二列(代表字节码偏移量)为9的指令&lt;code>YIELD_VALUE&lt;/code>就是yield关键字的执行代码，进入Python2.7.12源码目录，在解释器执行字节码的主函数&lt;code>PyEval_EvalFrameEx&lt;/code>中找到了下面一段：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c"> &lt;span class="n">TARGET_NOARG&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">YIELD_VALUE&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="n">retval&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">POP&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_stacktop&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">stack_pointer&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="n">why&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">WHY_YIELD&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="c1">// 跳转到fast_yield处。fast_yield里处理了一下状态位然后返回结果
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">goto&lt;/span> &lt;span class="n">fast_yield&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>TARGET_NOARG&lt;/code>为封装了&lt;code>case&lt;/code>语句的宏，这句话的意思是，如果字节码是&lt;code>YIELD_VALUE&lt;/code>，就把栈顶元素赋值给&lt;code>retval&lt;/code>，然后跳转到&lt;code>fast_yield&lt;/code>处，&lt;code>fast_yield&lt;/code>处代码进行了一些状态判断后直接返回了&lt;code>retval&lt;/code>。&lt;/p>
&lt;h2 id="生成器是如何记录代码返回位置的">生成器是如何记录代码返回位置的&lt;/h2>
&lt;p>显然，如果这时候调用代码&lt;code>a.next()&lt;/code>就会直接返回yield后边的表达式结果。这对应了上面C代码的&lt;code>fast_yield&lt;/code>部分，那生成器怎么记录上次执行的位置并在下一次调用&lt;code>a.next()&lt;/code>的时候从上次的位置继续执行的呢？&lt;/p>
&lt;p>Python在解释代码时，是将代码块加载为一个叫PyFrameObject的对象，这个对象代表了当前运行的栈帧。PyFrameObject里有个&lt;code>f_lasti&lt;/code>变量用于保存代码当前执行到了字节码的哪个位置。在第二次执行&lt;code>a.next()&lt;/code>时，生成器对象把之前携带了&lt;code>f_lasti&lt;/code>的PyFrameObject当参数传给&lt;code>PyEval_EvalFrameEx&lt;/code>，在&lt;code>PyEval_EvalFrameEx&lt;/code>里的执行一个JUMPTO就直接跳转到了上一次结束生成器时的字节码位置：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">PyObject&lt;/span> &lt;span class="o">*&lt;/span>
&lt;span class="nf">PyEval_EvalFrameEx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">PyFrameObject&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="n">throwflag&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="cp">#define FAST_DISPATCH() \
&lt;/span>&lt;span class="cp"> { \
&lt;/span>&lt;span class="cp"> if (!lltrace &amp;amp;&amp;amp; !_Py_TracingPossible) { \
&lt;/span>&lt;span class="cp"> f-&amp;gt;f_lasti = INSTR_OFFSET(); \
&lt;/span>&lt;span class="cp"> goto *opcode_targets[*next_instr++]; \
&lt;/span>&lt;span class="cp"> } \
&lt;/span>&lt;span class="cp"> &lt;/span>&lt;span class="c1">// 跳转到fast_next_opcode处
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">goto&lt;/span> &lt;span class="n">fast_next_opcode&lt;/span>&lt;span class="p">;&lt;/span> \
&lt;span class="p">}&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="nl">fast_next_opcode&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_lasti&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">INSTR_OFFSET&lt;/span>&lt;span class="p">();&lt;/span>
&lt;span class="cm">/* line-by-line tracing support */&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">_Py_TracingPossible&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span>
&lt;span class="n">tstate&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">c_tracefunc&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nb">NULL&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="o">!&lt;/span>&lt;span class="n">tstate&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">tracing&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="p">...&lt;/span>
&lt;span class="cm">/* Reload possibly changed frame fields */&lt;/span>
&lt;span class="c1">// 按照f-&amp;gt;f_lasti中的偏移量跳转字节码
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">JUMPTO&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_lasti&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>INSTR_OFFSET&lt;/code>宏正是字节码的偏移量。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="cp">#define INSTR_OFFSET() ((int)(next_instr - first_instr))
&lt;/span>&lt;span class="cp">&lt;/span>
&lt;span class="c1">// co-&amp;gt;co_code里保存的是字节码
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="n">first_instr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="kt">unsigned&lt;/span> &lt;span class="kt">char&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="n">PyString_AS_STRING&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">co&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">co_code&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="n">next_instr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">first_instr&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="o">-&amp;gt;&lt;/span>&lt;span class="n">f_lasti&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以生成器对象每次执行结束都把字节码的偏移量记录下来，并把运行状态保存在PyFrameObject里，下一次运行时生成器时，python解释器直接按照偏移量寻找下一个字节码指令。&lt;/p></description></item><item><title>Python 巧妙地将rpc接口封装成pythonic的链式调用</title><link>https://sund.site/posts/py-pythonic/</link><pubDate>Tue, 25 Oct 2016 15:40:43 +0000</pubDate><guid>https://sund.site/posts/py-pythonic/</guid><description>&lt;p>这是一个外国人实现的Zabbix(一个开源监控工具)的Python Client——pyzabbix里的代码片段。&lt;/p>
&lt;h2 id="rpc调用">RPC调用&lt;/h2>
&lt;p>Rpc调用的流程是向rpc服务端指定的uri(如http://www.abc.com/jsonrpc.php) 发送json(或其他双方约定格式)数据包，数据包里有rpc版本信息、方法名、参数等。下面&lt;code>Zabbix&lt;/code>类里的&lt;code>do_request&lt;/code>方法就完成了将方法名和方法参数打包json后发送请求的过程。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">Zabbix&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">object&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="c1"># ... skip other class methods&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">do_request&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">method&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">None&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">request_json&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="s1">&amp;#39;jsonrpc&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;2.0&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;method&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">method&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;params&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="ow">or&lt;/span> &lt;span class="p">{},&lt;/span>
&lt;span class="s1">&amp;#39;id&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">response&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">session&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">post&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">data&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">json&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">dumps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">request_json&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="n">timeout&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timeout&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="技巧">技巧&lt;/h2>
&lt;p>但是为了方便，我们在python里一般使用&lt;code>zabbixclient.host.get(args)&lt;/code>这样的链式调用，而不用&lt;code>zabbixclient('host.get', args)&lt;/code>这样的调用方式。pyzabbix的作者巧妙的实现了这样的转换。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">Zabbix&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">object&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="c1"># ... skip other class methods&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">do_request&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">method&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">params&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">None&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">request_json&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="s1">&amp;#39;jsonrpc&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;2.0&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;method&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">method&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s1">&amp;#39;params&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">params&lt;/span> &lt;span class="ow">or&lt;/span> &lt;span class="p">{},&lt;/span>
&lt;span class="s1">&amp;#39;id&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">id&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">response&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">session&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">post&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">url&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">data&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">json&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">dumps&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">request_json&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="n">timeout&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timeout&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="c1"># python内建方法，当获取某个对象的属性时，调用该对象的该方法&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__getattr__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">attr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;Dynamically create an object class (ie: host)&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="c1"># 此处把self传给ZabbixAPIObjectClass的self.parent&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ZabbixAPIObjectClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">attr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">ZabbixAPIObjectClass&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">object&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">parent&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">parent&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">parent&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__getattr__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">attr&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;Dynamically create a method (ie: get)&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">fn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">kwargs&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">args&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">kwargs&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">TypeError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Found both args and kwargs&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="c1"># 此处把父类传进来的方法名name和子方法attr拼成rpc的方法名&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">parent&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">do_request&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="s1">&amp;#39;{0}.{1}&amp;#39;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">attr&lt;/span>&lt;span class="p">),&lt;/span>
&lt;span class="n">args&lt;/span> &lt;span class="ow">or&lt;/span> &lt;span class="n">kwargs&lt;/span>
&lt;span class="p">)[&lt;/span>&lt;span class="s1">&amp;#39;result&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">fn&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>类似地，很多接口的实现都可以照搬这种方式把参数调用改成链式调用，如pymongo，redis-py等。&lt;/p>
&lt;h2 id="参考资料">参考资料：&lt;/h2>
&lt;p>&lt;a href="https://github.com/lukecyca/pyzabbix">https://github.com/lukecyca/pyzabbix&lt;/a>&lt;/p></description></item><item><title>Python Fabric库无法启动后台进程的问题和解决办法</title><link>https://sund.site/posts/py-fabric/</link><pubDate>Wed, 19 Oct 2016 16:25:51 +0000</pubDate><guid>https://sund.site/posts/py-fabric/</guid><description>&lt;h2 id="问题和处理方法">问题和处理方法&lt;/h2>
&lt;p>Python 的 Fabric 库能够方便的远程操作Linux主机执行命令或传输文件。其实现方式就是底层实现ssh协议，例如执行下面代码的run方法，在目标主机上启动一个zabbix后台服务：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">fabric&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">api&lt;/span>
&lt;span class="kn">from&lt;/span> &lt;span class="nn">fabric.tasks&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">Task&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">Zabbix&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Task&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">kwargs&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">with&lt;/span> &lt;span class="n">api&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">settings&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">host_string&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;192.168.1.2&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">user&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;root&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">password&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;123456&amp;#39;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">api&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;service zabbix_agentd start&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是这样操作后虽然 Fabric 的 output 返回结果打印是启动成功，但是ssh登录目标主机，却不见 zabbix_agentd 进程，这说明没有真正启动起来。&lt;/p>
&lt;p>我查询了 Fabric 文档，发现需要在api.run里添加参数&lt;code>pty=False&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-python" data-lang="python"> &lt;span class="n">api&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">run&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;service zabbix_agentd start&amp;#39;&lt;/span>&lt;span class="err">，&lt;/span> &lt;span class="n">pty&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样就成功启动了后台进程。&lt;/p>
&lt;h2 id="原因">原因&lt;/h2>
&lt;h3 id="什么是pty">什么是pty？&lt;/h3>
&lt;p>pty 是 pseudo-tty，众所周知 tty 是 Linux 支持输入与输出的终端设备，在 shell 下执行&lt;code>ps&lt;/code>可以查看每个进程对应的tty设备号，如&lt;code>ttys0001&lt;/code>。&lt;/p>
&lt;p>pty 是为了解决远程连接时一方不希望对方直接ssh连接到主机上而诞生的「虚拟设备」，即伪tty，其原理是在远程主机和本地之间同时启动pty端口连接终端，可以类比进程间的通道，pty两端同时执行输入输出操作，如同本地直接连接到远程主机。但是一旦断开本地与远程主机的连接，pty就会结束所有刚才的进程。&lt;/p>
&lt;p>根据网上的资料，Github 仓库的 ssh 连接就采用 pty， Github 不希望用户创建一个可与它的主机交互的 ssh 连接，所以采用这种模式。&lt;/p>
&lt;p>Fabric 在默认情况下就采用 pty ，所以想要用 fabric 登录目标主机启动后台进程，必须加上 &lt;code>pty=False&lt;/code>。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;p>&lt;a href="https://github.com/fabric/fabric/issues/395">https://github.com/fabric/fabric/issues/395&lt;/a>
&lt;a href="http://ytliu.info/blog/2013/09/28/ttyde-na-xie-shi-er/">http://ytliu.info/blog/2013/09/28/ttyde-na-xie-shi-er/&lt;/a>
&lt;a href="http://7056824.blog.51cto.com/69854/276610">http://7056824.blog.51cto.com/69854/276610&lt;/a>&lt;/p></description></item><item><title>Python defaultdict结构作计数器的用法</title><link>https://sund.site/posts/py-defaultdict/</link><pubDate>Tue, 11 Oct 2016 15:00:16 +0000</pubDate><guid>https://sund.site/posts/py-defaultdict/</guid><description>&lt;p>在开发中经常需要用到计数器，当函数foo调用另一个函数bar时，为了确认调用bar之后处理的结果正确性，经常需要使用计数器来统计bar函数里处理成功了多少次。例如：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="n">success_num&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">bar&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">print&lt;/span> &lt;span class="n">success_num&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">bar&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="n">n&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="c1"># 假设这个任务要迭代100次.&lt;/span>
&lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">100&lt;/span>
&lt;span class="k">try&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="c1"># Do something.&lt;/span>
&lt;span class="n">n&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="k">except&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">pass&lt;/span>
&lt;span class="k">finally&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">n&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是，这里需要定义多个计数器变量来保存计数。每多一个bar函数就要多定义两次计数器。有没有类似C语言指针一样的方法，可以在foo中定义后直接传给bar，在bar里修改值呢。&lt;/p>
&lt;p>众所周知，Python的参数传值实际传的是变量的拷贝，但是对于像字典、列表等非基本数据结构，实际传给参数的是这个数据结构的指针地址，修改指针地址指向的实际值就可以在函数内外实现传递数据的效果了。那么利用这个特性，可以结合python标准库collections里的defaultdict结构来实现一个更方便的计数器：&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">from&lt;/span> &lt;span class="nn">collections&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">defaultdict&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">foo&lt;/span>&lt;span class="p">():&lt;/span>
&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">defaultdict&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">bar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">print&lt;/span> &lt;span class="n">result&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">bar&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">count&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">100&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">count&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">try&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="c1"># Do something.&lt;/span>
&lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;success&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="k">except&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">result&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;fail&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，变量&lt;code>result&lt;/code>就是存有正确计数和错误计数的字典。&lt;/p></description></item><item><title>怎样的建议才有价值</title><link>https://sund.site/posts/talk-is-cheap/</link><pubDate>Thu, 25 Aug 2016 13:13:47 +0800</pubDate><guid>https://sund.site/posts/talk-is-cheap/</guid><description>&lt;p>我想很多时候我们下决心做一件事，都要征求周围人的建议。这些建议有好有坏。坏的建议不但帮不了你，还会歪曲你对事实的认识。最近我在研究系统学习英文的方法，偶然在豆瓣小站里看到了开头那段话，对此深表认同。以我个人健身的经历，在报名私教课之前也寻求过很多人的建议。大部分会告诉你，健身(减肥)最重要的就是坚持。他们还会煞有介事的告诉你要「管住嘴，迈开腿」。在这一年里，我减掉了大概25KG体重，最大的感受——如果没有教练指导，我自己是断然不会坚持下来的。大部分的建议都像开头引用的那段话一样，是假大空的虚话，废话。&lt;/p>
&lt;p>「任何一个通过自我磨练掌握了某一项具体技能或者在某领域内有一定造诣的人，都会对该领域有着起码的基本认知和独特的个人总结，如果你向其请教，得到的断然不会是“努力去做或者坚持最重要”之类的假大空的虚话」&lt;br>
—— 豆瓣英语学习大神 恶魔奶爸Sam&lt;/p>
&lt;p>怎样征求有用的建议？结合我这些年减肥失败的教训，笼统的概括为：如果你要做一件长期投入的事儿，那么请咨询跟你情况类似，且做成了这件事的人。&lt;/p>
&lt;p>首先「情况类似」很重要。因为很多人是科班出身，比如健身教练，他们大部分从上学起就被动养成了科学饮食、运动的好习惯。这些习惯并不是主动思考之后产生的，所以这些人在传授你知识时往往模糊不清的告诉你应该如何做，却说不出所以然。再比如英语系的学生就很难告诉你行之有效的英语学习方法，他们会告诉你大量看美剧英剧，背单词。但是你根本没有他们的学习环境，几乎不可能坚持下来。在语言学习中有「可理解输入」的概念，简单解释就是——你必须接受那些「你能够理解」的知识，否则你就吸收不了(记不住)。同理，知识在灌输给我们时候，如果不解释清楚来由，我们就很难有深刻认识。所以征求建议的对象如果跟你情况类似，你往往能听到更加切实可行的建议，比如在某个阶段应该注意什么，可能片面，但是有效。比如我在健身初期，咨询同学大伟很多健身的入门知识，关于人体代谢率，关于自重训练。这些东西，科班出身的教练通常不会细致地讲解给我。&lt;/p>
&lt;p>其次「要征求做成了这件事的人」，这就是开头那段话的意义，那些没做成这件事儿的人，大都输在了「坚持」这两个字上。在把这一信息转告别人时，这些人就会主观放大坚持的重要性。你去征求这些自己都没成事儿的人建议，得到的都是些「管住嘴，迈开腿」，「坚持不懈」之类的屁话。我这一年锻炼和饮食的心得就是不断学习，反复修订计划和总结经验。另外还有一种傻逼理论「每个人都有各自的特点，要针对性制定计划，没有一种通用的解决办法」。倘若真是这样，还上学干什么？搞科研做什么？管理学、经济学都要歇菜了。别用个体差异给自己找借口了。&lt;/p>
&lt;p>我猜很多有主见，独立思考的人都会认同一句话。这句话是罗永浩在一次鲁豫有约采访时候说的——「我们周围大部分人都是笨蛋」。虽然老罗最近在做手机上栽了大跟头，但是大多数人一辈子连栽这样跟头的机会都没有就入土了。可是骂他的成千上万人里有多少是经历过这过程的呢？传播那些人云亦云的虚话，不过是懒于思考，不求上进的人找好的借口。他们自己做不到的，就理所当然认为你也做不到。抱着「周围大部分人都是笨蛋」的理念，积极地去跟「对的人」征求「有价值」的建议，我相信一定能有所收获。&lt;/p></description></item><item><title>ZooKeeper 帮助手册</title><link>https://sund.site/posts/zookeeper/</link><pubDate>Tue, 14 Oct 2014 00:00:00 +0000</pubDate><guid>https://sund.site/posts/zookeeper/</guid><description>&lt;p>原文地址：
&lt;a href="http://zookeeper.apache.org/doc/r3.4.6/zookeeperProgrammers.html">http://zookeeper.apache.org/doc/r3.4.6/zookeeperProgrammers.html&lt;/a>&lt;/p>
&lt;p>本文假设你已经具有一定分布式计算的基础知识。你将在第一部分看到以下内容：&lt;/p>
&lt;ul>
&lt;li>ZooKeeper数据模型&lt;/li>
&lt;li>ZooKeeper Sessions&lt;/li>
&lt;li>ZooKeeper Watches&lt;/li>
&lt;li>一致性保证(Consistency Guarantees)&lt;/li>
&lt;/ul>
&lt;p>接下来的4小节讲述了程序开发的实际应用：&lt;/p>
&lt;ul>
&lt;li>创建模块——ZooKeeper操作指引&lt;/li>
&lt;li>编程语言接口&lt;/li>
&lt;li>简单示例演示程序的结构&lt;/li>
&lt;li>常见问题和故障&lt;/li>
&lt;/ul>
&lt;p>本文的附录中包含和ZooKeeper相关的有用信息。&lt;/p>
&lt;h3 id="zookeeper的数据模型">ZooKeeper的数据模型&lt;/h3>
&lt;p>ZooKeeper有一个类似分布式文件系统的命名体系。区别在于Zookeeper每个一个节点或子节点都可以拥有数据。节点路径是一个由斜线分开的绝对路径，注意没有相对路径。只要满足下面要求的unicode字符都可以作为节点路径：&lt;/p>
&lt;ul>
&lt;li>空字符不能出现在路径名&lt;/li>
&lt;li>不能出现以下字符: \u0001 - \u0019 and \u007F - \u009F&lt;/li>
&lt;li>以下字符不允许使用: \ud800 -uF8FFF, \uFFF0-uFFFF, \uXFFFE - \uXFFFF (where X is a digit 1 - E), \uF0000 - \uFFFFF&lt;/li>
&lt;li>字符&amp;quot;.&amp;ldquo;可以作为一个名字的一部分, 但是&amp;rdquo;.&amp;ldquo;和&amp;rdquo;..&amp;ldquo;不能单独作为相对路径使用, 以下用法都是无效的: &amp;ldquo;/a/b/./c&amp;quot;或者&amp;rdquo;/a/b/../c&amp;rdquo;&lt;/li>
&lt;li>&amp;ldquo;zookeeper&amp;quot;为保留字符&lt;/li>
&lt;/ul>
&lt;h4 id="znodes">ZNodes&lt;/h4>
&lt;p>ZooKeeper树结构中的节点被称为znode。各个znode维护着一组用来标记数据和访问权限发生变化的版本号。这些版本号组成的状态结构具有时间戳。Zookeeper使用版本号和时间戳来验证缓存状态，调整更新。
每次znode中的数据发生变化，znode的版本号增加。例如，每当一个客户端恢复数据时，它就接收这个版本的数据，而当一个客户端提交了更新或删除记录，它必须同时提供这个znode当前正在发生变化的数据的版本。如果这个版本和目前真实的版本不匹配，则提交无效。
__提示，在分布式程序中，一个字节点可以代表一个通用的主机，服务器，集群中的一员，客户端程序等。但是在Zookeeper中，znode代表数据节点，Servers代表组成了Zookeeper服务的机器; quorum peers refer to the servers that make up an ensemble; 客户端代表任何使用ZooKeeper服务的主机或程序。&lt;/p>
&lt;p>znode作为对程序开发来说最重要的信息，有几个特性需要特别关注下：&lt;/p>
&lt;p>&lt;strong>Watches&lt;/strong>
客户端可以在znode上设置Watch。znode发生的变化会触发watch然后清除watch。当一个watch被触发，Zookeeper给客户端发送一个通知。更多关于watch的内容请查看ZooKeeper Watches一节。&lt;/p>
&lt;p>&lt;strong>数据存取&lt;/strong>
命名空间中每个znode中的数据读写是原子操作。读操作读取znode中的所有数据位，写操作则替换所有数据。每个节点都有一个访问权限控制表（ACL）来标记谁可以做什么。
zookeeper不是设计成普通的数据库或大型对象存储的。它是用来管理coordination data。coordination data包括配置文件、状态信息、rendezvous等。这些数据结构的一个共同特点就是相对较小——以千字节为准。Zookeeper的客户端和服务会检查确保每个znode上的数据小于1M，实际平均数据要远远小于1M。
大规模数据的操作会引发一些潜在的问题并且延长在网络和介质之间传输的时间。如果确实需要大型数据的存储，那么可以采用如NFS或HDFS之类的大型数据存储系统，亦或是在zookeeper中存储指向存储位置的指针。&lt;/p>
&lt;p>&lt;strong>临时节点（Ephemeral Nodes）&lt;/strong>
zookeeper还有临时节点的概念，这些节点的生命周期依赖于创建它们的session是否活跃。session结束时节点即被销毁。也由于这种特性，临时节点不允许有子节点。&lt;/p>
&lt;p>&lt;strong>序列节点——命名不唯一&lt;/strong>
当你创建节点的时候，你会需要zookeeper提供一组单调递增的计数来作为路径结尾。这个计数对父znode是唯一的。用&lt;code>%010d&lt;/code>的格式——用0来填充的10位数（计数如此命名是为了简单排序）。例如&amp;rdquo;&lt;path>0000000001&amp;quot;，注意计数器是有符号整型，超过表示范围会溢出。&lt;/p>
&lt;h4 id="zookeeper中的时间">ZooKeeper中的时间&lt;/h4>
&lt;p>zookeeper有很多记录时间的方式：&lt;/p>
&lt;ul>
&lt;li>Zxid(ZooKeeper Transaction Id)： zookeeper每次发生改动都会增加zxid，zxid越大，发生的时间越靠后。&lt;/li>
&lt;li>Version numbers： 对znode的改动会增加版本号。版本号包括version (znode上数据的修改数), cversion (znode的子节点的修改数), aversion (znode上ACL（权限）的修改数)。&lt;/li>
&lt;li>Ticks : 多个server构成zookeeper服务时，各个server用ticks来标记如状态上报、连接超时等事件。ticks time还间接反映了session超时的最小值（两次tick time）；如果客户端请求的最小session timeout低于这个最小值，服务端会通知客户端最小超时置为这个最小值。&lt;/li>
&lt;li>Real time : 除了每次znode创建或改动时候将时间戳记录到状态结构中外，zookeeper不使用时钟时间。&lt;/li>
&lt;/ul>
&lt;h4 id="zookeeper状态结构stat-structure">ZooKeeper状态结构(Stat Structure)&lt;/h4>
&lt;p>存在于znode中的状态结构，由以下各个部分组成：&lt;/p>
&lt;ul>
&lt;li>czxid - znode创建产生的zxid&lt;/li>
&lt;li>mzxid - znode最后一次修改的zxid&lt;/li>
&lt;li>ctime - znode创建的时间的绝对毫秒数&lt;/li>
&lt;li>mtime - znode最后一次修改的绝对毫秒数&lt;/li>
&lt;li>version - znode上数据的修改数&lt;/li>
&lt;li>cversion - 子节点修改数&lt;/li>
&lt;li>aversion - znode的ACL修改数&lt;/li>
&lt;li>ephemeralOwner - 临时节点的所有者的session id。如果此节点非临时节点，该值为0&lt;/li>
&lt;li>dataLength - znode的数据长度&lt;/li>
&lt;li>numChildren - znode子节点数&lt;/li>
&lt;/ul>
&lt;h3 id="zookeeper-sessions">ZooKeeper Sessions&lt;/h3>
&lt;p>客户端通过创建一个handle和服务端建立session连接。一旦创建完成，handle就进入了CONNECTING状态，客户端库尝试连接一台构成zookeeper的server，届时进入CONNECTED状态。通常情况下操作会介于这两种状态之间。
一旦出现了不可恢复的错误：如session中止，鉴权失败或者应用直接结束handle，则handle会进入到CLOSED状态。下图是客户端的状态转换图：&lt;/p>
&lt;p>&lt;img>状态转换图&lt;/img>&lt;/p>
&lt;p>应用在创建客户端session时必须提供一串逗号分隔的主机号:端口号，每对主机端口号对应一个ZooKeeper的server（如：&amp;ldquo;127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002&amp;rdquo;），客户端库会尝试连接任意一台服务器，如果连接失败或是客户端主动断开连接，客户端会自动继续与下一台服务器连接，直到连接成功。&lt;/p>
&lt;p>&lt;strong>3.2.0版本新增内容&lt;/strong>: 一个新的操作“chroot”可以添加在连接字符串的尾部，用来指明客户端命令运行的根目录地址。类似unix的chroot命令，例如：
&amp;ldquo;127.0.0.1:4545/app/a&amp;rdquo; or &amp;ldquo;127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002/app/a&amp;rdquo;，说明客户端会以&amp;quot;/app/a&amp;quot;为根目录，所有路径都相对于根目录来设置，如&amp;quot;/foo/bar&amp;quot;的操作会运行在&amp;quot;/app/a/foo/bar&amp;quot;。
这一特性在多用户环境下非常好用，每个使用zookeeper服务的用户可以设置不同的根目录。&lt;/p>
&lt;p>当客户端获得和zookeeper服务连接的handle时，zookeeper会创建一个Zookeeper session分配给客户端，用一个64-bit数字表示。一旦客户端连接了其他服务器，客户端必须把这个session id也作为连接握手的一部分发送。出于安全目的，zookeeper给session id创建一个密码，任何zookeeper服务器都可以验证密码。
当客户端创建session时密码和session id一起发送到客户端来，当客户端重新连接其他服务器时，同时要发送密码和session id。&lt;/p>
&lt;p>zookeeper客户端库里有一个创建zookeeper session的参数，叫做session timeout（超时），用毫秒表示。客户端发送请求超时，服务端在超时范围内响应客户端。session超时最小为2个ticktime，最大为20个ticktime。zookeeper客户端API可以协调超时时间。
当客户端和zookeeper服务器集群断开时，它会搜索session创建时的服务器列表。最后，当至少一个服务器和客户端重新建立连接，session或被重新置为&amp;quot;connected&amp;quot;状态（超时时间内重新连接），或被置为&amp;quot;expired（过期）&amp;ldquo;状态（超出超时时间）。不建议在断开连接后重新创建session。ZK客户端库会帮你重新连接。特别地，我们将启发式学习模式植入客户的库中来处理类似“羊群效应”等问题。只有当你的session过期时才重新创建（托管的）。
session过期的状态转换图示例同过期session的watcher：&lt;/p>
&lt;ol>
&lt;li>&amp;lsquo;connected&amp;rsquo; : session正确创建，客户端和服务集群正常连接&lt;/li>
&lt;li>&amp;hellip;. 客户端从服务器集群断开&lt;/li>
&lt;li>&amp;lsquo;disconnected&amp;rsquo; : 客户端失去和服务器集群的连接&lt;/li>
&lt;li>&amp;hellip;. 过了一段时间, 超过了集群判定session过期的超时时间, 客户端并没有发觉自己和服务集群断开了连接&lt;/li>
&lt;li>&amp;hellip;. 又过一段时间, 客户端恢复了同集群的网络连接&lt;/li>
&lt;li>&amp;lsquo;expired&amp;rsquo; : 最终客户端重新连上集群，然后被通知已经到期&lt;/li>
&lt;/ol>
&lt;p>另一个session建立时zookeeper需要的参数是默认watcher（监视者）。在客户端发生任何变化时，watcher都会发出通知。例如客户端失去和服务器的连接、客户端session到期等。watcher默认的初始状态是disconnected。（也就是说任何状态改变事件都由客户端库发送到watcher）。当新建一个连接时，第一个发送给watcher的事件通常就是session连接事件。&lt;/p>
&lt;p>客户端发送请求会使session保持活动状态。客户端会发送ping包（译者注：心跳包）以保持session不会超时。Ping包不仅让服务端知道客户端仍然活动，而且让客户端也知道和服务端的连接没有中断。Ping包发送时间正好可以判断是否连接中断或是重新启动一个新的服务器连接。&lt;/p>
&lt;p>和服务器的连接建立成功，当一个同步或异步操作执行后，有两种情况会让客户端库判断失去连接：&lt;/p>
&lt;ol>
&lt;li>应用在已经失效的session上请求了一个操作时&lt;/li>
&lt;li>zookeeper服务器有一个等待中的操作时，客户端会从那台服务器断开连接。即服务器有等待的异步调用。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>3.2.0版本新增内容 —— SessionMovedException&lt;/strong> 一个客户端无法查看的内部异常SessionMovedException。这个异常发生在服务端收到一个请求，这个请求的session已经在另一个服务器上重新连接。发生这种情况的原因通常是客户端发送完请求后，由于网络延时，客户端超时重新和其他服务器建立连接，当请求包到达第一台服务器时，服务器发现session已经移除并关闭了和客户端的连接。客户端一般不用理会这个问题，但是有一种情况值得注意，当两台客户端使用事先存储的session id和密码试图创建同一个连接时，第一台客户端重建连接，第二台则会被中断。&lt;/p>
&lt;h3 id="zookeeper-watches">ZooKeeper Watches&lt;/h3>
&lt;p>所有zookeeper的读操作——getData(), getChildren(), exists()——都可以设置一个watch。Zookeeper的watch的定义是：watch事件是一次性触发的，发送到客户端的。在监视的数据发生变化时产生watch事件。以下三点是watch(事件)定义的关键点：&lt;/p>
&lt;ul>
&lt;li>一次性触发:
当数据发生变化时，一个watch事件被发送给客户端。例如，如果一个客户端做了一次&lt;code>getData(&amp;quot;/znode1&amp;quot;, true)&lt;/code>然后节点&lt;code>/znode1&lt;/code>发生数据变化或删除，这个客户端将收到&lt;code>/znode1&lt;/code>的watch事件。如果&lt;code>/znode1&lt;/code>继续发生改变，不会再有watch发送，除非客户端又做了其他读操作产生了新的watch。&lt;/li>
&lt;li>发送给客户端:
这就意味着，事件在发往客户端的过程中，可能无法在修改操作成功的返回值到达客户端之前到达客户端。watch是异步发送给watchers的。zookeeper提供一种保证顺序的方法：客户端在第一次看到某个watch事件之前不可能看到产生watch的修改的返回值。网络延时或其他因素可能导致不同客户端看到watch并返回不同时间更新的返回值。关键的一点是，不同的客户端看到发生的一切都必须是按照相同顺序的。&lt;/li>
&lt;li>watch依附的数据:
这是说改变一个节点有不通方式。用好理解的话说，zookeeper维护两组watch：data watch和child watch。getData()和exists()产生data watch。getChildren()引起child watch。watch根据数据返回的种类不同而不同。getData()和exists()返回关于节点的数据信息，而getChildren()返回子节点列表。因此setData()触发某个znode的data watch（假设事件成功）。create()成功会触发被创建的znode上的data watch和在它父节点上的child watch。delete()成功会触发data watch和child watch（因为没有了子节点）。&lt;/li>
&lt;/ul>
&lt;p>watch在客户端已连接上的服务器里维护，这样可以保证watch轻量便于设置，维护和分发。当客户端连接了一台新的服务器，watch会在任何session事件时触发。当断开和服务器的连接时，watch不会触发。当客户端重新连接上时，任何之前注册过的watch都会重新注册并在需要的时候被触发。一般来说这一切都是透明的。只有一种可能会丢失watch：当一个znode在断开和服务器连接时被创建或删除，那么判断这个znode存在的watch因未创建而找不到。&lt;/p>
&lt;p>&lt;strong>ZooKeeper如何保证watch可靠性&lt;/strong>&lt;/p>
&lt;p>zookeeper有如下方式：&lt;/p>
&lt;ul>
&lt;li>watch与其他事件、watch、异步回复保持有序，Zookeeper客户端库确保任何分发都是有序的。&lt;/li>
&lt;li>客户端会在某个监视的znode数据更新之前看到这个znode的watch事件。&lt;/li>
&lt;li>watch事件的顺序由Zookeeper服务端观察到的更新顺序决定。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>watch注意事项&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>watch是一次性触发的；如果你收到watch事件后还想继续得到后续更改的通知，你需要再生成（设置）一个watch。&lt;/li>
&lt;li>由于watch是一次性触发，你在获取某事件和发送新的请求来得到watch这个操作之间，无法确保观察到Zookeeper中那个节点在这期间的所有修改。你要准备好应付这种情况出现：znode会在收到事件和再次设置新事件（译者注：对节点的操作）之间发生了多次修改。（你可能并不关心，但是必须了解这可能发生）&lt;/li>
&lt;li>watch对象，或是function/context对，只会在得到通知时触发一次。例如，如果一个watch对象同时用来监控某个目标文件是否存在和监听getData()，之后那个文件被删除了。那么这个watch对象只会触发一次文件删除事件通知。&lt;/li>
&lt;li>如果你断开了同服务器的连接（例如服务器挂了），你在重新连上之前得不到任何watch。出于这种原因，session event会被发送给所有重要的watch handler。可以使用session事件进入安全模式：当断开连接时你收不到任何事件，这样你的进程可以在那种模式下稳健地执行。(译者注：可以通过发送session event使客户端进入安全模式（伪断开连接状态），在安全模式你可以修改代码而不用担心程序收到事件通知)&lt;/li>
&lt;/ul>
&lt;h3 id="使用acl控制zookeeper访问权限">使用ACL控制ZooKeeper访问权限&lt;/h3>
&lt;p>zookeeper使用ACL来控制对znode（zookeeper的数据节点）的访问权限。ACL的实现方式和unix的文件权限类似：用不同位来代表不同的操作限制和组限制。与标准unix权限不同的是，zookeeper的节点没有三种域——用户，组，其他。zookeeper里没有节点的所有者的概念。取而代之的是，一个由ACL指定的id集合和其相关联的权限。
注意，一个ACL只从属于一个特定的znode。对这个znode子节点也是无效的。例如，如果&lt;code>/app&lt;/code>只有被ip172.16.16.1的读权限，&lt;code>/app/status&lt;/code>有被所有人读的权限，那么&lt;code>/app/status&lt;/code>可以被所有人读，ACL权限不具有递归性。
zookeeper支持插件式认证方式，id使用&lt;code>scheme:id&lt;/code>的形式。&lt;code>scheme&lt;/code>是id对应的类型方式，例如&lt;code>ip:172.16.16.1&lt;/code>就是一个地址为172.16.16.1的主机id。
当客户端连接zookeeper并且认证自己，zookeeper就在这个与客户端的连接中关联所有与客户端一致的id。当客户端访问某个znode时，znode的ACL会重新检查这些id。ACL的表达式为&lt;code>(scheme:expression,perms)&lt;/code>。&lt;code>expression&lt;/code>就是特殊的scheme，例如，&lt;code>(ip:19.22.0.0/16, READ)&lt;/code>就是把任何以19.22开头的ip地址的客户端赋予读权限。&lt;/p>
&lt;h4 id="acl权限">ACL权限&lt;/h4>
&lt;p>ZooKeeper支持下列权限：&lt;/p>
&lt;ul>
&lt;li>CREATE：允许创建子节点&lt;/li>
&lt;li>READ：允许获得节点数据并列出所有子节点&lt;/li>
&lt;li>WRITE：允许设置节点上的数据&lt;/li>
&lt;li>DELETE：允许删除子节点&lt;/li>
&lt;li>ADMIN：允许设置权限&lt;/li>
&lt;/ul>
&lt;p>CREATE和DELETE操作是更细的粒度上的WRITE操作。有一种特殊的情况：&lt;/p>
&lt;ul>
&lt;li>你想要A获得操作zookeeper上某个znode的权限，但是不可以对其子节点进行CREATE和DELETE。&lt;/li>
&lt;li>只CREATE不DELETE：某个客户端在上一级目录上通过发送创建请求创建了一个zookeeper节点。你希望所有客户端都可以在这个节点上添加，但是只有创建者可以删除。（这就类似于文件的APPEND权限）&lt;/li>
&lt;/ul>
&lt;p>zookeeper没有文件所有者的概念，但有ADMIN权限。在某种意义上说，ADMIN权限指定了所谓的所有者。zookeeper虽然不支持查找权限（在目录上的执行权限虽然不能列出目录内容，却可以查找），但每个客户端都隐含着拥有查找权限。这样你可以查看节点状态，但仅此而已。（这有个问题，如果你在不存在的节点上调用了zoo_exists()，你将无权查看）&lt;/p>
&lt;h4 id="内建acl模式">内建ACL模式&lt;/h4>
&lt;p>ZooKeeper有下列内建模式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>world&lt;/strong> 有独立id，anyone，代表任何用户。&lt;/li>
&lt;li>&lt;strong>auth&lt;/strong> 不使用任何id，代表任何已经认证过的用户&lt;/li>
&lt;li>&lt;strong>digest&lt;/strong> 之前使用了格式为&lt;code>username:pathasowrd&lt;/code>的字符串来生成一个MD5哈希表作为ACL ID标识。在空文档中发送&lt;code>username:password&lt;/code>来完成认证。现在的ACL表达式格式为&lt;code>username:base64&lt;/code>, 用SHA1编码密码。&lt;/li>
&lt;li>&lt;strong>ip&lt;/strong> 用客户端的ip作为ACL ID标识。ACL表达式的格式为&lt;code>addr/bits&lt;/code>，addr中最有效的位匹配上主机ip最有效的位。&lt;/li>
&lt;/ul>
&lt;h4 id="zookeeper-c-client-api">ZooKeeper C client API&lt;/h4>
&lt;h3 id="插件式zookeeper认证">插件式ZooKeeper认证&lt;/h3>
&lt;p>zookeeper运行于复杂的环境下，有各种不同的认证方式。因此zookeeper拥有一套插件式的认证框架。内建认证scheme也是使用这套框架。
为了便于理解认证框架的工作方式，你首先要了解两种主要的认证操作。框架首先必须认证客户端。这步操作通常在客户端连接服务器的同时完成并且将从客户端发过来的（或从客户端收集来的）认证信息关联此次连接。认证框架的第二步操作是在ACL中寻找关联的客户端的条目。ACL条目是&lt;code>&amp;lt;idspec, permissions&amp;gt;&lt;/code>格式。idspec可能是一个关联了连接的，和认证信息匹配的简单字符串，也可能是评估认证信息的表达式。这取决于认证插件如何实现匹配。下面是一个认证插件必须实现的接口：&lt;/p>
&lt;pre>&lt;code>public interface AuthenticationProvider {
String getScheme();
KeeperException.Code handleAuthentication(ServerCnxn cnxn, byte authData[]);
boolean isValid(String id);
boolean matches(String id, String aclExpr);
boolean isAuthenticated();
}
&lt;/code>&lt;/pre>
&lt;p>第一个方法&lt;code>getScheme&lt;/code>返回一个标识该插件的字符串。由于我们支持多种认证方式，认证证书或者idspec必须一直加上&lt;code>scheme:&lt;/code>作为前缀。zookeeper服务器使用认证插件返回的scheme判断哪个id适用于该scheme。
当客户端发送与连接关联的认证信息时，handleAuthentication被调用。客户端指定和认证信息相应的模式。zookeeper把信息传给认证插件，认证插件的&lt;code>getScheme&lt;/code>匹配scheme。实现&lt;code>handleAuthentication&lt;/code>的方法通常在判断信息错误后返回一个error，或者在确认连接后使用&lt;code>cnxn.getAuthInfo().add(new Id(getScheme(), data))&lt;/code>&lt;/p>
&lt;p>认证插件在设置和ACL中都有涉及。当对某个节点设置ACL时，zookeeper服务器会传那个条目的id给&lt;code>isValid(String id)&lt;/code>方法。插件需要判断id的连接来源。例如，&lt;code>ip:172.16.0.0/16&lt;/code>是有效id，ip:host.com是无效id。如果新的ACL包括一个&amp;quot;auth&amp;quot;条目，就用&lt;code>isAuthenticated&lt;/code>判断该scheme的认证信息是否关联了连接，是否可以被添加到ACL中。一些scheme不会被包含到auth中。例如，如果auth已经指定，客户端的ip地址就不作为id添加到ACL中。
在检查ACL时zookeeper有一个&lt;code>matches(String id, String aclExpr)&lt;/code>方法。ACL的条目需要和认证信息相匹配。为了找到和客户端对应的条目，zookeeper服务器寻找每个条目的scheme，如果对某个scheme有那个客户端的认证信息，&lt;code>matches(String id, String aclExpr)&lt;/code>会被调用并传入两个值，分别是事先由&lt;code>handleAuthentication&lt;/code> 加入连接信息中认证信息的id，和设置到ACL条目id的&lt;code>aclExpr&lt;/code>。认证插件用自己的逻辑匹配scheme来判断id是否在aclExpr中。&lt;/p>
&lt;p>有两个内置认证插件：ip和digest。附加插件可以使用系统属性添加。在zookeeper启动过程中，会扫描所有以&amp;quot;zookeeper.authProvider&amp;quot;开头的系统属性。并且把那些属性值解释为认证插件的类名。这些属性可以使用&lt;code>-Dzookeeeper.authProvider.X=com.f.MyAuth&lt;/code>或在服务器设置文件中添加条目来创建：&lt;/p>
&lt;pre>&lt;code>authProvider.1=com.f.MyAuth
authProvider.2=com.f.MyAuth2
&lt;/code>&lt;/pre>
&lt;p>注意属性的后缀是唯一的。如果出现重复的情况&lt;code>-Dzookeeeper.authProvider.X=com.f.MyAuth -Dzookeeper.authProvider.X=com.f.MyAuth2&lt;/code>，只有一个会被使用。同样，所有服务器都必须统一插件定义，否则客户端用插件提供的认证schemes连接服务器时会出错。&lt;/p>
&lt;h3 id="一致性保证">一致性保证&lt;/h3>
&lt;p>ZooKeeper是一个高性能，可扩展的服务。读和写操作都非常快速。之所以如此，全因为zookeeper有数据一致性的保证：&lt;/p>
&lt;p>&lt;strong>顺序一致性&lt;/strong>
客户端的更新会按照它们发送的次序排序。&lt;/p>
&lt;p>&lt;strong>原子性&lt;/strong>
更新的失败或成功，都不会出现半个结果。&lt;/p>
&lt;p>&lt;strong>单独系统镜像&lt;/strong>
不管客户端连哪个服务器，它看来都是同一个。&lt;/p>
&lt;p>&lt;strong>可靠性&lt;/strong>
一旦更新生效，它就会一直保存到下一次客户端更新。这就有两个推论：&lt;/p>
&lt;ol>
&lt;li>如果客户端得到成功的返回值，说明更新生效了。在一些错误情况下（连接错误，超时等）客户端不会知道更新是否生效。虽然我们使失败的几率最小化，但是也只能保证成功的返回值情况。（这就叫Paxos算法的单调性条件）&lt;/li>
&lt;li>客户端能看到的更新，即使是渡请求或成功更新，在服务器失败时也不会回滚。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>时效性&lt;/strong>
客户端看到的系统状态在某个时间范围内是最新的（几十秒内），任何系统更改都会在该时间范围内被客户端发现。否则客户端会检测到断开服务。&lt;/p>
&lt;p>用这些一致性保证可以在客户端中构造出更高级的程序如 leader election, barriers, queues, read/write revocable locks(无须在zookeeper中附加任何东西)。更多信息&lt;a href="http://zookeeper.apache.org/doc/r3.4.6/recipes.html">Recipes and Solutions&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>zookeeper不存在的一致性保证： 多客户端同一时刻看到的内容相同
zookeeper不可能保证两台客户端在同一时间看到的内容总是一样，由于网络延迟等原因。假设这样一个场景，A和B是两个客户端，A设置节点/a下的值从0变为1，然后让B读/a，B可能读到旧的数据0。如果想让A和B读到同样的内容，B必须在读之前调用zookeeper接口中的sync()方法。&lt;/p>
&lt;/blockquote>
&lt;h3 id="编程接口">编程接口&lt;/h3>
&lt;h3 id="常见问题和故障">常见问题和故障&lt;/h3>
&lt;p>下面是一些常见的陷阱：&lt;/p>
&lt;ol>
&lt;li>如果你使用watch，你必须监控好已经连接的watch事件。当ZooKeeper客户端断开和服务器的连接，直到重新连接上这段时间你都收不到任何通知。如果你正在监视znode是否存在，那么你在断开连接期间收不到它创建和销毁的通知。&lt;/li>
&lt;li>你必须测试ZooKeeper故障的情况。在大多数服务器都可用的情况下，ZooKeeper是可以维持工作的。关键问题是你的客户端程序是否能察觉到。在实际情况下，客户端与ZooKeeper的连接有可能中断（多数时候是因为Zookeeper故障或网络中断）。Zookeeper的客户端库关注于如何让你重新连接并且知道发生了什么。但是同时你也必须确保能够恢复你的状态和发送失败的请求。努力在测试库里测出这些问题，而不是在产品里——用几台服务器组成的zookeeper集群测试这个问题，尝试让它们重启。&lt;/li>
&lt;li>客户端维护的服务器列表必须和现有的服务器列表一致。如果客户端的列表是现有服务器列表的子集，还可以在非最佳状态工作，但是如果客户端列表里的服务器不在现有集群里你就悲剧了。&lt;/li>
&lt;li>注意存放事务日志的位置。性能评测最重要的部分就是日志，ZooKeeper会在回复响应之前先把日志同步到磁盘上。为了达到最佳性能，首选专用的磁盘来存日志。把日志放在繁忙的磁盘上会降低效率。如果你只有一个磁盘，就把记录文件放在NFS上然后增加SnapshotCount。这样虽然无法完全解决问题，但能缓解一些。&lt;/li>
&lt;li>正确地设置你java的堆空间大小。这是避免频繁交换的有效措施。无用的访问磁盘会让你的效率大打折扣。记住，在ZooKeeper中，一切都是有序的，如果一个服务器访问了磁盘，所有的服务器都会同步这个操作。&lt;/li>
&lt;/ol>
&lt;p>其他资料链接请自行官网查看。&lt;/p></description></item><item><title>macbook安装ubuntu</title><link>https://sund.site/posts/macbook_ubuntu/</link><pubDate>Fri, 04 Jan 2013 00:00:00 +0000</pubDate><guid>https://sund.site/posts/macbook_ubuntu/</guid><description>&lt;p>&lt;strong>注意，ubuntu和xubuntu安装上有一定差别，请严格按照你选择的系统版本流程安装&lt;/strong>&lt;/p>
&lt;h3 id="ubuntu">ubuntu&lt;/h3>
&lt;h3 id="准备工作">准备工作&lt;/h3>
&lt;h5 id="分区">分区&lt;/h5>
&lt;p>这一步可以用命令行实现，也可以在mac下直接用磁盘工具分区，初学者建议后者。有经验的朋友可以在网上查询diskutils的用法，这是mac提供的分区工具&lt;/p>
&lt;p>使用磁盘工具，打开左侧最上边磁盘位置（不是macosx，而是整个硬盘）的选项，右边会出现&lt;code>分区&lt;/code>标签。选择分区，你可以用鼠标拖动轻松将macos的一部分划分给ubuntu使用。分区格式可以选择mac日志文件。其实选什么都一样，等会还要重新格式化。&lt;/p>
&lt;h4 id="把iso镜像转化为苹果电脑识别的img镜像">把iso镜像转化为苹果电脑识别的img镜像&lt;/h4>
&lt;pre>&lt;code>hdiutil convert /path/to/ubuntu.iso -format UDRW -o /path/to/target.img
&lt;/code>&lt;/pre>
&lt;p>命令中&lt;code>path/to/ubuntu.iso&lt;/code>是你下载的iso路径，&lt;code>path/to/target.img&lt;/code>自然是你要保存成img的路径&lt;/p>
&lt;h4 id="插入u盘刻录镜像">插入U盘，刻录镜像&lt;/h4>
&lt;p>先运行如下命令查询你U盘的设备名&lt;/p>
&lt;pre>&lt;code>diskutil list
&lt;/code>&lt;/pre>
&lt;p>这里假设U盘是disk1，执行&lt;/p>
&lt;pre>&lt;code>diskutil unmountDisk /dev/disk1
&lt;/code>&lt;/pre>
&lt;p>接下来执行命令刻录，&lt;/p>
&lt;pre>&lt;code>sudo dd if=/path/to/downloaded.img of=/dev/disk1 bs=1m
&lt;/code>&lt;/pre>
&lt;p>ubuntu官网针对上一条命令可能出现的两种错误提示给出了解决办法：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>If you see the error dd: Invalid number &amp;lsquo;1m&amp;rsquo;, you are using GNU dd. Use the same command but replace bs=1m with bs=1M.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>If you see the error dd: /dev/disk1: Resource busy, make sure the disk is not in use. Start the &amp;lsquo;Disk Utility.app&amp;rsquo; and unmount (don&amp;rsquo;t eject) the drive.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>好了，刻完就可以重启安装了。重启后按住&lt;code>option&lt;/code>会看到一个refit命名的移动设备图标，点进去就开始安装了。&lt;/p>
&lt;h4 id="安装过程">安装过程&lt;/h4>
&lt;p>安装过程可以参考网上其他人的帖子。一般有两种方式&lt;/p>
&lt;ol>
&lt;li>选择&lt;code>ubuntu和mac os x共存&lt;/code>，系统会自动被安装到空闲分区。&lt;/li>
&lt;li>选择&lt;code>其他选项&lt;/code>，可以自己手动分区，我一般是选这个来手动分区。&lt;/li>
&lt;/ol>
&lt;p>假设你选了&lt;code>其他选项&lt;/code>就会进入分区的窗口，这时你就会看到所有磁盘分区的情况，刚才在mac下给ubuntu预先分好一块空闲分区也在其中，名字可能叫disk02，或者disk03什么的。
接下来要进行四次分区。这一段分区方法参考了百度经验上一个网友的教程，我进行了2处修改，原帖地址&lt;a href="http://jingyan.baidu.com/article/60ccbceb18624464cab197ea.html">http://jingyan.baidu.com/article/60ccbceb18624464cab197ea.html&lt;/a>&lt;/p>
&lt;p>第一次分区：&lt;/p>
&lt;pre>&lt;code>点你刚才留出来的“空闲”分区，点“+”，进行如下设置：
挂载点：“/”
大小：22000MB
新分区的类型：主分区
新分区的位置：空间起始位置
用于：EXT4日志文件系统
&lt;/code>&lt;/pre>
&lt;p>第二次分区：&lt;/p>
&lt;pre>&lt;code>“空闲”处，继续点“+”，如下设置，
挂载点：（不设置）
大小：4096MB
新分区的类型：逻辑分区
新分区的位置：空间起始位置
用于：交换空间
&lt;/code>&lt;/pre>
&lt;p>第三次分区：&lt;/p>
&lt;pre>&lt;code>“空闲”处，继续点“+”，如下设置，
挂载点：/boot
大小：200MB
新分区的类型：逻辑分区
新分区的位置：空间起始位置
用于：EXT4日志文件系统
&lt;/code>&lt;/pre>
&lt;p>第四次分区：&lt;/p>
&lt;pre>&lt;code>“空闲”处，继续点“+”，如下设置，
挂载点：/home
大小：（剩余全部空间，剩下显示多少，就多少）
新分区的类型：逻辑分区
新分区的位置：空间起始位置
用于：EXT4日志文件系统
&lt;/code>&lt;/pre>
&lt;p>分区设置完毕后，下方还有一项“安装启动引导器的设备”，macbookpro用户需要选择/boot这个分区所在磁盘位置。&lt;/p>
&lt;h3 id="开机引导程序refit">开机引导程序rEFIT&lt;/h3>
&lt;p>安装完ubuntu，重启在mac下下载安装rEFIt。安装好后在终端里输入&lt;code>/efi/refit/. enable-always.sh&lt;/code>启动rEFIt。重启，你就会看到ubuntu的选项。&lt;/p>
&lt;h3 id="xubuntu估计lubuntu和kubuntu也应该适用仅是猜想">Xubuntu(估计Lubuntu和Kubuntu也应该适用，仅是猜想。)&lt;/h3>
&lt;h3 id="准备工作-1">准备工作&lt;/h3>
&lt;h4 id="如何刻录镜像到移动设备">如何刻录镜像到移动设备&lt;/h4>
&lt;p>这个问题很重要，如果你下载了iso格式的Xubuntu系统镜像，
你需要将该镜像不经过任何转换的完整刻录到移动设备或光盘上
（我使用的是unetbootin 这个软件，开源，跨平台，操作简便）。
注意，绝对不可以将iso格式转换成img（mac镜像）后刻录。
这样会导致ubuntu部分版本无法安装grub引导器。&lt;/p>
&lt;h4 id="开机引导程序refit-1">开机引导程序rEFIt&lt;/h4>
&lt;p>安装完的系统无法被mac直接引导，所以需要安装rEFIt引导。如果不想要安装它，
可以参考下边附录1里的安装方法。重新修改引导文件。&lt;/p>
&lt;h4 id="安装过程-1">安装过程&lt;/h4>
&lt;ol>
&lt;li>在官网下载xubuntu镜像，使用uneetbootin刻录到设备
上(mac版的unetbootin貌似刻录iso有问题，可以在windows上下载该软件使用)。&lt;/li>
&lt;li>重启，开机界面按住&lt;code>option&lt;/code>键，有个windows命名的移动设备图标，选中进入。&lt;/li>
&lt;li>安装过程不敷述, 装后重启&lt;/li>
&lt;li>从mac进入，安装rEFIt，在shell里运行&lt;code>/efi/refit/. enable-always.sh&lt;/code>启动rEFIt&lt;/li>
&lt;li>重启，出现两个图标，苹果代表mac，企鹅代表linux。至此，完成安装过程。&lt;/li>
&lt;/ol>
&lt;h2 id="ubuntu或xubuntu安装后的一些配置">ubuntu或Xubuntu安装后的一些配置&lt;/h2>
&lt;p>打开系统配置文件，&lt;/p>
&lt;pre>&lt;code>sudo gedit /etc/rc.local
&lt;/code>&lt;/pre>
&lt;p>在exit 0 前边加入下边对应的语句,
默认关闭功能键Fn:&lt;/p>
&lt;pre>&lt;code>echo 2 &amp;gt; /sys/module/hid_apple/parameters/fnmode
&lt;/code>&lt;/pre>
&lt;p>设置默认亮度(数字2565可以修改任意亮度)（xubuntu下不起作用，原因未知）&lt;/p>
&lt;pre>&lt;code>echo 2565 &amp;gt; /sys/class/backlight/intel_backlight/brightness
&lt;/code>&lt;/pre>
&lt;p>设置键盘灯亮度（数字1代表亮度):&lt;/p>
&lt;pre>&lt;code>echo 1 &amp;gt; /sys/class/leds/smc::kbd_backlight/brightness
&lt;/code>&lt;/pre>
&lt;h3 id="附录1">附录1&lt;/h3>
&lt;p>&lt;a href="https://help.ubuntu.com/community/MacBookPro11-1/Saucy">https://help.ubuntu.com/community/MacBookPro11-1/Saucy&lt;/a>&lt;/p></description></item></channel></rss>