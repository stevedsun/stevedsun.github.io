<!doctype html><html lang=zh-CN><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://sund.site/favicon.ico><title>Python 依赖管理工具的研究 | Steve Sun</title>
<meta name=title content="Python 依赖管理工具的研究"><meta name=description content="太长不读
如果你从事工程项目，poetry 是目前最好的方案，但是如果你不喜欢 Python 的 virtualenv，可以试试 pdm。
混乱的 Python
Python 的依赖管理工具 pip 一直被众多开发者吐槽。从我个人角度，pip 有三点致命缺陷：

无法解决 Python 依赖环境的隔离问题
依赖管理文件 requirements.txt 无法真正开箱即用
打包部署非常麻烦，需要手动配置

环境隔离问题
Python 的依赖库可以安装到系统全局，也可以安装到用户目录（/home/${USER}/.local）。但如果你同时管理多个 Python 项目，就需要将不同项目的依赖拆分到不同的文件夹分开管理。
传统方式是基于 virtualenv 创建隔离的 Python bin 文件和项目依赖的虚拟环境（所谓虚拟环境并不是虚拟机，只是个绑定 terminal session 的命令环境）。这种方式的缺点是：

开发者需要经常关注“我现在处于哪个项目目录？我需要切换到当前虚拟环境里吗？”之类的问题。
virtualenv 只解决环境隔离，但是无法同步更新依赖文件、打包发布。

依赖安装问题
Python 管理依赖的手段，最早是手动执行pip install xxx来安装依赖，最后 pip freeze 来导出依赖列表到一个 requirements.txt 文件里。但是这个 txt 文件非常令人困惑。

不像 NodeJS 那么方便，想要升、降级某个依赖版本，无法自动同步到 txt 文件里。
平铺式地列出了所有一级、二级依赖包（即依赖包的依赖包）。因为 Python 某些依赖又基于系统上安装的 C 库版本，这就导致不同系统环境上执行 pip install -r requirements.txt 得到的效果并不一致，经常报错。

打包部署问题
Python 一般使用 wheel 打包二进制，它只解决打包问题，环境依赖是靠 pip 和 setuptools 完成，所以使用 wheel 你仍然要操心环境隔离和依赖管理问题。"><meta name=keywords content="python,"><link rel=canonical href=https://sund.site/posts/2023/python-packaging/><meta property="og:url" content="https://sund.site/posts/2023/python-packaging/"><meta property="og:site_name" content="Steve Sun"><meta property="og:title" content="Python 依赖管理工具的研究"><meta property="og:description" content="太长不读 如果你从事工程项目，poetry 是目前最好的方案，但是如果你不喜欢 Python 的 virtualenv，可以试试 pdm。
混乱的 Python Python 的依赖管理工具 pip 一直被众多开发者吐槽。从我个人角度，pip 有三点致命缺陷：
无法解决 Python 依赖环境的隔离问题 依赖管理文件 requirements.txt 无法真正开箱即用 打包部署非常麻烦，需要手动配置 环境隔离问题 Python 的依赖库可以安装到系统全局，也可以安装到用户目录（/home/${USER}/.local）。但如果你同时管理多个 Python 项目，就需要将不同项目的依赖拆分到不同的文件夹分开管理。
传统方式是基于 virtualenv 创建隔离的 Python bin 文件和项目依赖的虚拟环境（所谓虚拟环境并不是虚拟机，只是个绑定 terminal session 的命令环境）。这种方式的缺点是：
开发者需要经常关注“我现在处于哪个项目目录？我需要切换到当前虚拟环境里吗？”之类的问题。 virtualenv 只解决环境隔离，但是无法同步更新依赖文件、打包发布。 依赖安装问题 Python 管理依赖的手段，最早是手动执行pip install xxx来安装依赖，最后 pip freeze 来导出依赖列表到一个 requirements.txt 文件里。但是这个 txt 文件非常令人困惑。
不像 NodeJS 那么方便，想要升、降级某个依赖版本，无法自动同步到 txt 文件里。 平铺式地列出了所有一级、二级依赖包（即依赖包的依赖包）。因为 Python 某些依赖又基于系统上安装的 C 库版本，这就导致不同系统环境上执行 pip install -r requirements.txt 得到的效果并不一致，经常报错。 打包部署问题 Python 一般使用 wheel 打包二进制，它只解决打包问题，环境依赖是靠 pip 和 setuptools 完成，所以使用 wheel 你仍然要操心环境隔离和依赖管理问题。"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-19T08:05:27+08:00"><meta property="article:modified_time" content="2023-01-19T08:05:27+08:00"><meta property="article:tag" content="Python"><meta property="og:image" content="https://sund.site/images/share.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sund.site/images/share.png"><meta name=twitter:title content="Python 依赖管理工具的研究"><meta name=twitter:description content="太长不读 如果你从事工程项目，poetry 是目前最好的方案，但是如果你不喜欢 Python 的 virtualenv，可以试试 pdm。
混乱的 Python Python 的依赖管理工具 pip 一直被众多开发者吐槽。从我个人角度，pip 有三点致命缺陷：
无法解决 Python 依赖环境的隔离问题 依赖管理文件 requirements.txt 无法真正开箱即用 打包部署非常麻烦，需要手动配置 环境隔离问题 Python 的依赖库可以安装到系统全局，也可以安装到用户目录（/home/${USER}/.local）。但如果你同时管理多个 Python 项目，就需要将不同项目的依赖拆分到不同的文件夹分开管理。
传统方式是基于 virtualenv 创建隔离的 Python bin 文件和项目依赖的虚拟环境（所谓虚拟环境并不是虚拟机，只是个绑定 terminal session 的命令环境）。这种方式的缺点是：
开发者需要经常关注“我现在处于哪个项目目录？我需要切换到当前虚拟环境里吗？”之类的问题。 virtualenv 只解决环境隔离，但是无法同步更新依赖文件、打包发布。 依赖安装问题 Python 管理依赖的手段，最早是手动执行pip install xxx来安装依赖，最后 pip freeze 来导出依赖列表到一个 requirements.txt 文件里。但是这个 txt 文件非常令人困惑。
不像 NodeJS 那么方便，想要升、降级某个依赖版本，无法自动同步到 txt 文件里。 平铺式地列出了所有一级、二级依赖包（即依赖包的依赖包）。因为 Python 某些依赖又基于系统上安装的 C 库版本，这就导致不同系统环境上执行 pip install -r requirements.txt 得到的效果并不一致，经常报错。 打包部署问题 Python 一般使用 wheel 打包二进制，它只解决打包问题，环境依赖是靠 pip 和 setuptools 完成，所以使用 wheel 你仍然要操心环境隔离和依赖管理问题。"><meta itemprop=name content="Python 依赖管理工具的研究"><meta itemprop=description content="太长不读 如果你从事工程项目，poetry 是目前最好的方案，但是如果你不喜欢 Python 的 virtualenv，可以试试 pdm。
混乱的 Python Python 的依赖管理工具 pip 一直被众多开发者吐槽。从我个人角度，pip 有三点致命缺陷：
无法解决 Python 依赖环境的隔离问题 依赖管理文件 requirements.txt 无法真正开箱即用 打包部署非常麻烦，需要手动配置 环境隔离问题 Python 的依赖库可以安装到系统全局，也可以安装到用户目录（/home/${USER}/.local）。但如果你同时管理多个 Python 项目，就需要将不同项目的依赖拆分到不同的文件夹分开管理。
传统方式是基于 virtualenv 创建隔离的 Python bin 文件和项目依赖的虚拟环境（所谓虚拟环境并不是虚拟机，只是个绑定 terminal session 的命令环境）。这种方式的缺点是：
开发者需要经常关注“我现在处于哪个项目目录？我需要切换到当前虚拟环境里吗？”之类的问题。 virtualenv 只解决环境隔离，但是无法同步更新依赖文件、打包发布。 依赖安装问题 Python 管理依赖的手段，最早是手动执行pip install xxx来安装依赖，最后 pip freeze 来导出依赖列表到一个 requirements.txt 文件里。但是这个 txt 文件非常令人困惑。
不像 NodeJS 那么方便，想要升、降级某个依赖版本，无法自动同步到 txt 文件里。 平铺式地列出了所有一级、二级依赖包（即依赖包的依赖包）。因为 Python 某些依赖又基于系统上安装的 C 库版本，这就导致不同系统环境上执行 pip install -r requirements.txt 得到的效果并不一致，经常报错。 打包部署问题 Python 一般使用 wheel 打包二进制，它只解决打包问题，环境依赖是靠 pip 和 setuptools 完成，所以使用 wheel 你仍然要操心环境隔离和依赖管理问题。"><meta itemprop=datePublished content="2023-01-19T08:05:27+08:00"><meta itemprop=dateModified content="2023-01-19T08:05:27+08:00"><meta itemprop=wordCount content="250"><meta itemprop=image content="https://sund.site/images/share.png"><meta itemprop=keywords content="Python"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width-max:720px;--font-primary:Verdana, sans-serif;--font-secondary:monospace;--font-size-primary:1em;--font-size-secondary:0.8em;--body-bg-color:#fcfcfc;--bold-text-color:#222;--body-text-color:#444;--link-color:#3273dc;--link-visited-color:#8b6fcb;--table-border-color:#f2f2f2;--table-th-bg-color:#f2f2f2;--img-border-color:#f2f2f2;--code-bg-color:#f2f2f2;--code-text-color:#222;--blockquote-border-color:#666;--blockquote-text-color:#666;--upvoted-color:#FA8072}@media(prefers-color-scheme:dark){:root{--body-bg-color:#1c1c1c;--bold-text-color:#eee;--body-text-color:#ddd;--link-color:#8cc2dd;--link-visited-color:#c3b1ee;--table-border-color:#999;--table-th-bg-color:#999;--img-border-color:#999;--code-bg-color:#555;--code-text-color:#ddd;--blockquote-border-color:#ccc;--blockquote-text-color:#ccc}}body{font-family:var(--font-primary);font-size:var(--font-size-primary);margin:auto;padding:20px;max-width:var(--width-max);text-align:left;background-color:var(--body-bg-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--body-text-color)}h1,h2,h3,h4,h5,h6,strong,b{color:var(--bold-text-color)}h1,h2,h3,h4,h5,h6{margin:16px 0}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}.title{text-decoration:none;border:0}.title:hover{text-decoration:none}.title span{font-weight:400}nav a{margin-right:8px}textarea{width:100%;font-size:16px}input{font-size:14px}content{line-height:1.6}table{width:100%;border-collapse:collapse;border:1px solid var(--table-border-color);border-radius:4px}th,td{border:1px solid var(--table-border-color);padding:4px}th{background-color:var(--table-th-bg-color)}hr{border:0;border-top:1px dashed}img{max-width:100%;display:block;margin-left:auto;margin-right:auto;border:1px solid var(--img-border-color);border-radius:4px;content-visibility:auto;loading:lazy}img[src*="#minipic"]{max-width:50%;margin-left:0;margin-right:auto}i{font-style:normal}time{font-family:var(--font-secondary);font-size:15px}code{font-family:var(--font-secondary);background-color:var(--code-bg-color);color:var(--code-text-color);padding:2px;border-radius:4px}pre code{display:block;padding:16px;white-space:pre-wrap;overflow-x:auto}div.highlight pre{border-radius:4px}div.highlight code{background-color:var(--code-bg-color);color:var(--code-text-color)}blockquote{border-left:2px solid var(--blockquote-border-color);color:var(--blockquote-text-color);margin:0;padding-left:16px;font-style:normal}blockquote p{margin:0}footer{padding:25px 0;text-align:center;font-size:var(--font-size-secondary)}ul li:has(input){list-style-type:none;margin-left:-25.5px}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li span.grouped{flex:0 0 80px}ul.blog-posts li a:visited{color:var(--link-visited-color)}div.toc{position:fixed;top:50%;left:calc((100vw + var(--width-max))/2);transform:translateY(-50%);width:calc((90vw - var(--width-max))/2);max-height:80vh;overflow-y:auto;padding:20px 8px;z-index:99;&::-webkit-scrollbar { display:none; } -ms-overflow-style:none;scrollbar-width:none}div.toc ul{list-style-type:none;padding-left:0}div.toc ul li{margin:8px 0}div.toc ul li a{text-decoration:none;color:var(--blockquote-text-color)}div.toc ul li a:hover{color:var(--link-color)}button.upvote-btn{margin:0;padding:0;border:none;background:0 0;cursor:pointer;display:flex;flex-direction:column;align-items:center;color:var(--body-text-color)}button.upvoted{color:var(--upvoted-color)}span.upvote-count{margin-top:-4px;font-size:smaller}@media(max-width:500px){img[src*="#minipic"]{max-width:100%;margin-left:auto;margin-right:auto}div.toc{display:none}}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-XJJVVQ0LBH"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XJJVVQ0LBH")</script></head><body><header><a href=/ class=title><h1>Steve Sun</h1></a><nav><a href=/>Home</a>
<a href=/friends/>Friends</a>
<a href=/posts/>Posts</a></nav></header><main><content><h2 id=太长不读>太长不读</h2><p>如果你从事工程项目，<a href=https://python-poetry.org/>poetry</a> 是目前最好的方案，但是如果你不喜欢 Python 的 virtualenv，可以试试 <a href=https://pdm.fming.dev/latest/>pdm</a>。</p><h2 id=混乱的-python>混乱的 Python</h2><p>Python 的依赖管理工具 <code>pip</code> 一直被众多开发者吐槽。从我个人角度，<code>pip</code> 有三点致命缺陷：</p><ul><li>无法解决 Python 依赖环境的隔离问题</li><li>依赖管理文件 <code>requirements.txt</code> 无法真正开箱即用</li><li>打包部署非常麻烦，需要手动配置</li></ul><h3 id=环境隔离问题>环境隔离问题</h3><p>Python 的依赖库可以安装到系统全局，也可以安装到用户目录（<code>/home/${USER}/.local</code>）。但如果你同时管理多个 Python 项目，就需要将不同项目的依赖拆分到不同的文件夹分开管理。</p><p>传统方式是基于 virtualenv 创建隔离的 Python bin 文件和项目依赖的虚拟环境（所谓虚拟环境并不是虚拟机，只是个绑定 terminal session 的命令环境）。这种方式的缺点是：</p><ul><li>开发者需要经常关注“我现在处于哪个项目目录？我需要切换到当前虚拟环境里吗？”之类的问题。</li><li>virtualenv 只解决环境隔离，但是无法同步更新依赖文件、打包发布。</li></ul><h3 id=依赖安装问题>依赖安装问题</h3><p>Python 管理依赖的手段，最早是手动执行<code>pip install xxx</code>来安装依赖，最后 <code>pip freeze</code> 来导出依赖列表到一个 <code>requirements.txt</code> 文件里。但是这个 txt 文件非常令人困惑。</p><ul><li>不像 NodeJS 那么方便，想要升、降级某个依赖版本，无法自动同步到 txt 文件里。</li><li>平铺式地列出了所有一级、二级依赖包（即依赖包的依赖包）。因为 Python 某些依赖又基于系统上安装的 C 库版本，这就导致不同系统环境上执行 <code>pip install -r requirements.txt</code> 得到的效果并不一致，经常报错。</li></ul><h3 id=打包部署问题>打包部署问题</h3><p>Python 一般使用 <code>wheel</code> 打包二进制，它只解决打包问题，环境依赖是靠 pip 和 setuptools 完成，所以使用 wheel 你仍然要操心环境隔离和依赖管理问题。</p><p>另外基于 Python 各版本之间兼容性问题和底层实现上的不可抗拒力量，wheel 也经常会莫名其妙失败。</p><h2 id=现有的解决方案>现有的解决方案</h2><p>一直以来，出现过 <code>pipx</code>，<code>pipenv</code>， <code>conda</code>，<code>poetry</code> 以及我最近接触的 <code>pdm</code>。他们都在某种程度上解决了 Python 的问题，这篇文章：</p><p><a href=https://chriswarrick.com/blog/2023/01/15/how-to-improve-python-packaging>How to improve Python packaging, or why fourteen tools are at least twelve too many</a></p><p>对比了各种工具的利弊。最后得出结论是 poetry 和 pdm 是目前最合适的工具。而 pdm 是目前唯一支持 <a href=https://peps.python.org/pep-0582/>PEP 582</a> 的依赖管理工具。</p><h3 id=什么是-pep-582>什么是 PEP 582</h3><blockquote><p>This PEP proposes to add to Python a mechanism to automatically recognize a <code>__pypackages__</code> directory and prefer importing packages installed in this location over user or global site-packages. This will avoid the steps to create, activate or deactivate “virtual environments”. Python will use the <code>__pypackages__</code> from the base directory of the script when present.</p></blockquote><p>这个 PEP 的目的就是基于一个文件夹 <code>__pypackages__ </code>来管理 Python 的依赖，类似 nodejs 的<code>node_modules</code>，用户不需要再创建虚拟环境来隔离依赖包。Python 会自动识别和安装依赖。</p><blockquote><p>更新于 2023 年 7 月 2 日：PEP 582 提案已经被拒绝，PDM 暂时仍然支持，但是不建议开发者使用这一特性。</p></blockquote><h3 id=pdm>PDM</h3><p>PDM 实现了 PEP 582！这让我们在解决 Python 依赖问题时不用再考虑虚拟环境。</p><h4 id=初始化项目>初始化项目</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pdm init
</span></span></code></pre></div><p>之后 PDM 会问几个问题，记得选择<strong>不使用虚拟机环境</strong>，这样 PDM 就会默认使用 PEP 582 的解决方案，在项目下生成一个类似 NodeJS 的 <code>__pypackages__</code>。</p><p>剩下的操作就跟 NodeJS 的 npm 非常像了。</p><p>添加一个依赖之后，PDM 会自动更新<code>pyproject.toml</code>文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pdm add requests
</span></span></code></pre></div><h4 id=安装项目依赖>安装项目依赖</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pdm install
</span></span></code></pre></div><h4 id=启动项目>启动项目</h4><p>先在 <code>pyproject.toml</code>里添加</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#f92672>[</span>tool.pdm.scripts<span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>start <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;flask run -p 54321&#34;</span>
</span></span></code></pre></div><p>然后执行</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pdm run start
</span></span></code></pre></div><h4 id=打包部署>打包部署</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>pdm build
</span></span><span style=display:flex><span>pdm publish
</span></span></code></pre></div><h2 id=总结>总结</h2><p>如果你从事科研工作，用 <code>conda</code>。</p><p>如果你从事工程项目，<code>poetry</code>是目前业内用的最多的方案，大多数情况下它是个不错的依赖管理工具。但是如果你不喜欢 Python 的 virtualenv，<code>pdm</code>是更好的选择。</p></content><p><a href=https://sund.site/tags/python/>#Python</a></p><div class=toc><nav id=TableOfContents><ul><li><a href=#太长不读>太长不读</a></li><li><a href=#混乱的-python>混乱的 Python</a><ul><li><a href=#环境隔离问题>环境隔离问题</a></li><li><a href=#依赖安装问题>依赖安装问题</a></li><li><a href=#打包部署问题>打包部署问题</a></li></ul></li><li><a href=#现有的解决方案>现有的解决方案</a><ul><li><a href=#什么是-pep-582>什么是 PEP 582</a></li><li><a href=#pdm>PDM</a><ul><li><a href=#初始化项目>初始化项目</a></li><li><a href=#安装项目依赖>安装项目依赖</a></li><li><a href=#启动项目>启动项目</a></li><li><a href=#打包部署>打包部署</a></li></ul></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></main><footer>Subscribe via <a href=/index.xml>RSS</a>.<br>Made with
<a href=https://github.com/rokcso/hugo-bearblog-neo/>Hugo Bear Neo</a>.<br>Copyright © 2013-2025, Steve Sun.
🗺️ <a href=/sitemap.xml>Sitemap</a>.</footer></body></html>