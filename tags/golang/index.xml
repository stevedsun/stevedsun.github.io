<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>golang - Tag - 電波障害</title><link>https://sund.site/tags/golang/</link><description>golang - Tag - 電波障害</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Sun, 08 May 2022 14:00:00 +0800</lastBuildDate><atom:link href="https://sund.site/tags/golang/" rel="self" type="application/rss+xml"/><item><title>Building A File Parser</title><link>https://sund.site/posts/2022/2022-5-8_lexer_design/</link><pubDate>Sun, 08 May 2022 14:00:00 +0800</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2022/2022-5-8_lexer_design/</guid><description><![CDATA[<p>Last week, after reading this article - <a href="https://www.aaronraff.dev/blog/how-to-write-a-lexer-in-go" target="_blank" rel="noopener noreffer ">How to Write a Lexer in Go</a>, I found that it is not so difficult to design a configuration file parser by this article&rsquo;s mind-set. Then I tried to write a fluent-bit configuration parser, finally got this <a href="https://github.com/stevedsun/go-fluentbit-conf-parser" target="_blank" rel="noopener noreffer ">Fluent-Bit configuration parser for Golang</a>.</p>
<p>In this article, I want to introduce how to parse Fluent-bit configuration <code>.conf</code> file, and the thinking behind it.</p>
<h2 id="fluent-bit-configuration-format-and-schema">Fluent-bit configuration format and schema</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[FIRST_SECTION]
    Key1  some value
    Key2  another value

[SECOND_SECTION]
    KeyN  3.14
</code></pre></td></tr></table>
</div>
</div><p>Here is a classic mode configuration of Fluent-bit, it includes two parts:</p>
<ul>
<li>Section</li>
<li>Key/value pair</li>
</ul>
<p>First of all, we need to define a struct which represents the Fluent-bit configuration file.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">FluentBitConf</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Sections</span> <span class="p">[]</span><span class="nx">Section</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Section</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Name</span>    <span class="kt">string</span>
	<span class="nx">Entries</span> <span class="p">[]</span><span class="nx">Entry</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Entry</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Key</span>   <span class="kt">string</span>
	<span class="nx">Value</span> <span class="kd">interface</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>Once we have a struct, the next step is to parse tokens from the file and save their values into golang struct. We can copy the logic of the lexer to develop our fluentbit parser.</p>
<p>In a lexer program, the target characters which we want to parse out are called &ldquo;Token&rdquo;, Token is also the keyword that our parser program is searching for. A parser program will read characters in a file one by one, whenever it found a token, the parser saves the value between tokens into the final structure and go ahead.</p>
<h2 id="parse-a-single-token">Parse a single token</h2>
<p>If we want to parse Section, we have to make the parser read characters one by one and stop at <code>[</code> character, which means the beginning of a Section. The parser must save the current state as <code>t_section</code> and keep parser reading until <code>]</code> character, the word between <code>[</code> and <code>]</code> is the Section value we need to persist into go struct.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go">
<span class="c1">// define some tag to tell parser state
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">t_section</span> <span class="p">=</span> <span class="kc">iota</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">parser</span> <span class="o">*</span><span class="nx">FluentBitConfParser</span><span class="p">)</span> <span class="nf">Parse</span><span class="p">()</span> <span class="o">*</span><span class="nx">FluentBitConf</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">currSection</span> <span class="o">*</span><span class="nx">Section</span> <span class="p">=</span> <span class="kc">nil</span>

	<span class="k">for</span> <span class="p">{</span>
        <span class="c1">// read charector one by one
</span><span class="c1"></span>		<span class="nx">r</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">reader</span><span class="p">.</span><span class="nf">ReadRune</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="c1">// stop at the end of file
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">currSection</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
					<span class="nx">parser</span><span class="p">.</span><span class="nx">Conf</span><span class="p">.</span><span class="nx">Sections</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parser</span><span class="p">.</span><span class="nx">Conf</span><span class="p">.</span><span class="nx">Sections</span><span class="p">,</span> <span class="o">*</span><span class="nx">currSection</span><span class="p">)</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">Conf</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">Conf</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="nx">r</span> <span class="p">{</span>
		<span class="k">case</span> <span class="sc">&#39;\n&#39;</span><span class="p">:</span>
			<span class="k">continue</span>
		<span class="k">case</span> <span class="sc">&#39;[&#39;</span><span class="p">:</span>
			<span class="c1">// save last config item
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">currSection</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">parser</span><span class="p">.</span><span class="nx">Conf</span><span class="p">.</span><span class="nx">Sections</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">parser</span><span class="p">.</span><span class="nx">Conf</span><span class="p">.</span><span class="nx">Sections</span><span class="p">,</span> <span class="o">*</span><span class="nx">currSection</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="c1">// create new config item
</span><span class="c1"></span>			<span class="nx">currSection</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Section</span><span class="p">{</span>
				<span class="nx">Name</span><span class="p">:</span>    <span class="s">&#34;&#34;</span><span class="p">,</span>
				<span class="nx">Entries</span><span class="p">:</span> <span class="p">[]</span><span class="nx">Entry</span><span class="p">{},</span>
			<span class="p">}</span>
			<span class="nx">parser</span><span class="p">.</span><span class="nx">token</span> <span class="p">=</span> <span class="nx">t_section</span>
		<span class="k">default</span><span class="p">:</span>
			<span class="k">if</span> <span class="nx">unicode</span><span class="p">.</span><span class="nf">IsSpace</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>

            <span class="c1">// here is important function, read the charectors after token-chareactor and save them into struct
</span><span class="c1"></span>			<span class="nx">strValue</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">parser</span><span class="p">.</span><span class="nf">parseString</span><span class="p">()</span>
			<span class="k">switch</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">token</span> <span class="p">{</span>
			<span class="k">case</span> <span class="nx">t_section</span><span class="p">:</span>
				<span class="nx">currSection</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="nx">strValue</span>
				<span class="nx">parser</span><span class="p">.</span><span class="nx">token</span> <span class="p">=</span> <span class="nx">t_entry_key</span>
		<span class="p">}</span>

	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>In function <code>parser.parseString()</code>, we have to read until the end of a value (for section, it&rsquo;s <code>]</code>), then return the value.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">parser</span> <span class="o">*</span><span class="nx">FluentBitConfParser</span><span class="p">)</span> <span class="nf">parseString</span><span class="p">()</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">val</span> <span class="kt">string</span> <span class="p">=</span> <span class="s">&#34;&#34;</span>

	<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">reader</span><span class="p">.</span><span class="nf">UnreadRune</span><span class="p">();</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="nx">r</span><span class="p">,</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">reader</span><span class="p">.</span><span class="nf">ReadRune</span><span class="p">()</span>
		<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">err</span> <span class="o">==</span> <span class="nx">io</span><span class="p">.</span><span class="nx">EOF</span> <span class="p">{</span>
				<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">nil</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="nx">err</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nx">parser</span><span class="p">.</span><span class="nx">token</span> <span class="o">==</span> <span class="nx">t_section</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span> <span class="o">==</span> <span class="sc">&#39;]&#39;</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nx">val</span><span class="p">,</span> <span class="kc">nil</span>
		<span class="p">}</span>

		<span class="nx">val</span> <span class="p">=</span> <span class="nx">val</span> <span class="o">+</span> <span class="nb">string</span><span class="p">(</span><span class="nx">r</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>That&rsquo;s all logic for parsing a section. To parse key/value pair is the same process, just note to make parser know which state it is and save values between whitespace or <code>\n</code>, you can see the code at <a href="https://github.com/stevedsun/go-fluentbit-conf-parser/blob/master/parser.go" target="_blank" rel="noopener noreffer ">the github repo</a>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>To parse a configuration file, we have to</p>
<ul>
<li>Defining token (key characters)</li>
<li>Reading characters and looking for a token</li>
<li>Saving current state to tell parser which struct the following characters belong</li>
</ul>
]]></description></item></channel></rss>