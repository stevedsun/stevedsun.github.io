<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>分布式 on Steve Sun</title><link>https://sund.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/</link><description>Recent content in 分布式 on Steve Sun</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 18 Mar 2021 15:32:57 +0800</lastBuildDate><atom:link href="https://sund.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>分布式缓存系统的设计</title><link>https://sund.site/posts/2021/distributed-cache/</link><pubDate>Thu, 18 Mar 2021 15:32:57 +0800</pubDate><guid>https://sund.site/posts/2021/distributed-cache/</guid><description>很久不写技术文章了。这是一篇关于 Redis 构建分布式缓存系统的总结，结合之前项目上的使用场景，做一个系统性的梳理。
下面就以我做过的商品预约平台项目作为引子，引出分布式缓存设计的一些要点。
该商品预约平台的背景如下：
该系统由多个微服务组成 预约的过程：用户可以选择指定门店，指定日期到店提领商品，如果对应门店和日期没有库存，则不能预约 因为“预约”的是未来时刻的库存，所以门店的未来某个时间剩余库存是通过一系列公式计算得出的。这个公式比较复杂，考虑到了用户指定的日期是否在配货周期内等因素，这里省略掉细节 每年节日高峰时期，用户会集中预约商品，导致服务压力骤增。又因为未来日期的库存需要动态计算的特点（比如 A 预约了 1 月 1 日的最后一件商品，B 就会无法在该日预约），不同用户的预约操作会互相影响，严重时导致数据库死锁、数据不一致等问题 基于以上背景，这个预约系统的设计必须将性能作为主要优化目标，而缓存作为性能优化的不二选择，就承担了重要职责。
识别热点数据 并不是所有数据都有必要被缓存，往往缓存的数据具有以下几个特点：
读写比很高。如果写操作比读操作还多，缓存系统频繁更新会大大降低可用性 是热点数据。因为内存的价格昂贵，所以按照 2-8 原则，20%热点数据才值得被缓存 能够容忍短时间的不一致 结合项目需要，排除掉一些不适合缓存的数据：
对于那些只读的、配置相关的数据，只需要做进程缓存（使用 Guava Cache），在服务启动时加载数据到内存就可以了 尽量用 CDN 和 Nginx 静态缓存来解决大部分不常更新的资源 对于该预约项目，用户最频繁查询的数据是不同门店在不同日期下的库存数量。这类数据是缓存设计的重点照顾对象：
用户选择了指定城市、指定门店后，系统会返回最近 30 天的库存信息，用户只可能修改其中一条信息。所以读写比很高 库存信息是预约订单流程的必备步骤，而且是跨服务调用（预约服务 -&amp;gt; 库存服务）的数据，所以涉及到大量网络请求、数据库查询。 指定性能优化的指标 在即将完成业务系统开发时，我们就根据 Google SRE Books 提到的四个黄金指标，制定了监控系统性能的四个维度：
请求率 错误数，非 200 返回结果数量 响应时间 资源利用率（CPU、内存） 我们使用 Prometheus + Grafana 的组合实现监控可视化，这样每次测试人员进行压力测试时，都可以通过这些指标对系统进行调整。缓存影响最大的指标是请求率（一般用 TPS 或者 QPS）和响应时间。所以在设计缓存系统时，要不断参照这两个指标进行优化。
缓存的设计的实践 分级缓存 为了不让某一接口或者微服务的缓存失效导致其他接口或服务的并发量暴增，就要针对不同来源（数据库的表、接口等）的数据做分级缓存。比如用户在一次查询中涉及到“附近可预约门店”的查询、“活动期间不同日期剩余库存”的查询、“已预约数量“的查询，这三种查询逐层依赖后边的查询结果。
假设如果只针对库存数量做缓存，一旦这部分缓存失效，那么“附近可预约门店”的查询就会直接访问数据库查询全部门店的剩余库存来确定哪个门店可以预约。这样就导致查询库存的接口并发量骤增。所以分级缓存一定程度上缓解了缓存雪崩的问题。
自动化测试 API 参数合法性 我们的 QA 通常会写自动化脚本对后端 API 做定期的扫描，检查哪些接口的数据输入、输出有不合法的类型或是数值范围。除了巩固系统的健壮性，还能帮助缓存系统抵御缓存穿透的风险。</description></item></channel></rss>