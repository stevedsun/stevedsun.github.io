<!doctype html><html lang=zh><head><meta charset=utf-8><title>电波障害</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="总结一下yield关键字在C层面是如何实现的"><meta property="og:title" content="Python yield关键字的底层实现"><meta property="og:description" content="总结一下yield关键字在C层面是如何实现的"><meta property="og:type" content="website"><meta property="og:url" content="https://sund.site/posts/2016/12/python-yield%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"><meta itemprop=name content="Python yield关键字的底层实现"><meta itemprop=description content="总结一下yield关键字在C层面是如何实现的"><meta name=twitter:card content="summary"><meta name=twitter:title content="Python yield关键字的底层实现"><meta name=twitter:description content="总结一下yield关键字在C层面是如何实现的"><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=favicon-32.png><link rel=stylesheet href=https://sund.site/scss/style.min.d3753708bd00a3fa8abf275247a06b76c6984dfc5688dcb559cb98c7ffbbdf5e.css></head><body><header><div class="header header-frame"><div><h1 class=header__title>Python yield关键字的底层实现</h1><div class=header__description>总结一下yield关键字在C层面是如何实现的</div></div><nav class=header-nav><ul class="header-nav-list header-nav-list--menu"><li class=header-nav-list__item><a class=header-nav-list__link href=/about/><span>About</span></a></li></ul><button class=header-nav-list__nav-btn>navigation</button></nav><button class=mb-header__menu-btn>
<span class=mb-header__menu-btn-line></span><span class=mb-header__menu-btn-line></span><span class=mb-header__menu-btn-line></span></button></div><nav id=mobile-header-nav class=mb-header-nav><button class="mb-header-nav__close-btn flex-center"><svg class="mb-header-nav__svg-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/><path d="M0 0h24v24H0z" fill="none"/></svg></button><div class=mb-header-nav__wrapper><div class=mb-header-nav__container><svg width="240" height="72" viewBox="0 0 240 72" class="mb-header-nav__title"><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">Tags</text></svg><ul class=mb-header-nav-list><li class=mb-header-nav-list__item><a class=mb-header-nav-list__link href=https://sund.site/tags/python/>python</a></li></ul></div><div class=mb-header-nav__container><svg width="240" height="72" viewBox="0 0 240 72" class="mb-header-nav__title"><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">Menu</text></svg><ul class=mb-header-nav-list><li class=mb-header-nav-list__item><a class=mb-header-nav-list__link href=/about/>About</a></li></ul></div></div></nav></header><div id=content><article class=post><div class=post-content><p>这几天面试被问到类似的问题，顺便看了看Python的源码，参考网上的教程，总结一下yield关键字在C层面是如何实现的。</p><h2 id=举个栗子>举个栗子</h2><p>我们先看一个python生成器函数的例子：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#000;font-weight:700>from</span> <span style=color:#555>dis</span> <span style=color:#000;font-weight:700>import</span> dis

<span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>func</span>():
    i <span style=color:#000;font-weight:700>=</span> <span style=color:#099>4</span>
    <span style=color:#000;font-weight:700>yield</span> i
    <span style=color:#000;font-weight:700>print</span> i
    
dis(func)
a <span style=color:#000;font-weight:700>=</span>func()
a<span style=color:#000;font-weight:700>.</span>next()
a<span style=color:#000;font-weight:700>.</span>next()
</code></pre></div><p>使用python的库dis可以直接查看python虚拟机运行的字节码。<code>dis(func)</code>的打印如下：</p><pre><code>  6           0 LOAD_CONST               1 (4)
              3 STORE_FAST               0 (i)

  7           6 LOAD_FAST                0 (i)
              9 YIELD_VALUE         
             10 POP_TOP             

  8          11 LOAD_FAST                0 (i)
             14 PRINT_ITEM          
             15 PRINT_NEWLINE       
             16 LOAD_CONST               0 (None)
             19 RETURN_VALUE      
</code></pre><p>我们猜测其中第二列(代表字节码偏移量)为9的指令<code>YIELD_VALUE</code>就是yield关键字的执行代码，进入Python2.7.12源码目录，在解释器执行字节码的主函数<code>PyEval_EvalFrameEx</code>中找到了下面一段：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>          TARGET_NOARG(YIELD_VALUE)
          {
              retval <span style=color:#000;font-weight:700>=</span> POP();
              f<span style=color:#000;font-weight:700>-&gt;</span>f_stacktop <span style=color:#000;font-weight:700>=</span> stack_pointer;
              why <span style=color:#000;font-weight:700>=</span> WHY_YIELD;
              <span style=color:#998;font-style:italic>// 跳转到fast_yield处。fast_yield里处理了一下状态位然后返回结果
</span><span style=color:#998;font-style:italic></span>              <span style=color:#000;font-weight:700>goto</span> fast_yield;
          }
</code></pre></div><p>其中<code>TARGET_NOARG</code>为封装了<code>case</code>语句的宏，这句话的意思是，如果字节码是<code>YIELD_VALUE</code>，就把栈顶元素赋值给<code>retval</code>，然后跳转到<code>fast_yield</code>处，<code>fast_yield</code>处代码进行了一些状态判断后直接返回了<code>retval</code>。</p><h2 id=生成器是如何记录代码返回位置的>生成器是如何记录代码返回位置的</h2><p>显然，如果这时候调用代码<code>a.next()</code>就会直接返回yield后边的表达式结果。这对应了上面C代码的<code>fast_yield</code>部分，那生成器怎么记录上次执行的位置并在下一次调用<code>a.next()</code>的时候从上次的位置继续执行的呢？</p><p>Python在解释代码时，是将代码块加载为一个叫PyFrameObject的对象，这个对象代表了当前运行的栈帧。PyFrameObject里有个<code>f_lasti</code>变量用于保存代码当前执行到了字节码的哪个位置。在第二次执行<code>a.next()</code>时，生成器对象把之前携带了<code>f_lasti</code>的PyFrameObject当参数传给<code>PyEval_EvalFrameEx</code>，在<code>PyEval_EvalFrameEx</code>里的执行一个JUMPTO就直接跳转到了上一次结束生成器时的字节码位置：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>PyObject <span style=color:#000;font-weight:700>*</span>
<span style=color:#900;font-weight:700>PyEval_EvalFrameEx</span>(PyFrameObject <span style=color:#000;font-weight:700>*</span>f, <span style=color:#458;font-weight:700>int</span> throwflag)
{
...
<span style=color:#999;font-weight:700;font-style:italic>#define FAST_DISPATCH() \
</span><span style=color:#999;font-weight:700;font-style:italic>          { \
</span><span style=color:#999;font-weight:700;font-style:italic>      if (!lltrace &amp;&amp; !_Py_TracingPossible) { \
</span><span style=color:#999;font-weight:700;font-style:italic>          f-&gt;f_lasti = INSTR_OFFSET(); \
</span><span style=color:#999;font-weight:700;font-style:italic>          goto *opcode_targets[*next_instr++]; \
</span><span style=color:#999;font-weight:700;font-style:italic>      } \
</span><span style=color:#999;font-weight:700;font-style:italic>      </span><span style=color:#998;font-style:italic>// 跳转到fast_next_opcode处
</span><span style=color:#998;font-style:italic></span>      <span style=color:#000;font-weight:700>goto</span> fast_next_opcode; \
          }
...
<span style=color:#900;font-weight:700>fast_next_opcode</span>:
          f<span style=color:#000;font-weight:700>-&gt;</span>f_lasti <span style=color:#000;font-weight:700>=</span> INSTR_OFFSET();
  
          <span style=color:#998;font-style:italic>/* line-by-line tracing support */</span>
  
          <span style=color:#000;font-weight:700>if</span> (_Py_TracingPossible <span style=color:#000;font-weight:700>&amp;&amp;</span>
              tstate<span style=color:#000;font-weight:700>-&gt;</span>c_tracefunc <span style=color:#000;font-weight:700>!=</span> <span style=color:#0086b3>NULL</span> <span style=color:#000;font-weight:700>&amp;&amp;</span> <span style=color:#000;font-weight:700>!</span>tstate<span style=color:#000;font-weight:700>-&gt;</span>tracing) {
              ...
              <span style=color:#998;font-style:italic>/* Reload possibly changed frame fields */</span>
              <span style=color:#998;font-style:italic>// 按照f-&gt;f_lasti中的偏移量跳转字节码
</span><span style=color:#998;font-style:italic></span>              JUMPTO(f<span style=color:#000;font-weight:700>-&gt;</span>f_lasti);
}
</code></pre></div><p>其中<code>INSTR_OFFSET</code>宏正是字节码的偏移量。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#999;font-weight:700;font-style:italic>#define INSTR_OFFSET()  ((int)(next_instr - first_instr))
</span><span style=color:#999;font-weight:700;font-style:italic></span>
<span style=color:#998;font-style:italic>// co-&gt;co_code里保存的是字节码
</span><span style=color:#998;font-style:italic></span>first_instr <span style=color:#000;font-weight:700>=</span> (<span style=color:#458;font-weight:700>unsigned</span> <span style=color:#458;font-weight:700>char</span><span style=color:#000;font-weight:700>*</span>) PyString_AS_STRING(co<span style=color:#000;font-weight:700>-&gt;</span>co_code);
next_instr <span style=color:#000;font-weight:700>=</span> first_instr <span style=color:#000;font-weight:700>+</span> f<span style=color:#000;font-weight:700>-&gt;</span>f_lasti <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>;
</code></pre></div><p>所以生成器对象每次执行结束都把字节码的偏移量记录下来，并把运行状态保存在PyFrameObject里，下一次运行时生成器时，python解释器直接按照偏移量寻找下一个字节码指令。</p></div></article><button class=floating-button>
<a class=floating-button__link href=https://sund.site><span>home</span></a></button></div><footer class=post-footer><div class=footer><div>© 2021, Steve Sun</div><div class=footer__socials><a href=https://twitter.com/way2steve target=_blank class=social-link title="Twitter link" rel=noopener aria-label="follow on Twitter——Opens in a new window"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0 0v24h24V0H0zm18.862 9.237c.208 4.617-3.235 9.765-9.33 9.765-1.854.0-3.579-.543-5.032-1.475 1.742.205 3.48-.278 4.86-1.359-1.437-.027-2.649-.976-3.066-2.28.515.098 1.021.069 1.482-.056-1.579-.317-2.668-1.739-2.633-3.26.442.246.949.394 1.486.411-1.461-.977-1.875-2.907-1.016-4.383 1.619 1.986 4.038 3.293 6.766 3.43-.479-2.053 1.079-4.03 3.198-4.03.944.0 1.797.398 2.396 1.037.748-.147 1.451-.42 2.085-.796-.245.767-.766 1.41-1.443 1.816.664-.08 1.297-.256 1.885-.517-.44.656-.997 1.234-1.638 1.697z"/></svg></a><a href=https://github.com/stevedsun target=_blank class=social-link title="Github link" rel=noopener aria-label="follow on Github——Opens in a new window"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0 0v24h24V0H0zm14.534 19.59c-.406.078-.534-.171-.534-.384v-2.195c0-.747-.262-1.233-.55-1.481 1.782-.198 3.654-.875 3.654-3.947.0-.874-.311-1.588-.824-2.147.083-.202.357-1.016-.079-2.117.0.0-.671-.215-2.198.82-.639-.18-1.323-.267-2.003-.271-.68.003-1.364.091-2.003.269-1.528-1.035-2.2-.82-2.2-.82-.434 1.102-.16 1.915-.077 2.118-.512.56-.824 1.273-.824 2.147.0 3.064 1.867 3.751 3.645 3.954-.229.2-.436.552-.508 1.07-.457.204-1.614.557-2.328-.666.0.0-.423-.768-1.227-.825.0.0-.78-.01-.055.487.0.0.525.246.889 1.17.0.0.463 1.428 2.688.944v1.489c0 .211-.129.459-.528.385-3.18-1.057-5.472-4.056-5.472-7.59.0-4.419 3.582-8 8-8s8 3.581 8 8c0 3.533-2.289 6.531-5.466 7.59z"/></svg></a></div></div></footer><script src=https://sund.site/js/script.js></script></body></html>