<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on 電波障害</title><link>https://sund.site/tags/python/</link><description>Recent content in python on 電波障害</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 14 Jul 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://sund.site/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>《Python源码剖析》第三部分——Python虚拟机进阶</title><link>https://sund.site/posts/python-3/</link><pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate><guid>https://sund.site/posts/python-3/</guid><description>Python 环境初始化 进程启动后创建PyInterpreterObject，PyInterpreterObject里面维护了全局module映射表interp-&amp;gt;modules，该表默认初始化为__bui</description></item><item><title>《Python源码剖析》第二部分——Python虚拟机基础</title><link>https://sund.site/posts/python-2/</link><pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate><guid>https://sund.site/posts/python-2/</guid><description>Python执行环境 在编译过程中，这些包含在Python源代码中的静态信息都会被Python编译器收集起来，编译的结果中包含了字符串，常量值，字节码等在源代码中出现的一切有用的静态信息。在Python</description></item><item><title>《Python源码剖析》第一部分——Python对象基础</title><link>https://sund.site/posts/python/</link><pubDate>Wed, 12 Jul 2017 00:00:00 +0000</pubDate><guid>https://sund.site/posts/python/</guid><description>Python的对象初始化 在Python中，对象就是为C中的结构体在堆上申请的一块内存，一般来说，对象是不能被静态初始化的，并且也不能在栈空间上生存。唯一的例外就是类型对象，Python中所有的内建的类</description></item><item><title>Python2 中字符类型的一些坑</title><link>https://sund.site/posts/py-str/</link><pubDate>Wed, 11 Jan 2017 11:09:00 +0000</pubDate><guid>https://sund.site/posts/py-str/</guid><description>问题 有一道面试题是这样的： a = u&amp;#39;China&amp;#39; b = &amp;#39;China&amp;#39; c = u&amp;#39;中国&amp;#39; d = &amp;#39;中国&amp;#39; # 1 print &amp;#39;%s%s&amp;#39; % (a, b) # 2 print &amp;#39;%s&amp;#39; % c # 3 print &amp;#39;%s&amp;#39; % d # 4 print &amp;#39;%s%s&amp;#39; % (c, d) 判断打印后的效果。 先说正确答案，只有最后一行会报错。</description></item><item><title>Python yield关键字的底层实现</title><link>https://sund.site/posts/py-yield/</link><pubDate>Wed, 28 Dec 2016 18:00:00 +0000</pubDate><guid>https://sund.site/posts/py-yield/</guid><description>这几天面试被问到类似的问题，顺便看了看Python的源码，参考网上的教程，总结一下yield关键字在C层面是如何实现的。 举个栗子 我们先看一个python生成器函数的例子： from dis import dis def func(): i = 4 yield i print i dis(func) a</description></item><item><title>Python 巧妙地将rpc接口封装成pythonic的链式调用</title><link>https://sund.site/posts/py-pythonic/</link><pubDate>Tue, 25 Oct 2016 15:40:43 +0000</pubDate><guid>https://sund.site/posts/py-pythonic/</guid><description>这是一个外国人实现的Zabbix(一个开源监控工具)的Python Client——pyzabbix里的代码片段。 RPC调用 Rpc调用的流程是向rpc服务端指定的uri(如http://www.abc.</description></item><item><title>Python Fabric库无法启动后台进程的问题和解决办法</title><link>https://sund.site/posts/py-fabric/</link><pubDate>Wed, 19 Oct 2016 16:25:51 +0000</pubDate><guid>https://sund.site/posts/py-fabric/</guid><description>问题和处理方法 Python 的 Fabric 库能够方便的远程操作Linux主机执行命令或传输文件。其实现方式就是底层实现ssh协议，例如执行下面代码的run方法，在目标主机上启动一个zabbix后台服务： from fabric import api from fabric.tasks import Task class Zabbix(Task):</description></item><item><title>Python defaultdict结构作计数器的用法</title><link>https://sund.site/posts/py-defaultdict/</link><pubDate>Tue, 11 Oct 2016 15:00:16 +0000</pubDate><guid>https://sund.site/posts/py-defaultdict/</guid><description>在开发中经常需要用到计数器，当函数foo调用另一个函数bar时，为了确认调用bar之后处理的结果正确性，经常需要使用计数器来统计bar函数里处理成功了多少次。例如： def foo(): success_num = bar() print success_num def bar(): n = 0 # 假设这个任</description></item></channel></rss>