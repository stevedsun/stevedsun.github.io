<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>《Python源码剖析》第二部分——Python虚拟机基础 - 電波障害</title><meta name=Description content="電波障害 - Steve Sun's Blog"><meta property="og:title" content="《Python源码剖析》第二部分——Python虚拟机基础"><meta property="og:description" content="Python执行环境 在编译过程中，这些包含在Python源代码中的静态信息都会被Python编译器收集起来，编译的结果中包含了字符串，常量值"><meta property="og:type" content="article"><meta property="og:url" content="https://sund.site/posts/2017/python-2/"><meta property="og:image" content="https://sund.site/android-chrome-192x192.png"><meta property="article:published_time" content="2017-07-13T00:00:00+00:00"><meta property="article:modified_time" content="2017-07-13T00:00:00+00:00"><meta property="og:site_name" content="電波障害"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sund.site/android-chrome-192x192.png"><meta name=twitter:title content="《Python源码剖析》第二部分——Python虚拟机基础"><meta name=twitter:description content="Python执行环境 在编译过程中，这些包含在Python源代码中的静态信息都会被Python编译器收集起来，编译的结果中包含了字符串，常量值"><meta name=application-name content="電波障害"><meta name=apple-mobile-web-app-title content="電波障害"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://sund.site/posts/2017/python-2/><link rel=prev href=https://sund.site/posts/2017/python/><link rel=next href=https://sund.site/posts/2017/python-3/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"《Python源码剖析》第二部分——Python虚拟机基础","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/sund.site\/posts\/2017\/python-2\/"},"image":["https:\/\/sund.site\/android-chrome-192x192.png"],"genre":"posts","keywords":"python","wordcount":4115,"url":"https:\/\/sund.site\/posts\/2017\/python-2\/","datePublished":"2017-07-13T00:00:00+00:00","dateModified":"2017-07-13T00:00:00+00:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"Steve Sun","logo":"https:\/\/sund.site\/android-chrome-192x192.png"},"author":{"@type":"Person","name":"Steve Sun"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=電波障害><img class="lazyload logo" src=/svg/loading.min.svg data-src=/android-chrome-192x192.png data-srcset="/android-chrome-192x192.png, /android-chrome-192x192.png 1.5x, /android-chrome-192x192.png 2x" data-sizes=auto alt=/android-chrome-192x192.png title=/android-chrome-192x192.png>電波障害</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>Posts </a><a class=menu-item href=/tags/>Tags </a><a class=menu-item href=/about/>About </a><a class=menu-item href=https://github.com/stevedsun title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw" aria-hidden=true></i></a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=電波障害><img class="lazyload logo" src=/svg/loading.min.svg data-src=/android-chrome-192x192.png data-srcset="/android-chrome-192x192.png, /android-chrome-192x192.png 1.5x, /android-chrome-192x192.png 2x" data-sizes=auto alt=/android-chrome-192x192.png title=/android-chrome-192x192.png>電波障害</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/>Posts</a><a class=menu-item href=/tags/>Tags</a><a class=menu-item href=/about/>About</a><a class=menu-item href=https://github.com/stevedsun title=GitHub rel="noopener noreffer" target=_blank><i class="fab fa-github fa-fw" aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>Contents</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">《Python源码剖析》第二部分——Python虚拟机基础</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://sund.site/about/ title=Author target=_blank rel="noopener noreffer author" class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>Steve Sun</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2017-07-13>2017-07-13</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;4115 words&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;9 minutes&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#python执行环境>Python执行环境</a></li><li><a href=#legb-规则>LEGB 规则</a></li><li><a href=#python-虚拟机运行框架>Python 虚拟机运行框架</a></li><li><a href=#python字节码>Python字节码</a></li><li><a href=#python-的异常抛出机制>Python 的异常抛出机制</a></li><li><a href=#函数对象的实现>函数对象的实现</a></li><li><a href=#闭包的实现>闭包的实现</a></li><li><a href=#元类>元类</a></li><li><a href=#descriptor>Descriptor</a><ul><li><a href=#引申python-黑魔法-descriptor-描述器>引申：Python 黑魔法 Descriptor (描述器)</a></li></ul></li><li><a href=#bound-method和unbound-method>Bound Method和Unbound Method</a></li></ul></nav></div></div><div class=content id=content><h2 id=python执行环境>Python执行环境</h2><blockquote><p>在编译过程中，这些包含在Python源代码中的静态信息都会被Python编译器收集起来，编译的结果中包含了字符串，常量值，字节码等在源代码中出现的一切有用的静态信息。在Python运行期间，这些源文件中提供的静态信息最终会被存储在一个运行时的对象中，当Python运行结束后，这个运行时对象中所包含的信息甚至还会被存储在一种文件中。这个对象和文件就是我们这章探索的重点：PyCodeObject对象和pyc文件。</p></blockquote><blockquote><p>在程序运行期间，编译结果存在于内存的PyCodeObject对象中；而Python结束运行后，编译结果又被保存到了pyc文件中。当下一次运行相同的程序时，Python会根据pyc文件中记录的编译结果直接建立内存中的PyCodeObject对象，而不用再次对源文件进行编译了。</p></blockquote><p>从文章摘录可见，python生成的不是编译后的文件，而是<code>.py</code>文件对应的静态信息——PyCodeObject，这里包括了字节码指令序列、字符串、常量。每个名字空间(类、模块、函数)都对应一个独立的PyCodeObject。(python连编译后的文件里存的都是个对象！)</p><p>不被import的py文件不会生成pyc。标准库里有py_compile等方法也可以生成pyc。</p><p><strong>import机制</strong> 导入某个模块时，先查找对应的pyc，如果没有pyc就生成然后import这个pyc。(所以实际导入的并不是py文件，而是py文件编译后的PyCodeObject)。</p><p><strong>PyFrameObject</strong> Python程序运行时的「执行环境」。参考操作系统执行可执行文件的过程。Python也是将函数对应的执行环境封装成栈帧的形式加载进内存。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_frame</span> <span class=p>{</span>
    <span class=n>PyObject_VAR_HEAD</span>
    <span class=k>struct</span> <span class=n>_frame</span> <span class=o>*</span><span class=n>f_back</span><span class=p>;</span>  <span class=c1>//执行环境链上的前一个frame
</span><span class=c1></span>    <span class=n>PyCodeObject</span> <span class=o>*</span><span class=n>f_code</span><span class=p>;</span>   <span class=c1>//PyCodeObject对象
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>*</span><span class=n>f_builtins</span><span class=p>;</span>   <span class=c1>//builtin名字空间
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>*</span><span class=n>f_globals</span><span class=p>;</span>    <span class=c1>//global名字空间
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>*</span><span class=n>f_locals</span><span class=p>;</span>     <span class=c1>//local名字空间
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>**</span><span class=n>f_valuestack</span><span class=p>;</span>    <span class=c1>//运行时栈的栈底位置
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>**</span><span class=n>f_stacktop</span><span class=p>;</span>      <span class=c1>//运行时栈的栈顶位置
</span><span class=c1></span>    <span class=err>……</span>
    <span class=kt>int</span> <span class=n>f_lasti</span><span class=p>;</span>        <span class=c1>//上一条字节码指令在f_code中的偏移位置
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>f_lineno</span><span class=p>;</span>       <span class=c1>//当前字节码对应的源代码行
</span><span class=c1></span>    <span class=err>……</span>
    <span class=c1>//动态内存，维护（局部变量+cell对象集合+free对象集合+运行时栈）所需要的空间
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>*</span><span class=n>f_localsplus</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>  
<span class=p>}</span> <span class=n>PyFrameObject</span><span class=p>;</span>
</code></pre></td></tr></table></div></div><p>Python标准库的<code>sys._getframe()</code>可以动态的在程序执行时获取当前内存中活跃的PyFrameObject信息。</p><h2 id=legb-规则>LEGB 规则</h2><p>即python作用域的查找顺序是<code>local</code>-<code>enclosing</code>-<code>global</code>-<code>buildin</code>。看下面代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=n>a</span> <span class=o>=</span> <span class=mi>1</span>

<span class=k>def</span> <span class=nf>g</span><span class=p>():</span>
  <span class=k>print</span> <span class=n>a</span>

<span class=k>def</span> <span class=nf>f</span><span class=p>():</span>
  <span class=k>print</span> <span class=n>a</span> <span class=o>//</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
  <span class=n>a</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>//</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>
  <span class=k>print</span> <span class=n>a</span>

<span class=n>g</span><span class=p>()</span>
</code></pre></td></tr></table></div></div><p>代码在[1]处会抛出异常，原因是python在编译阶段就把静态数据(局部变量、全局变量、字节码)放入pyc里，执行到<code>f()</code>里时，查找到<code>a</code>是在local作用域里定义的而不是global里，但是此时local的a还没赋值，所以就会抛出异常。由此可见，<strong>python作用域信息是在静态编译时就处理好了的</strong>。</p><h2 id=python-虚拟机运行框架>Python 虚拟机运行框架</h2><blockquote><p>运行时环境是一个全局的概念，而执行环境实际就是一个栈帧，是一个与某个Code Block对应的概念。</p></blockquote><blockquote><p>在PyCodeObject对象的co_code域中保存着字节码指令和字节码指令的参数，Python虚拟机执行字节码指令序列的过程就是从头到尾遍历整个co_code、依次执行字节码指令的过程。</p></blockquote><p>由上文引用可见，python在编译阶段将代码块的字节码保存在PyCodeObject的co_code属性里，然后在执行阶段从头到尾遍历这个co_code属性解读字节码。</p><p><strong>Python运行时环境</strong> Python在运行时用PyInterpreterState结构维护进程运行环境，PyThreadState维护线程运行环境，PyFrameObject维护栈帧运行环境，三者是依次包含关系，如下图所示：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://i.loli.net/2021/03/05/GHImB214fvxSXgk.png data-srcset="https://i.loli.net/2021/03/05/GHImB214fvxSXgk.png, https://i.loli.net/2021/03/05/GHImB214fvxSXgk.png 1.5x, https://i.loli.net/2021/03/05/GHImB214fvxSXgk.png 2x" data-sizes=auto alt=https://i.loli.net/2021/03/05/GHImB214fvxSXgk.png title=https://i.loli.net/2021/03/05/GHImB214fvxSXgk.png></p><p>Python虚拟机就是一个「软CPU」，动态加载上述三种结构进内存，并模拟操作系统执行过程。程序执行后，先创建各个运行时环境，再将栈帧中的字节码载入，循环遍历解释执行。</p><h2 id=python字节码>Python字节码</h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-c data-lang=c><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span>
<span class=mi>0</span>   <span class=n>LOAD_CONST</span>   <span class=mi>0</span>  <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=mi>3</span>   <span class=n>STORE_NAME</span>   <span class=mi>0</span>  <span class=p>(</span><span class=n>i</span><span class=p>)</span>
</code></pre></td></tr></table></div></div><p>例如python的一条语句<code>i=1</code>可以解释为下面两行字节码，最左边的第1列数字代表这行字节码在内存中的偏移位置，第2列是字节码的名字(CPU并不关心名字，它只是根据偏移量读出字节码，所以这个名字是方便阅读用的)，第3列是字节码的参数，如<code>LOAD_CONST</code>对应的数据在变量<code>f->f_code->co_consts</code>里，0就是这个参数位于<code>f->f_code->co_consts</code>的偏移量。最后一列的括号里是从参数里取到的value。</p><h2 id=python-的异常抛出机制>Python 的异常抛出机制</h2><p>异常处理的操作都在<code>Python/traceback.c</code>文件里，python每次调用一层函数，就创建改函数对应的PyFrameObject对象来保存函数运行时信息，PythonFrameObject里调用PyEval_EvalFrameEx循环解释字节码，如果抛出异常就创建PyTraceBackObject对象，将对象交给上一层PyFrameObject里的PyTracebackObject组成链表，最后返回最上层PyRun_SimpleFileExFlags函数，该函数调用PyErr_Print遍历PyTraceBackObject链表打印出异常信息。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://i.loli.net/2021/03/05/9bEUBjYov8mZy3s.jpg data-srcset="https://i.loli.net/2021/03/05/9bEUBjYov8mZy3s.jpg, https://i.loli.net/2021/03/05/9bEUBjYov8mZy3s.jpg 1.5x, https://i.loli.net/2021/03/05/9bEUBjYov8mZy3s.jpg 2x" data-sizes=auto alt=https://i.loli.net/2021/03/05/9bEUBjYov8mZy3s.jpg title=https://i.loli.net/2021/03/05/9bEUBjYov8mZy3s.jpg></p><h2 id=函数对象的实现>函数对象的实现</h2><p>PyFunctionObject是函数对象。在python调用函数时，生成PyFunctionObject对象，该对象的f_global指针用来将外层的全局变量传递给函数内部，然后在<code>ceval.c</code>文件的<code>fast_function</code>里解出PyFunctionObject对象里携带的信息，创建新的PyFrameObject对象(上文说过这个对象是维护运行时环境的)，最后调用执行字节码的函数<code>PyEval_EvalFrameEx</code>执行真正函数字节码。</p><p><strong>Python执行一段代码需要什么？</strong> 从书中描述可见，python执行一段代码需要做几件事：</p><ul><li>从源码编译出 PyCodeObject 保存变量和字节码</li><li>执行阶段，从PyCodeObject里取出信息交给 PyFrameObject，执行 PyEval_EvalFrameEx 解释字节码</li><li>如果遇到函数调用，就把函数对应的代码段从 PyCodeObject 存入 PyFunctionObject 对象，然后把这个函数对象通过参数传给新创建的 PyFrameObject ，在内层空间执行 PyEval_EvalFrameEx 解释字节码</li><li>将结果或异常存入 PyFrameObject 的变量( 异常是存入f_blockstack里，外层判断f_blockstack里的数据是被except捕获还是没有捕获而继续下一步操作) 抛给外层</li></ul><p>值得注意的是，<strong>python在执行阶段，将对函数参数的键值查找，转换为索引查找</strong>，即在转换PyCodeObject为PyFrameObject时，将参数信息按位置参数、键参数按照一定顺序存储在f_localsplus变量中，再用索引来查找对应参数，而需要查找键值。这样提高了运行时效率。下图是<code>foo('Rboert', age=5)</code>在内存中的存储形式。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://i.loli.net/2021/03/05/IGy8JTzZpgmN6sL.jpg data-srcset="https://i.loli.net/2021/03/05/IGy8JTzZpgmN6sL.jpg, https://i.loli.net/2021/03/05/IGy8JTzZpgmN6sL.jpg 1.5x, https://i.loli.net/2021/03/05/IGy8JTzZpgmN6sL.jpg 2x" data-sizes=auto alt=https://i.loli.net/2021/03/05/IGy8JTzZpgmN6sL.jpg title=https://i.loli.net/2021/03/05/IGy8JTzZpgmN6sL.jpg></p><h2 id=闭包的实现>闭包的实现</h2><p>Python在编译阶段就把函数闭包内层和闭包外层使用的变量存入PyCodeObject中：</p><ul><li>co_cellvars：通常是一个tuple，保存嵌套的作用域中使用的变量名集合；</li><li>co_freevars：通常也是一个tuple，保存使用了的外层作用域中的变量名集合。</li></ul><p>在执行阶段，PyFrameObject的f_localsplus中也为闭包的变量划分的内存区域，如下图所示：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://i.loli.net/2021/03/05/fUB4wC36dAc7rqt.jpg data-srcset="https://i.loli.net/2021/03/05/fUB4wC36dAc7rqt.jpg, https://i.loli.net/2021/03/05/fUB4wC36dAc7rqt.jpg 1.5x, https://i.loli.net/2021/03/05/fUB4wC36dAc7rqt.jpg 2x" data-sizes=auto alt=https://i.loli.net/2021/03/05/fUB4wC36dAc7rqt.jpg title=https://i.loli.net/2021/03/05/fUB4wC36dAc7rqt.jpg></p><h2 id=元类>元类</h2><p>元类<code>&lt;type type></code>和其他类的关系如下图：</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://i.loli.net/2021/03/05/N76woqSlmR28Oyt.jpg data-srcset="https://i.loli.net/2021/03/05/N76woqSlmR28Oyt.jpg, https://i.loli.net/2021/03/05/N76woqSlmR28Oyt.jpg 1.5x, https://i.loli.net/2021/03/05/N76woqSlmR28Oyt.jpg 2x" data-sizes=auto alt=https://i.loli.net/2021/03/05/N76woqSlmR28Oyt.jpg title=https://i.loli.net/2021/03/05/N76woqSlmR28Oyt.jpg></p><p><strong>可调用性（callable）</strong> ，只要一个对象对应的class对象中实现了“<strong>call</strong>”操作（更确切地说，在Python内部的PyTypeObject中，tp_call不为空）那么这个对象就是一个可调用的对象，换句话说，在Python中，所谓“调用”，就是执行对象的type所对应的class对象的tp_call操作。</p><h2 id=descriptor>Descriptor</h2><blockquote><p>在PyType_Ready中，Python虚拟机会填充tp_dict，其中与操作名对应的是一个个descriptor
对于一个Python中的对象obj，如果obj.__ class__对应的class对象中存在__get__、__set__和__delete__三种操作，那么obj就可称为Python一个descriptor。</p></blockquote><blockquote><p>如果细分，那么descriptor还可分为如下两种：</p></blockquote><ol><li>data descriptor : type中定义了__get__和__set__的descriptor；</li><li>non data descriptor : type中只定义了__get__的descriptor。
在Python虚拟机访问instance对象的属性时，descriptor的一个作用是影响Python虚拟机对属性的选择。从PyObject_GenericGetAttr的伪代码可以看出，Python虚拟机会在instance对象自身的__dict__中寻找属性，也会在instance对象对应的class对象的mro列表中寻找</li></ol><blockquote><ol><li>Python虚拟机按照instance属性、class属性的顺序选择属性，即instance属性优先于class属性；</li><li>如果在class属性中发现同名的data descriptor，那么该descriptor会优先于instance属性被Python虚拟机选择</li></ol></blockquote><p><img class=lazyload src=/svg/loading.min.svg data-src=https://i.loli.net/2021/03/05/1xKk3IVPdjWb8iB.jpg data-srcset="https://i.loli.net/2021/03/05/1xKk3IVPdjWb8iB.jpg, https://i.loli.net/2021/03/05/1xKk3IVPdjWb8iB.jpg 1.5x, https://i.loli.net/2021/03/05/1xKk3IVPdjWb8iB.jpg 2x" data-sizes=auto alt=https://i.loli.net/2021/03/05/1xKk3IVPdjWb8iB.jpg title=https://i.loli.net/2021/03/05/1xKk3IVPdjWb8iB.jpg></p><h3 id=引申python-黑魔法-descriptor-描述器>引申：Python 黑魔法 Descriptor (描述器)</h3><ul><li><a href=http://www.jianshu.com/p/250f0d305c35>http://www.jianshu.com/p/250f0d305c35</a></li><li><a href=http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html>http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html</a></li></ul><h2 id=bound-method和unbound-method>Bound Method和Unbound Method</h2><p>假设有下面两种对类方法的调用：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>A</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
    <span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>pass</span>

<span class=n>a</span> <span class=o>=</span> <span class=n>A</span><span class=p>()</span>
<span class=c1># [1]</span>
<span class=n>a</span><span class=o>.</span><span class=n>f</span><span class=p>()</span>  

<span class=c1># [2]</span>
<span class=n>A</span><span class=o>.</span><span class=n>f</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>

<span class=c1># [3]</span>
<span class=n>func</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=n>f</span>
<span class=n>func</span><span class=p>()</span>
</code></pre></td></tr></table></div></div><p>在代码[1]里，实例a调用类方法f，python底层会自动完成实例a和类方法f之间的绑定动作(调用<code>func_ descr_get(A.f, a, A)</code>，将实例地址和函数对象PyFunctionObject封装到一个PyMethodObject)，而代码[2]里直接通过A调用，则f为非绑定的PyMethodObject，里面没有实例信息，需要传入a。</p><p>比较绑定方法与非绑定方法可知，通过[1]的方式每次都要绑定一次实例，开销非常大，下图比较的是[1]和[3]两种方式，绑定操作的执行次数。</p><p><img class=lazyload src=/svg/loading.min.svg data-src=https://i.loli.net/2021/03/05/TpCcdaYmHlQnXzE.jpg data-srcset="https://i.loli.net/2021/03/05/TpCcdaYmHlQnXzE.jpg, https://i.loli.net/2021/03/05/TpCcdaYmHlQnXzE.jpg 1.5x, https://i.loli.net/2021/03/05/TpCcdaYmHlQnXzE.jpg 2x" data-sizes=auto alt=https://i.loli.net/2021/03/05/TpCcdaYmHlQnXzE.jpg title=https://i.loli.net/2021/03/05/TpCcdaYmHlQnXzE.jpg></p><p>结论： <strong>调用类实例绑定的方法时，如果方法执行次数非常多，最好将方法赋值给一个变量，防止重复绑定增加开销</strong></p></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>Updated on 2017-07-13</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span><a href=javascript:void(0); title="Share on Twitter" data-sharer=twitter data-url=https://sund.site/posts/2017/python-2/ data-title=《Python源码剖析》第二部分——Python虚拟机基础 data-via=way2steve data-hashtags=python><i class="fab fa-twitter fa-fw" aria-hidden=true></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/python/>python</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>Back</a></span>&nbsp;|&nbsp;<span><a href=/>Home</a></span></section></div><div class=post-nav><a href=/posts/2017/python/ class=prev rel=prev title=《Python源码剖析》第一部分——Python对象基础><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>《Python源码剖析》第一部分——Python对象基础</a>
<a href=/posts/2017/python-3/ class=next rel=next title=《Python源码剖析》第三部分——Python虚拟机进阶>《Python源码剖析》第三部分——Python虚拟机进阶<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><img src=/images/qrcode/like.png style=width:150px;z-index:50></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2016 - 2022</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://sund.site/about/ target=_blank>Steve Sun</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i></a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"Copy to clipboard","maxShownLines":50},"comment":{}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js',new Date());gtag('config','UA-64688885-1',{'anonymize_ip':true});</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=UA-64688885-1" async></script></body></html>