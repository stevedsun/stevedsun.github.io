<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Steve Sun</title><link>https://sund.site/posts/</link><description>Recent content in Posts on Steve Sun</description><generator>Hugo</generator><language>zh-CN</language><copyright>Copyright © 2013-2025, Steve Sun.</copyright><lastBuildDate>Tue, 29 Apr 2025 10:49:39 +0800</lastBuildDate><follow_challenge><feedId>41397727810093074</feedId><userId>56666701051455488</userId></follow_challenge><atom:link href="https://sund.site/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Hand on Enablement</title><link>https://sund.site/posts/2025/hand-on-enablement/</link><pubDate>Tue, 29 Apr 2025 10:49:39 +0800</pubDate><guid>https://sund.site/posts/2025/hand-on-enablement/</guid><description>&lt;p>最近在读《沃顿商学院最受欢迎的谈判课》这本书。有两个可以快速上手的实用技巧：&lt;/p>
&lt;ol>
&lt;li>在做没有把握的事之前，找人一起模拟演练一下&lt;/li>
&lt;li>快速行动，避免焦虑&lt;/li>
&lt;/ol>
&lt;h2 id="提前模拟的重要性">提前模拟的重要性&lt;/h2>
&lt;p>和朋友或者同事，在面试、谈判之前提前演练，可以从不同视角对人际沟通场景进行演习，大概能排除掉因为个人认知盲点带来的 20%失误。&lt;/p>
&lt;p>&lt;strong>和人打交道最重要的不是专业知识，而是视角&lt;/strong>。越是在某些领域经验丰富的人，越是会忽略视角的重要性。调查显出，经验丰富的人，尤其不喜欢倾听别人的观点。那些习惯放低身段的人，在社交场合更容易获得机会，他们往往更愿意倾听，从而更加了解对方的需求。&lt;/p>
&lt;h2 id="跳进信息流里学习游泳">跳进信息流里学习游泳&lt;/h2>
&lt;p>站在岸上观察不会让你学会游泳，有时候要勇敢跳进水里。很多时候你缺少的不是信息，而是跳进信息流里的行动。&lt;/p>
&lt;p>例如，大企业只喜欢招有工作经验的人，一家企业的工作方式是一套复杂的人与人的信息流，了解它最好的方式是参与。对于一个毕业生，首要任务是利用各种实习、外包机会参与进去，而不是找课程培训。&lt;/p>
&lt;p>要 Hand on enablement，有些焦虑的本质，是缺少行动。互联网的发达让人习惯性地收集信息，而不是采取行动。&lt;/p>
&lt;p>我最近在犹豫是否需要买一辆车做代步工具，我发现我无法决策的原因是缺少开车的机会，不了解自己的需求。所以「是否买车」的问题对我来说可以转换成「创造条件开车」。下一步就是租车先了解自己的需求。&lt;/p>
&lt;p>快速行动，也可以获得一种全新的视角，你会发现这和前边强调模拟演练的共通之处：&lt;strong>多种视角下的得到的浅显认识，往往能胜过单一视角下的深入研究&lt;/strong>。&lt;/p>
&lt;p>Let&amp;rsquo;s do it.&lt;/p></description></item><item><title>与AI协作编程──痛点篇</title><link>https://sund.site/posts/2025/pairing-with-ai-02/</link><pubDate>Sun, 23 Mar 2025 00:00:01 +0800</pubDate><guid>https://sund.site/posts/2025/pairing-with-ai-02/</guid><description>&lt;p>在与 AI 协作编程中，经常遇到一些大模型无法正确执行的情况。最常见的有：&lt;/p>
&lt;ul>
&lt;li>任务死循环&lt;/li>
&lt;li>模型无法修复环境问题&lt;/li>
&lt;li>模型执行长任务后半段忘记上下文&lt;/li>
&lt;/ul>
&lt;h2 id="一些使用经验">一些使用经验&lt;/h2>
&lt;p>以我自己为例，我经常使用 Cline + Github Copilot 的组合。我很喜欢 Cline 的功能是 &lt;code>Checkpoint restore&lt;/code>，它可以在执行错误的位置重新编辑提示词执行。这让我可以在相同的任务中调用不同的模型，观察他们处理问题的能力。&lt;/p>
&lt;p>用作规划（Plan）的模型通常用 Deepseek-R1，Gemini 2.0 Flash Thinking，Claude 3.7。这里除了 Claude 3.7 能够比较准确给出计划外，其他模型多少都容易走「歪路」， 比如 Deepseek-R1 喜欢做一些多余的事情，让它翻译中文，它会调用 MCP 的翻译服务而不是自己翻译。&lt;/p>
&lt;p>从经济角度考虑，解决简单问题 Gemini 2.0 Flash Thinking 是比较快速、经济的模型。复杂问题直接上 Claude 3.7 可能更容易控制成本。&lt;/p>
&lt;p>用作执行任务（Act）的模型里，Deepseek-V3 表现非常不稳定，经常死循环或丢失上下文。Claude 太贵，而 Gemini 2.0 Flash 是相对准确且划算的模型。置于国产的 Qwen 系列模型不完全支持 Function Calling，Cline 也没有适配，所以暂时无法测试。&lt;/p>
&lt;h2 id="ai-编程疑难杂症的应对方法">AI 编程疑难杂症的应对方法&lt;/h2>
&lt;p>最近读到&lt;a href="https://ezyang.github.io/ai-blindspots/">AI Blindspots&lt;/a>这篇文章，作者系统性整理了 AI 编程中遇到的问题和他的思路。对我非常有启发。我用 Agent 把它翻译成了中文并人工做了润色，你可以在这里读到：&lt;a href="https://sund.notion.site/AI-1be8ce9d275d80649a29e541d310d5c5">AI 编程的盲点&lt;/a>。&lt;/p>
&lt;p>概括起来，解决 AI 问题的核心要领还是三点：更准确的提示词、更完整的上下文、缩小问题规模。&lt;/p>
&lt;p>相信随着技术的发展，编程范式会发生翻天覆地的变化。如果重构变得如此容易，那么马丁福勒的《重构》是否应该出一套 AI 时代下的新范式。如果文档不再是被人读，而是喂给模型当作上下文，那么文档的形态应该是什么样？是否提供一个向量化的文档接口供大模型调用，将是未来编程框架的新常态？&lt;/p>
&lt;p>我对未来充满期待。&lt;/p></description></item><item><title>与AI协作编程──测试篇</title><link>https://sund.site/posts/2024/pairing-with-ai-01/</link><pubDate>Wed, 11 Dec 2024 17:02:43 +0800</pubDate><guid>https://sund.site/posts/2024/pairing-with-ai-01/</guid><description>&lt;p>未来的程序开发范式，将是人与 AI 协作编程。这已经是软件行业不争的事实。像 Windsurf，Cusor，Copilot 之类的编程工具一方面提高了开发效率，另一方面也让代码变得更黑盒，更不易阅读和维护。&lt;/p>
&lt;p>我试图浅显地讨论一下哪些软件开发的手段更适合在 AI 时代提高 AI 编写代码的可观测性和维护性。接下来所有以「与 AI 协作编程」为标题的文章都只是抛砖引玉，并未形成系统化方法论。期望任何错误之处，读者不吝赐教。&lt;/p>
&lt;h2 id="使用-ai-编写代码有哪些常见问题">使用 AI 编写代码有哪些常见问题？&lt;/h2>
&lt;p>&lt;strong>可观测性问题：AI 实现的功能不完备，经常要手动修改片段&lt;/strong>&lt;/p>
&lt;p>AI 生成代码最大的问题在于，它经常引起人类不易察觉的隐蔽错误。当人类使用 prompt 修改代码时，由于 AI 行为的不易观测性，即便修复了一个 bug，也可能导致其他回归问题（引起已有逻辑的错误）。&lt;/p>
&lt;p>&lt;strong>上下文问题：缺少全局上下文，碎片代码之间缺少联系&lt;/strong>&lt;/p>
&lt;p>由于 Token 数限制或经济上的考虑，很多编辑器会优化输入的内容，这就容易造成大模型错误地理解局部上下文。没有办法处理跨功能模块的业务逻辑。尤其项目变得庞大后，复杂的模块经常依赖其他模块，调整业务逻辑需要重构若干个代码文件。&lt;/p>
&lt;h2 id="解决思路">解决思路&lt;/h2>
&lt;p>AI 编写代码的核心问题，可以归纳为不可观测性和缺少上下文造成的低维护性。为了解决这两个问题，我们需要先回顾一下传统软件工序如何让代码更易观测和维护。&lt;/p>
&lt;h3 id="人类主导的单元测试">人类主导的单元测试&lt;/h3>
&lt;p>单元测试是代码的说明书。复杂的业务逻辑通常需要阅读大量代码才能看懂。但是熟练的程序员会先看单元测试。好的单元测试会把模块的预期输入、输出完整地写进 Case 里。在 &lt;a href="https://www.amazon.com/Unit-Testing-Principles-Practices-Patterns/dp/1617296279">Unit Testing Principles, Practices, and Patterns&lt;/a> 里，作者认为好的单元测试应该具备：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>保护回归&lt;/strong>。即测试能够防止出现已经修复的问题在回归测试中复现的情况。&lt;/li>
&lt;li>&lt;strong>抵抗重构&lt;/strong>。即代码重构后，测试能正确识别出重构是否对已有功能造成影响。&lt;/li>
&lt;li>&lt;strong>快速反馈&lt;/strong>。即单元测试容易运行，发现问题能及时定位到错误。&lt;/li>
&lt;li>&lt;strong>易于维护&lt;/strong>。 测试不同于业务代码，它的可维护体现在正确处理依赖关系和共享代码。&lt;/li>
&lt;/ul>
&lt;p>这些原则最终目的，都是保证被测系统按预期行为运行。&lt;/p>
&lt;p>当 AI 和人类合作完成代码时，我个人认为，在编写单元测试这件事上，人类应该主导（80%），AI 辅助（20%），因为单元测试定义了「我期望的行为」。&lt;/p>
&lt;p>当单元测试完善后，又反过来指导 AI 实现的真正的业务代码。这时人类占比下降，AI 占据主导。人类反复运行单元测试，同时将测试结果和 prompt 一起传递给 AI，帮助 AI 修正程序的问题。&lt;/p>
&lt;h3 id="编写对-ai-友好的测试离不开好的模块设计">编写对 AI 友好的测试离不开好的模块设计&lt;/h3>
&lt;p>在编写好的测试时，也要关注正确的拆分模块。一个好的测试通常是给定输入，验证是否输出预期的结果。而模块如果依赖过多外部环境做分支判断，就会造成测试的输出严重依赖外部状态。这会降低模块的可观测性。&lt;/p>
&lt;p>下面两条经验，可以帮助你写出好的代码：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>写测试时要测试行为的结果，而不是步骤。写业务代码时，要 AI 写清步骤。&lt;/p>
&lt;p>单元测试的「单元」可以不是一个类或函数。而是一组完成一个原子业务逻辑的操作。（当然也有不同的流派支持以类为单位测试，但这不是本文的重点）。为了让 AI 生成的业务代码具有抗重构特性，要验证 AI 的行为结果，而不是验证每一个实现步骤。耦合测试代码和实现步骤会导致业务的修改破坏已有的测试，使得「期望的行为」要不断随着「具体的实现」来修改。&lt;/p>
&lt;p>当 AI 开始写业务逻辑后，应该以步骤驱动的方式逐步实现，期间，人类可以针对某一步骤修正 AI 的代码逻辑。但切忌破坏测试的逻辑。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>无状态的代码（函数式）最容易测试&lt;/p>
&lt;p>因为它的输出具有不变性。应该让核心代码尽量无状态，将状态、外部系统依赖放在应用服务层。而把深且不易理解的核心逻辑，放在领域服务层。这里的细节可以参考 DDD（Domain Driven Design）的思想。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/pairing-with-ai-01/functional_core.png" alt="functional_core.png">&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>这篇文章作为一系列人类与 AI 协作编程话题的开头，从测试角度试图缓解 AI 生成代码的可观测性问题。&lt;/p>
&lt;p>在后边的文章里，我希望从架构设计角度，讨论一下如何设计 AI 友好的、易于维护上下文的架构。&lt;/p>
&lt;p>文章内容会随着时间的推移，持续更新，欢迎讨论。&lt;/p></description></item><item><title>Go 语言的依赖倒置</title><link>https://sund.site/posts/2024/go-dependency-inject/</link><pubDate>Thu, 21 Nov 2024 11:26:22 +0800</pubDate><guid>https://sund.site/posts/2024/go-dependency-inject/</guid><description>&lt;blockquote>
&lt;p>这篇文章比较基础，是我在给 Java 程序员做 go 语言培训时用到的。&lt;/p>
&lt;/blockquote>
&lt;h2 id="为什么要做依赖倒置dip">为什么要做依赖倒置（DIP）？&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">依赖倒置&lt;/a>，或叫依赖反转、DIP，是软件开发非常重要的设计原则。很多程序员没有了解过相关知识，或者只从 Java Spring 知道大致思想。我今天想用一篇简短的文章，用 Go 语言做一个简单的例子，讲解一下怎么最简单地实现依赖倒置。&lt;/p>
&lt;p>如果你还不知道它是什么，可以参考 wiki 中的描述，或者阅读&lt;a href="https://martinfowler.com/articles/dipInTheWild.html">马丁福勒关于 DIP 的文章&lt;/a>。&lt;/p>
&lt;p>依赖倒置原则要解决一个软件开发中常见的风险：依赖。&lt;/p>
&lt;p>尝试回忆一下：&lt;/p>
&lt;ol>
&lt;li>当你尝试通过 Mock 方式屏蔽底层细节做测试时，你发现你要测试的类引用了大量框架提供的接口，导致你需要 mock 大量底层的实现。&lt;/li>
&lt;li>当你尝试修改一个旧的底层类，但是依赖该类的上层服务类太多，你一边担心造成副作用，一边在所有依赖的位置重构上层代码。&lt;/li>
&lt;/ol>
&lt;p>我们分析一下这两个场景：&lt;/p>
&lt;p>场景 1 里，应用类依赖于框架提供的实现，导致应用类很难从框架上剥离出来，业内处理这种问题的方法叫&lt;strong>控制反转&lt;/strong>（IoC, Inversion of Control）。即应用类不应该依赖框架，而是框架提供插槽一样，把应用类注册给框架，由框架统一调度应用，执行对应的方法。&lt;/p>
&lt;p>场景 2 里，服务类依赖底层类，导致底层修改难度越来越大。解决办法是&lt;strong>依赖注入&lt;/strong>（DI, Dependency Injection）。即上层类不直接引用底层类，而是在使用的地方把上层类依赖的底层类注入进来。&lt;/p>
&lt;p>把这两个场景结合起来，就是依赖倒置原则的核心：&lt;/p>
&lt;ul>
&lt;li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。&lt;/li>
&lt;li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。&lt;/li>
&lt;/ul>
&lt;p>这两个原则保证了代码中模块的高内聚、低耦合，同时给 Mock、迭代更新模块创造了条件。&lt;/p>
&lt;h2 id="用-go-语言实现它">用 Go 语言实现它&lt;/h2>
&lt;p>假设现在要从一个用户的服务中查询用户的信息。有两个接口，UserRepository 作为数据层负责查询数据库， UserService 负责业务逻辑，它依赖 UserRepository。同时为了方便测试，我们还要写一个 Mock 的数据层实现。 整个结构如下图。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/go-dependency-inject/example.png" alt="Go example">&lt;/p>
&lt;p>接下来非常轻松地，我们实现两个接口，并写了他们的实现类。同时我们还在 UserService 的实现类里写了一个 NewUserService，来把它依赖的 UserRepository 实现注入进来。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 在 user_repository.go 中实现具体的接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">UserRepository&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GetByID&lt;/span>(&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Save&lt;/span>(&lt;span style="color:#a6e22e">user&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ... 具体实现 UserRepository，略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// user_service.go 中实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">UserService&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GetUser&lt;/span>(&lt;span style="color:#a6e22e">id&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) (&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">User&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">CreateUser&lt;/span>(&lt;span style="color:#a6e22e">name&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span>, &lt;span style="color:#a6e22e">age&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#66d9ef">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// ... 具体实现 UserService，略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">NewUserService&lt;/span>(&lt;span style="color:#a6e22e">repo&lt;/span> &lt;span style="color:#a6e22e">UserRepository&lt;/span>) &lt;span style="color:#a6e22e">UserService&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">UserServiceImpl&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">repo&lt;/span>: &lt;span style="color:#a6e22e">repo&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么问题来了，可不可以直接在 &lt;code>user_service.go&lt;/code> 中直接把 repository 引用进来呢？显然不行，因为这样，两个模块就形成了依赖关系。&lt;/p>
&lt;p>这一点是依赖反转的核心，上层模块不直接引用下层模块，而是由执行的类来初始化 Service 并将依赖的下层服务注入进来。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 在main.go 中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">repo&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">MySQLUserRepository&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">userService&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewUserService&lt;/span>(&lt;span style="color:#a6e22e">repo&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，当编写测试 Mock 代码时，不需要修改任何代码逻辑，直接在测试中将&lt;code>NewUserService&lt;/code> 的参数替换成测试的假实例即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 在 user_service_test.go 中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">TestUserService&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">repo&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">MockTestUserRepository&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">userService&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewUserService&lt;/span>(&lt;span style="color:#a6e22e">repo&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，如果数据层修改了实现，或者迁移到另外的数据库，你只需要修改两个地方：数据层的实现者和依赖注入者。对于调用者 &lt;code>UserService&lt;/code> 则完全不受到影响。整个项目也不会形成依赖陷阱。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>依赖倒置原则的两个核心原则：&lt;/p>
&lt;ul>
&lt;li>模块不依赖于其他模块，而是都依赖于抽象接口&lt;/li>
&lt;li>抽象接口不依赖于实现，而实现依赖于抽象接口&lt;/li>
&lt;/ul>
&lt;p>在 Go 语言中实现这两条原则并不麻烦，只要将原本的调用方-实现方，转换成注册方-调用方-实现方。在 Go 中也有一些库和框架实现依赖反转，其实核心思想并没有差异。&lt;/p></description></item><item><title>监控系统项目复盘</title><link>https://sund.site/posts/2024/metrics-project-retro/</link><pubDate>Thu, 24 Oct 2024 15:52:22 +0800</pubDate><guid>https://sund.site/posts/2024/metrics-project-retro/</guid><description>&lt;p>这篇文章对我过去 3 年的一大块工作内容进行复盘。我作为项目组的架构师，在下文中也对项目早期遗留的一些问题进行反思，并分享我个人的解决思路。&lt;/p>
&lt;h2 id="项目核心依赖开源组件定制化过度">项目核心依赖开源组件，定制化过度&lt;/h2>
&lt;p>我们的项目是一个运行在边缘设备上的日志、软硬件性能指标的采集/监控系统。考虑到边缘计算设备（IPC）的性能，选择开源组件时就侧重于轻量化、支持丰富的输出标准。早期部门架构师采用了 Fluent-Bit 作为项目的核心组件。Fluent-Bit 是 C 编写的开源、轻量、可轻度扩展的数据收集器。它最开始用作日志收集，后来逐渐发展成全功能的 Agent。对比流行的&lt;a href="https://github.com/open-telemetry">OpenTelemetry&lt;/a>，Fluent-Bit 更开箱即用、更轻量，但是不易于修改和扩展。&lt;/p>
&lt;p>最开始整个团队都没接触过监控系统，所以在设计系统时挖了不少坑。首先，用户在 UI 上操作过度繁琐，需要依次配置输出的目标（地址、端口、协议、格式、加密方式等等）、采集的指标类型，最后还要手动点击 Apply （应用）一下。&lt;/p>
&lt;p>经过几轮迭代，适当简化了操作逻辑。但是像大部分工业 PC 上运行的程序一样，用户在初始化配置过后，通常不会主动去 UI 上修改配置。终端用户更关心占用系统资源多少、稳定性如何。所以最开始团队把这个项目做成了一个重交互的 C 端产品，这是个教训。&lt;/p>
&lt;p>第二，后端开发为了满足 UI 设计的流程（比如，用户可以创建多份不同的配置项到不同的目标地址），做了复杂的 Work-around。因为 Fluent-Bit 是单进程事件驱动模型，只有单一配置文件，每次修改配置文件都要重启 Fluent-bit 进程。这就造成了 UI 上用户添加一个配置项，后台就要重新生成整个配置文件并重启 Fluent-Bit。这对于一个稳定运行的监控系统来说，无疑增加了&lt;strong>重启过程中数据丢失&lt;/strong>的风险。另外，如果&lt;strong>新增的配置项出错，就会让整个生成的配置文件报错，导致 Fluent-Bit 进程假死&lt;/strong>等问题。&lt;/p>
&lt;p>为了解决这些问题，后端工程师又对 Fluent-Bit 的各项参数玩出各种花活儿。比如利用不同 tag 来分流不同用户配置项，为每个配置项单独配置参数和过滤规则。再比如设定缓存数据包大小和缓存 timeout 时间为 0，这样 Fluent-Bit 重启之后会首先尝试重发缓存在文件系统里的数据，这样间接防止用户数据丢失。&lt;/p>
&lt;p>这些花活儿不但提高了维护难度，从用户角度看，也并没有带来任何真正的价值提升。&lt;/p>
&lt;p>回顾来看，&lt;strong>如果早期的 UI 设计改成单独的配置页面，不但简化的操作流程，还给业务代码降低的复杂度。&lt;/strong>&lt;/p>
&lt;p>第三，核心项目依赖 Fluent-Bit 造成项目迁移到其他开源组件非常困难。加上 Fluent-Bit 更新频率高，公司对安全性合规要求使得我们团队每隔一段时间要对 Fluent-Bit 进行升级，同时对所有配置选项做回归测试。加上 Fluent-Bit 订制性很差，它虽然支持使用 Go 语言实现 Output 插件，但是只能用 C 语言编写 Input 插件。导致我们采集内部应用的数据，不得不用到它的 TCP 和 HTTP 插件来中转。部署多个 Agent 采集不同的内部服务。这让后期集成测试更添难度。&lt;/p>
&lt;p>总体来说，Fluent-bit 的性能基本达到了预期，但是各种小 bug（比如 pgsql 插件在目标不可达时直接 Block 整个进程），开源社区维护者并没有引起重视，我们提交给开源社区的代码也被以各种理由驳回。如果让我重新选择，我更倾向于使用其他扩展性更强的开源组件。&lt;/p>
&lt;h2 id="对-go-语言不熟悉项目结构混乱">对 Go 语言不熟悉，项目结构混乱&lt;/h2>
&lt;p>团队遇到的第二个挑战是对 Go 语言不熟悉。大部分开发成员只有 Java 开发经验，所以顺理成章把 Go 写成了 Java。因为框架（Go-Gin）的限制，导致开发中问题频出。&lt;/p>
&lt;p>第一个问题来自面向对象和依赖反转。依赖反转对于使用 Java Spring 的人来说不会陌生，但是用 Go 实现依赖反转，需要利用 Interface 封装，并结合 Go-Mock 库做单元测试。团队成员早期不熟悉语言特性，经常错误封装抽象，或者干脆直接函数套函数，写成&lt;a href="https://zh.wikipedia.org/zh-sg/%E9%9D%A2%E6%9D%A1%E5%BC%8F%E4%BB%A3%E7%A0%81">面条型代码&lt;/a>。这充分暴露了大部分国内 Java 程序员其实没有受过良好的 OOP 训练。对于单元测试、集成测试这些工程实践也是流于形式。软件质量在大部分企业里仍然靠测试人员手动验证。&lt;/p>
&lt;p>第二个问题是 Go 语言不鼓励过度抽象。如泛型、异常处理，都要一步步重复琐碎的代码片段，这让 Sonar 静态检查经常 failed。没经验的同事就会用各种奇技淫巧逃避静态检查。这也说明开发团队定期 code review 的必要性。&lt;/p>
&lt;p>第四，Go 语言其实是一个社区不那么完善的编程语言，它的很多框架（如最热门的 gorm 居然是个人开发项目），像 Flyway 这种 Java 工具链中很成熟的迁移工具，在 Go 里竟然需要组合多个开源项目来替代。所以 Go 只适合来开发中等以下规模的项目，或者对性能要求较高的平台核心组件。（在国内）不适合做复杂的业务场景。&lt;/p>
&lt;h2 id="api-接口粒度过细没有对资源对象做好抽象">API 接口粒度过细，没有对资源对象做好抽象&lt;/h2>
&lt;p>团队早期由于管理混乱：架构上，没有对业务模型做好抽象，资源对象拆分太碎；管理上，任务拆解太简单粗暴，给每个同事单独负责一个模块，导致每个业务流程都设计了专门的 API，维护压力大。好在业务场景少，用自动化测试能一定程度上保证了接口可靠性。&lt;/p>
&lt;p>最开始做自动化集成测试时，我们仍然使用 BDD 的形式，以业务操作为基础编写，后来逐渐发现这种监控系统，其实真正的用户操作逻辑非常简单，复杂的部分是不同类型的数据、不同的 Input、Output 配置可能引起的异常。所以我们改成了数据驱动测试，用配置文件对不同类型的 Fluent-Bit 配置做全面的测试。&lt;/p>
&lt;p>总结起来，Fluent-Bit 配置的修改，其实完全可以用 3~4 个宽泛的 API 来实现，除了前文提到流程过度设计原因，项目初期的不确定性，导致开发人员过度关注松耦合，而忽略了维护性。&lt;/p>
&lt;h2 id="错误的流水线设计">错误的流水线设计&lt;/h2>
&lt;p>最开始项目沿用的部门其他团队的集成测试、部署模式，把 Python 写的测试用例和项目部署脚本放在单独的 Gitlab Repo 里。结果是每次项目部署时，要人工去网页上修改版本号触发流水线。从持续集成的角度看，业务代码和测试用例分开，造成了每次 commit 都要到不同 repo 里去提交，且一旦冲突又要分别执行多次集成测试（时间长，反馈慢）。&lt;/p>
&lt;p>后期我们做了一些调整，把多个小模块合并成一个&lt;a href="https://zh.wikipedia.org/wiki/Monorepo">Monorepo&lt;/a>，同时把部分 API 相关的集成测试放在后端代码里，减少提交次数，也让原子提交更容易。&lt;/p>
&lt;p>不过部署问题依然没有被解决，原因是边缘平台上的模块太多，系统集成需要多个团队合作，部署、发布版本时间长，出错的环节太多。对于这种情况，部门技术负责人设定了严格的代码提交、测试、review、文档更新流程，但是根本问题还在于团队责任模糊、部门团队跨多个国家和时区，缺少统一的调度和沟通机制。这些问题只能留给管理层逐渐缓解，或者随着业务收敛，减少、分流项目组。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>整体来看，我们团队遇到的很多问题出自项目早期，缺少项目和技术团队管理经验。对业务的愿景不了解，把做 C 端 Saas 产品的经验带到工业领域，用熟悉的开发范式套用到制造业。当然，不回避地说，在业务上，部门多流程长，业务负责人只能盲人摸象，用户反馈要先到达 Support 团队，再反馈给上层，最后才到开发团队。这让我们开发出来的产品要经过至少 3-6 个月才能得到有效的反馈。迭代周期太长，研发闭门造车。&lt;/p></description></item><item><title>磨合</title><link>https://sund.site/posts/2024/symbiosis/</link><pubDate>Mon, 16 Sep 2024 23:31:14 +0800</pubDate><guid>https://sund.site/posts/2024/symbiosis/</guid><description>&lt;p>前几天买了一辆公路车，车店老板说，新买的自行车要骑一段时间，需要慢慢磨合。&lt;/p>
&lt;p>我不知道老板说的「磨合」，是人适应车，还是车适应人。也可能两者都有。&lt;/p>
&lt;p>这让我联想起书里这段话：&lt;/p>
&lt;blockquote>
&lt;p>我一直都是从一个十分理性的角度来谈论一切有关机械的事物，因为机械是零部件、是各种关系、是分析、是组合、是明了事物的原委，但它并不真的在此处。它总是在别处，我们都以为别处即此处，但是实际上它却远在千里之外，这就是机械的本质。
── 禅与摩托车维修艺术&lt;/p>
&lt;/blockquote>
&lt;p>当一个车手骑上一辆陌生的车，自行车机械结构也在慢慢适应车手：螺丝的松紧、齿轮的咬合程度、转轴的润滑程度……这些自行车上的无数个「参数」和骑车的人一起被重塑。你骑车越久，车对你的拟合程度就越高。而人身上的骨骼、肌肉也在慢慢适应车。&lt;/p>
&lt;p>这大概就是所谓的磨合。&lt;/p>
&lt;p>&lt;a href="https://world.hey.com/dhh/why-don-t-more-people-use-linux-33b75f53">DHH&lt;/a>前几个月搞了一个项目，他用 Linux 系统篡了一个开箱即用的开源工具：用一行命令把电脑变成充满快捷键、工作效率拉满的编程环境。也有国外程序员批评他，说他把自己那套习惯搞成了开源项目让大家学。可 DHH 把这种设计哲学称为「Omakase」（お任せ），意为「交给您了」，是日本餐厅点菜时，食客完全交给厨师作决定的一种文化。我管它叫专家级预制菜。&lt;/p>
&lt;p>从零开始调校，对大部分人来说门槛太高。那循着专家的指引，再磨合出一套自己的东西，也未尝不可。&lt;/p>
&lt;p>DHH 不止是知名开源框架 Ruby on Rails 的作者，也是个作家、赛车手。也许身为多重身份的天才，他对工具和环境有一种控制欲，或者说，与其共生的欲望。&lt;/p>
&lt;p>与某物共生，前提是它必须足够复杂。需要你认真去理解，去体会。简单就意味着「参数」太少，它无法向你拟合，你只能傻傻地向它拟合，适应它。&lt;/p>
&lt;p>为了让某物达到你预期的状态，你要经过漫长的、名为磨合的旅程。这期间，你看到了和预期中不同的风景，最初预设的目标不那么重要了，无尽的可能性在前方等着你。&lt;/p>
&lt;p>这就是最佳状态，不用纠结于完美，完美是平衡，旅程本身就是目的地。&lt;/p>
&lt;p>朋友们，像车手训练自己耐力那样，不断去和你周遭的一切磨合吧，因为磨合就是人生的全部意义。&lt;/p></description></item><item><title>Windows Efficient Setup</title><link>https://sund.site/posts/2024/windows-efficient-setup/</link><pubDate>Sat, 31 Aug 2024 00:23:37 +0800</pubDate><guid>https://sund.site/posts/2024/windows-efficient-setup/</guid><description>&lt;p>Last month I read DHH&amp;rsquo;s blog post &lt;a href="https://world.hey.com/dhh/introducing-omakub-354db366">Introducing Omakub&lt;/a>. Omakub is a project that helps you to setup your Ubuntu machine by running a single command. DHH composed a list of tools he uses on his Ubuntu.&lt;/p>
&lt;p>In spirit of the post, I decided to setup my Windows machine efficiently like Omakub.&lt;/p>
&lt;p>You can find the full setup script &lt;a href="https://gist.github.com/stevedsun/319f0c05b02e739207743dd441b6239a">here&lt;/a>.&lt;/p>
&lt;p>Following is the keyboard Layout I am using.&lt;/p>
&lt;h2 id="keyboard-layout">Keyboard Layout&lt;/h2>
&lt;p>&lt;strong>Tool&lt;/strong>: AutoHotKey, PowerToys&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>Shortcut&lt;/th>
 &lt;th>Description&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>Alt + Number&lt;/td>
 &lt;td>Switch between Apps&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Win + Number&lt;/td>
 &lt;td>Switch between Desktops&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Caplock&lt;/td>
 &lt;td>Switch between Input Methods&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>Caplock(hold)&lt;/td>
 &lt;td>Switch between Upper/Lower&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;ol>
&lt;li>Download &lt;a href="https://github.com/Ciantic/VirtualDesktopAccessor/releases/tag/2024-01-25-windows11">VirtualDesktopAccessor.dll&lt;/a>&lt;/li>
&lt;li>Put the &lt;code>.dll&lt;/code> and &lt;code>.ahk&lt;/code> files in one folder, create a shortcut for &lt;code>Config.ahk&lt;/code>.&lt;/li>
&lt;li>Copy the shortcut to path &lt;code>C:\Users\&amp;lt;YourName&amp;gt;\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup&lt;/code> to make it auto startup.&lt;/li>
&lt;li>Install &lt;code>PowerToys&lt;/code>, remap &lt;code>LWin&lt;/code> and &lt;code>LAlt&lt;/code>.&lt;/li>
&lt;li>(Optional) Turn off window animation in windows settings.&lt;/li>
&lt;/ol>
&lt;h2 id="the-problem-of-windows-shortcuts">The Problem of Windows&amp;rsquo; Shortcuts&lt;/h2>
&lt;p>As we know, the Windows shortcut is very limited when switching between apps and desktops. For users who are not English native speakers, switching input method when typing is also not a good experience.&lt;/p>
&lt;p>Comparing with Windows, MacOS has a very powerful shortcut system. You can always use &lt;code>cmd + q&lt;/code> to close a window, &lt;code>caplock&lt;/code> to switch between input methods.&lt;/p>
&lt;p>DHH moved the MacOS&amp;rsquo; advantages to Linux. The Windows users can also refer to the Omakub project and build a more powerful development environment.&lt;/p></description></item><item><title>RESTful Web Service Cookbook 笔记</title><link>https://sund.site/posts/2024/restful-api-cookbook/</link><pubDate>Sat, 13 Jul 2024 16:12:34 +0800</pubDate><guid>https://sund.site/posts/2024/restful-api-cookbook/</guid><description>&lt;p>&lt;a href="https://www.oreilly.com/library/view/restful-web-services/9780596809140/">RESTful Web Service Cookbook&lt;/a> 是一本简短、精炼的 RESTful 接口设计指南。这篇文章（笔记）用来记录这本书中提到的重点。&lt;/p>
&lt;blockquote>
&lt;p>因为 RESTful 对后端开发来说实在太熟悉不过，所以我会省略掉那些习以为常的约定，只记录书中提到的、大多数开发者没有注意到的细节。&lt;/p>
&lt;/blockquote>
&lt;h2 id="http-method">HTTP Method&lt;/h2>
&lt;h3 id="get">GET&lt;/h3>
&lt;p>进行&lt;strong>安全&lt;/strong>与&lt;strong>幂等&lt;/strong>的信息获取。&lt;/p>
&lt;h3 id="post">POST&lt;/h3>
&lt;p>执行的目标是一个资源集合（工厂），而不是具体的 URI。&lt;/p>
&lt;p>适用场景：&lt;/p>
&lt;ul>
&lt;li>创建新的资源,把资源作为一个工厂。&lt;/li>
&lt;li>通过一个控制器资源来修改一个或多个资源。&lt;/li>
&lt;li>执行需要大数据输入（参数较多）的查询。&lt;/li>
&lt;li>&lt;strong>在其他 HTTP 方法看上去不合适时，执行不安全或非幂等的操作&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;p>解决方案：&lt;/p>
&lt;ul>
&lt;li>将一个已存在的资源标识为创建新资源的工厂。虽然您可以把任意资源用做工厂,但常见的做法是使用一个集合资源。&lt;/li>
&lt;li>让客户端向工厂资源提交附有需要创建资源的表述的 POST 请求。通过可选支持的 &lt;strong>Slug&lt;/strong> 头, 客户端可以向服务器建议一个名字,作为被创建资源的 URI 的一部分。&lt;/li>
&lt;li>资源创建之后,返回响应码 &lt;strong>201(Created)&lt;/strong>,并在 &lt;strong>Location&lt;/strong> 头中包含新创建资源的 URI。&lt;/li>
&lt;li>如果响应正文包含了新创建资源的完整表述,那么在 &lt;strong>Content-Location&lt;/strong> 头中包含新创建资源的 URI。&lt;/li>
&lt;/ul>
&lt;h3 id="put">PUT&lt;/h3>
&lt;p>仅在客户端可以控制 URI 的构成时,才使用 PUT 方法创建新资源。&lt;strong>（换句话说，PUT 也可以创建资源，但是仅限于客户端可以指定 URI）&lt;/strong>&lt;/p>
&lt;h2 id="确定资源对象的粒度">确定资源对象的粒度&lt;/h2>
&lt;p>应该以适合客户端使用模式的方式来设计资源,而不是基于现有的数据库或对象模型。&lt;/p>
&lt;ul>
&lt;li>可缓存性&lt;/li>
&lt;li>减小修改频率&lt;/li>
&lt;li>可变性——分离可变和不可变数据&lt;/li>
&lt;/ul>
&lt;h3 id="如何设计复合资源">如何设计复合资源?&lt;/h3>
&lt;p>&lt;strong>复合资源&lt;/strong>降低了统一接口的可见性,因为它们的表述中包含了和其他资源相重叠的数据。&lt;/p>
&lt;ul>
&lt;li>如果符合资源使用&lt;strong>频率不高&lt;/strong>，可以考虑用&lt;strong>缓存&lt;/strong>替代。&lt;/li>
&lt;li>考虑网络开销，复合资源会不会降低服务端吞吐量，增大延时。&lt;/li>
&lt;/ul>
&lt;h2 id="http-body">HTTP Body&lt;/h2>
&lt;p>以 JSON 格式的 Body 为例：&lt;/p>
&lt;ol>
&lt;li>最好包含一个指向 self 的链接&lt;/li>
&lt;li>如果分页，最好包含下一页的链接&lt;/li>
&lt;li>如果分页，要指示集合的大小（总数）&lt;/li>
&lt;li>如果查询对象是本地化的，添加一个属性来表示本地化内容的语言&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;John&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;urn:example:user:1234&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;link&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;rel&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;self&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;href&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://www.example.org/person/john&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;address&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;urn:example:address:4567&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;link&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;rel&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;self&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;#34;href&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;http://www.example.org/person/john/address&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="http-response">HTTP Response&lt;/h2>
&lt;ol>
&lt;li>对于客户端错误，返回 4xx 状态码 + Date （错误发生的时间）。&lt;/li>
&lt;li>对于服务端错误，返回 5xx 状态码 + Date （错误发生的时间）。&lt;/li>
&lt;li>Body 中要描述错误，如果有外部文档和链接可参考，在 Header 提供一个 Link 头或直接把链接写在 Body 里。&lt;/li>
&lt;li>为了后期追踪或分析，在服务器上记录了错误日志，应该提供一个可以找到该错误的标识符或链接。&lt;/li>
&lt;/ol>
&lt;h2 id="设计查询结构">设计查询结构&lt;/h2>
&lt;h3 id="设计查询请求">设计查询请求&lt;/h3>
&lt;ol>
&lt;li>为了缓存和性能，尽量避免范围查询。解决方法包括：
&lt;ul>
&lt;li>使用预定义查询&lt;/li>
&lt;li>也可以使用 HTTP Header： Range&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>避免使用通用语言（SQL、XPATH）的查询。&lt;/li>
&lt;li>避免 URI 和数据存储方式的紧耦合（前端把后端当作数据库）。&lt;/li>
&lt;li>对于参数较多，可以考虑使用 POST（因为 URI 长度有最大限制）
&lt;ul>
&lt;li>POST 接口的缺点是丧失了缓存能力&lt;/li>
&lt;li>POST 请求是不可缓存的，所以 Cache-Control 和 Expires 头无济于事&lt;/li>
&lt;li>解决缓存问题，可以让 POST 创建一个临时资源，把 link 返回前端，前端下次用 GET 获取该资源&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="设计查询响应结果">设计查询响应结果&lt;/h3>
&lt;ol>
&lt;li>返回集合。添加合理的缓存过期头。&lt;/li>
&lt;li>如果没有结果，应该返回&lt;strong>空集合&lt;/strong>。&lt;/li>
&lt;/ol></description></item><item><title>乐山游记</title><link>https://sund.site/posts/2024/leshan/</link><pubDate>Sun, 23 Jun 2024 18:50:51 +0800</pubDate><guid>https://sund.site/posts/2024/leshan/</guid><description>&lt;p>&lt;img src="https://sund.site/images/leshan/1.jpg" alt="">&lt;/p>
&lt;p>最近工作节奏放缓，业余时间也多了。我决定去乐山看看。久闻小吃之都的美名，但是来成都之后一直在全国出差，对这座高铁只要 50 分钟就能到达的城市，一次面都没见过，实在说不过去。&lt;/p>
&lt;p>作为时间管理小能手，我星期六早上 6 点就从家出发，8 点多到了乐山站。先找个早餐店弄一碗乐山豆腐脑吧，这是我在成都最爱的小吃之一，很期待原产地的风味。很多店铺都还没开门，一直走到了火车站对面的美食街才找到一家。坐下，一碗酥肉豆腐脑，一个牛肉咔饼。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/2.jpg" alt="">&lt;/p>
&lt;p>乐山豆腐脑和北方豆腐脑不太一样。它的主食是豆花和红薯粉丝。在粘稠的豆花粉丝汤里，加上炸黄豆、花生、牛肉（或者酥肉、鸡丝）、香菜。洒上辣椒油。有时候再放点薄脆。吃到嘴里是滑滑的咸辣汤汁裹着肉和黄豆的酥脆口感。乐山本地的豆腐脑用的豆花似乎和成都小店里有区别，是比嫩豆腐要稍微老一点的豆腐，汤也更入味。&lt;/p>
&lt;p>牛肉咔饼其实就是肉夹馍的四川版。把牛肉剁碎，再用葱姜蒜等调料用粉蒸肉的手法蒸熟，夹在一个软软的面饼里。一大早肉刚出锅，眼看老板夹着带热气的蒸肉放到饼里，香得很！&lt;/p>
&lt;p>吃饱喝足之后，第一个要去的地方是乐山大佛。&lt;/p>
&lt;p>乐山大佛在地图上很容易找到。乐山市面积不大，整个城市位于三江交汇处。乐山大佛就坐在三江口，眼观峨眉山。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/3.png" alt="">&lt;/p>
&lt;p>从地图上就能看出，大渡河泥沙更多，河水偏黄色。而岷江水是青绿色。在大佛前的交汇点，形成一条非常明显的分界线。&lt;/p>
&lt;p>打车 40 分钟到了景区，门票分两种：坐船和爬山。小小一座凌云山，被当地开辟出山和水两条收费路线，颇有四川小吃的特色，一菜多吃。&lt;/p>
&lt;p>我选择了更轻松的坐船。船从岷江的嘉州渡开船，行至大渡河交汇处，江水已经开始由青泛黄。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/4.jpg" alt="">&lt;/p>
&lt;p>复行十几分钟，就到了大佛脚下。大佛的左脚先映入眼帘，大佛身边左右护法已经被千年的江风磨平了棱角。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/5.jpg" alt="">&lt;/p>
&lt;p>乐山大佛项目立项于唐代，经过了三代项目经理才完工。到现代也在不断修缮。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/6.jpg" alt="">&lt;/p>
&lt;p>大佛周围的山崖有很多方孔，是用来搭建脚手架的。据说大佛外层原本有一座叫“大像阁”的七层建筑罩住大佛本体。但在历史上被毁掉了。在乐山博物馆还能看到很多相关资料。博物馆里还有一些有趣的豆知识：大佛头上的每一个圆圈都是一根长条状的石头，工匠先于大佛头部开凿出一个个插槽，再把这些长条状的“慧根”嵌进去。这可能是最早期的模块化设计。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/7.jpg" alt="">&lt;/p>
&lt;p>继续前行，绕过大佛，就能看到凌云山的栈道和像蚂蚁穴一样的山路，如果选了登山门票，你就会和其他游客像小蚂蚁一样出现在这里。凌云山其实只是江上的一座小山丘，能在这样一个光滑无附着的地方凿出道路，很佩服古人的毅力。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/8.jpg" alt="">&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/9.jpg" alt="">&lt;/p>
&lt;p>船往回开时，站在船尾能看到凌云山的远影形成一尊向右躺平的卧佛形象。这个躺平的形象，就是乐山的精神图腾。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/10.jpg" alt="">&lt;/p>
&lt;p>离开乐山大佛景区，继续探索乐山的美食吧！坐公交车前往上中顺特色街区。&lt;/p>
&lt;p>上中顺有很多小吃，比如叶婆婆钵钵鸡，但是因为排队人太多，一个人吃钵钵鸡又浪费了一大锅锅底，所以我这次就放弃了。直奔海汇源纸皮烧麦。&lt;/p>
&lt;p>海汇源的烧麦有鲜肉、牛肉、羊肉三种馅，还可以加钱把烧麦做成锅贴。我这次买的就是锅贴烧麦。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/11.jpg" alt="">&lt;/p>
&lt;p>乐山纸皮烧麦跟成都的烧麦、北方的烧麦都不一样。成都烧麦的馅是肉粒和糯米混合的，味道像广式粽子；北方是牛羊肉馅。乐山烧麦肉馅更像北方，皮非常薄，用油煎一下口感脆香。我过去吃烧麦最不喜欢吃它顶端的褶皱。因为蒸烧麦时那里经常蒸不熟，会有生面渣的口感。但是海汇源的烧麦完全没有这个问题，它把服务态度以外的卖点都做足了（服务态度不好也是四川小吃的特色）。海汇源的烧麦不但皮薄馅大，小料（四川叫蘸水）也很有特色，辣椒油里似乎还能吃出一点点柠檬汁的味道。&lt;/p>
&lt;p>从海汇源出来，我又在街边买了三串糖醋酱裹着的炸豆腐，算是乐山近年和绵绵冰（中式 Gelato）一样流行的街边小吃，不过味道一般，不作推荐。&lt;/p>
&lt;p>从上中顺街区往东南方向走，就能看到大渡河。沿着大渡河有几座渡口，可以眺望对面的凌云山。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/12.jpg" alt="">&lt;/p>
&lt;p>沿江有很多小亭子，当地老年人会聚到这里打一种叫“贰柒拾”的四川桥牌。这种牌有 1~10 十种数字和红黑两类花色。像打麻将一样可以吃碰胡，本质是个凑牌型算番数的概率计分游戏。&lt;/p>
&lt;p>据说之所以用这种长条形的纸牌，是因为过去物质匮乏，人们用工厂里填物料用的废纸来制作纸牌。这种乐山“贰柒拾”应该是四川长牌的一个变种，四川长牌在湖广地区也曾经流行，很多老年人都会打。但是现如今当地的年轻人也都沉迷王者荣耀了，再过几年只能在非遗博物馆听讲解员讲解玩法。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/13.jpg" alt="">&lt;/p>
&lt;p>我很欣赏乐山街头这种随处可见的景象：茶馆、打牌的小桌子。根本不需要特别的场地，一棵树周围的三米圈出一个阴凉，就是当地老年人的天然棋牌馆。随着年纪增长，我也越来越享受这种不容易变质的快乐，像下班回家看看体育运动，或者打开斗鱼看魔兽争霸比赛。这些赛事最大的特点是规则几乎不会变化，它们不像王者荣耀，几天不玩就陌生了，不会时不时给你更新个玩法，增加个人物。人不是计算机，更不是所谓“用户”，我不需要经常更新。年纪越大，多巴胺越是依赖那些简单、不变的东西。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/14.jpg" alt="">&lt;/p>
&lt;p>沿着大渡河：远处是镇坐千年的大佛，脚下三江汇聚，水花在岷江与大渡河之间，像用粉笔划出的分界线。近处是急流中游泳的老人。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/15.jpg" alt="">&lt;/p>
&lt;p>结束了乐山之行，赶回成都已经困得睁不开眼了，一觉睡到第二天下午两点。发现上午朋友在微信群里发了张图片。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/leshan/16.jpg" alt="">&lt;/p>
&lt;p>从乐山回来我突然领悟了那句话：如果浪费时间能让你感到快乐，那时间就没有浪费。&lt;/p></description></item><item><title>Ricoh GR 2 使用心得</title><link>https://sund.site/posts/2024/ricoh_gr2_sharing/</link><pubDate>Fri, 17 May 2024 23:07:29 +0800</pubDate><guid>https://sund.site/posts/2024/ricoh_gr2_sharing/</guid><description>&lt;p>买 GR2 已经很多年了，几年前写过一篇&lt;a href="https://sund.site/posts/2019/ricoh-gr2-settings/">Ricol GR 2 参数说明&lt;/a>，作为初学者分享了参数的说明。今天这篇分享一下这几年的使用心得。&lt;/p>
&lt;h2 id="机内裁剪">机内裁剪&lt;/h2>
&lt;p>GR2 作为 28mm 相机，对于普通人扫街来说，最大的痛点就是经常抓不到合适的构图。28mm 的优点是取景范围更大，可以捕捉更多环境信息，但是相对地，用它拍摄时经常混入太多杂乱的场景元素。&lt;/p>
&lt;p>但是好在 GR2 支持机内裁剪，可以把 28mm 裁切成 35mm 或 47mm 镜头。这让街拍时的构图更加灵活（当然以牺牲画质为代价）。&lt;/p>
&lt;h2 id="不同光圈的适合场景">不同光圈的适合场景&lt;/h2>
&lt;ul>
&lt;li>F2.8 室内的人物和场景&lt;/li>
&lt;li>F4 静物&lt;/li>
&lt;li>F5.6 均衡&lt;/li>
&lt;li>F8 图像最锐利的光圈设定&lt;/li>
&lt;li>F11 漂亮的星芒效果&lt;/li>
&lt;/ul>
&lt;h2 id="自定义参数">自定义参数&lt;/h2>
&lt;h3 id="fuji-胶片风格">FUJI 胶片风格&lt;/h3>
&lt;p>&lt;img src="https://raw.githubusercontent.com/stevedsun/blog-img/main/Pasted%20image%20(3).png" alt="">&lt;/p>
&lt;ul>
&lt;li>滤镜模式：正片。 饱和度：4、对比度：5、鲜明度：6&lt;/li>
&lt;li>白平衡：复合 AWB&lt;/li>
&lt;li>白平衡补偿：A：3、G：4&lt;/li>
&lt;li>曝光补偿：-1.0 ~ -1.0&lt;/li>
&lt;/ul>
&lt;p>上面这套参数模仿富士相机的胶片效果。对比鲜明度较高，有淡淡的绿色调。&lt;/p>
&lt;h3 id="日常蓝色调">日常蓝色调&lt;/h3>
&lt;p>&lt;img src="https://raw.githubusercontent.com/stevedsun/blog-img/main/Pasted%20image%20(2).png" alt="">&lt;/p>
&lt;ul>
&lt;li>滤镜模式：正片。 饱和度：7、对比度：3、鲜明度：7&lt;/li>
&lt;li>白平衡：复合 AWB&lt;/li>
&lt;li>白平衡补偿：B：7、M：0&lt;/li>
&lt;li>曝光补偿：-1.0 ~ -1.0&lt;/li>
&lt;/ul>
&lt;p>这套参数画面干净，呈现静谧的蓝色。适合拍摄日常冷色调题材的画面。&lt;/p>
&lt;h3 id="自然风小清新">自然风小清新&lt;/h3>
&lt;ul>
&lt;li>滤镜模式：正片。 饱和度：2、对比度：4、鲜明度：3&lt;/li>
&lt;li>白平衡：复合 AWB&lt;/li>
&lt;li>白平衡补偿：B：8、M：0&lt;/li>
&lt;li>曝光补偿：-1.0 ~ -1.0&lt;/li>
&lt;/ul>
&lt;p>适合旅行拍摄低对比度的小清新画面。&lt;/p>
&lt;h3 id="性冷淡">性冷淡&lt;/h3>
&lt;p>&lt;img src="https://raw.githubusercontent.com/stevedsun/blog-img/main/Pasted%20image%20(4).png" alt="">&lt;/p>
&lt;ul>
&lt;li>滤镜模式：轻微。 饱和度：9、对比度：5、鲜明度：9&lt;/li>
&lt;li>白平衡：CT：4200K&lt;/li>
&lt;li>白平衡补偿：B：8、M：2&lt;/li>
&lt;li>曝光补偿：-0.3 ~ -1.0&lt;/li>
&lt;/ul>
&lt;p>这套参数适合拍摄山脉、沙漠、城市人文等低静默、低色调的景物。&lt;/p>
&lt;p>上面两套参数来自&lt;a href="https://weibo.com/calcas">霜绝的分享&lt;/a>，他还有其他几套参数。&lt;/p>
&lt;h2 id="快拍模式snap-mode">快拍模式（Snap Mode）&lt;/h2>
&lt;p>快拍模式就是当你快速全按快门时，GR 按照你预先设置的快拍距离来快速捕捉画面的模式。&lt;/p>
&lt;p>快拍模式适合用 F5.6 ~ F6.0 的光圈，因为在这个光圈范围内，快拍对焦距离为 1&lt;del>5 米甚至更远，可以清晰地拍摄到 1&lt;/del>5 米范围的物体。&lt;/p>
&lt;p>关于这个模式的更多介绍推荐阿默的视频： &lt;a href="https://www.youtube.com/watch?v=JAZd5cM03NY">【ＧＲ浪漫】 GR III GR IIIx 感性で描く日常スナップ&lt;/a>。&lt;/p>
&lt;h2 id="tav-模式和-p-模式">Tav 模式和 P 模式&lt;/h2>
&lt;p>Tav 和 P 模式很相似，是 GR2 特有的一种模式。在 Tav 模式下，你可以手动调节 F 和 快门速度，让相机自动调节 ISO，这个好处就是你可以用一个相对较快的快门速度（比如 1/125）来保证抓拍街道上移动的人物的同时，很轻松地调节 F 来获得不同的取景深度。但是要切忌让 ISO 高于 800，噪点会明显增加。&lt;/p>
&lt;p>P 模式是我街拍用的比较多的模式，它固定了 ISO，你可以在 F 和快门二选一，另一个交给相机自动设置。这种适合在光线环境不好的情况下抓拍，尤其适合成都这种常年阴暗的城市 🤣&lt;/p></description></item></channel></rss>