<!doctype html><html lang=zh-CN><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://sund.site/favicon.ico><title>Cursor等AI编程工具的背后原理 | Steve Sun</title>
<meta name=title content="Cursor等AI编程工具的背后原理"><meta name=description content='在上一篇文章DeepWIKI 是如何工作的我分享了 DeepWIKI 可能的实现方式。文中留了一个问题：DeepWIKI 是如何将源代码仓库分块的？
这个问题的答案就是 AST 分块。
这篇文章我想分析一下两个软件开发辅助工具（Cursor, Cline）都是怎么实现「索引代码」的，其实它们和 DeepWIKI 的原理没有本质区别，都使用了 AST 分块的方法。
AST
Abstract Syntax Tree（AST，抽象语法树）是源代码的树形表示，它反映了代码的语法结构。在代码分块时，AST 可以帮助我们更好地理解代码的语义边界。
AST 在各种编译、分析源代码工具中都广泛使用。例如前端的 Babel、TypeScript 编译器（TSC），就利用 AST 来将 es6 或者 TypeScript 代码转换成浏览器可理解的 js 代码。
下面是一个简单的例子，展示 AST 如何把 TypeScript 代码转换成树形结构，假设有一段 TypeScript 函数：
function greet(name: string) {
  return "Hello, " + name;
}
经过 AST 工具的转换，它被抽象成下面的语法树结构：

SourceFile：

FunctionDeclaration

Identifier：&ldquo;greet&rdquo;
Parameter：

Identifier：&ldquo;name&rdquo;


Block：

ReturnStatement：

BinaryExpression：

StringLiteral：&ldquo;Hello, "
Identifier：&ldquo;name&rdquo;











后续编译器就可以遍历这个语法树，按节点转换成 Javascript 代码。
理解了 AST，就大致可以理解 DeepWIKI、甚至是 Cursor 这种代码编辑器如何构建代码索引的。
Cursor
在Cursor 的官方文档中，可以看到关于它如何索引用户代码的相关描述。
Cursor 会扫描用户代码仓库，计算文件哈希值并构建 Merkle 树，类似 Git 比较文件差异的原理，Cursor 用 Merkle 树来比较用户空间文件的差异，并且将用户修改过的文件以增量的方式上传到 Cursor 的服务器。'><meta name=keywords content="AI,"><link rel=canonical href=https://sund.site/posts/2025/ast-chunk/><meta property="og:url" content="https://sund.site/posts/2025/ast-chunk/"><meta property="og:site_name" content="Steve Sun"><meta property="og:title" content="Cursor等AI编程工具的背后原理"><meta property="og:description" content='在上一篇文章DeepWIKI 是如何工作的我分享了 DeepWIKI 可能的实现方式。文中留了一个问题：DeepWIKI 是如何将源代码仓库分块的？
这个问题的答案就是 AST 分块。
这篇文章我想分析一下两个软件开发辅助工具（Cursor, Cline）都是怎么实现「索引代码」的，其实它们和 DeepWIKI 的原理没有本质区别，都使用了 AST 分块的方法。
AST Abstract Syntax Tree（AST，抽象语法树）是源代码的树形表示，它反映了代码的语法结构。在代码分块时，AST 可以帮助我们更好地理解代码的语义边界。
AST 在各种编译、分析源代码工具中都广泛使用。例如前端的 Babel、TypeScript 编译器（TSC），就利用 AST 来将 es6 或者 TypeScript 代码转换成浏览器可理解的 js 代码。
下面是一个简单的例子，展示 AST 如何把 TypeScript 代码转换成树形结构，假设有一段 TypeScript 函数：
function greet(name: string) { return "Hello, " + name; } 经过 AST 工具的转换，它被抽象成下面的语法树结构：
SourceFile： FunctionDeclaration Identifier：“greet” Parameter： Identifier：“name” Block： ReturnStatement： BinaryExpression： StringLiteral：“Hello, " Identifier：“name” 后续编译器就可以遍历这个语法树，按节点转换成 Javascript 代码。
理解了 AST，就大致可以理解 DeepWIKI、甚至是 Cursor 这种代码编辑器如何构建代码索引的。
Cursor 在Cursor 的官方文档中，可以看到关于它如何索引用户代码的相关描述。
Cursor 会扫描用户代码仓库，计算文件哈希值并构建 Merkle 树，类似 Git 比较文件差异的原理，Cursor 用 Merkle 树来比较用户空间文件的差异，并且将用户修改过的文件以增量的方式上传到 Cursor 的服务器。'><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-06-02T07:58:17+08:00"><meta property="article:modified_time" content="2025-06-02T07:58:17+08:00"><meta property="article:tag" content="AI"><meta property="og:image" content="https://sund.site/images/share.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sund.site/images/share.png"><meta name=twitter:title content="Cursor等AI编程工具的背后原理"><meta name=twitter:description content='在上一篇文章DeepWIKI 是如何工作的我分享了 DeepWIKI 可能的实现方式。文中留了一个问题：DeepWIKI 是如何将源代码仓库分块的？
这个问题的答案就是 AST 分块。
这篇文章我想分析一下两个软件开发辅助工具（Cursor, Cline）都是怎么实现「索引代码」的，其实它们和 DeepWIKI 的原理没有本质区别，都使用了 AST 分块的方法。
AST Abstract Syntax Tree（AST，抽象语法树）是源代码的树形表示，它反映了代码的语法结构。在代码分块时，AST 可以帮助我们更好地理解代码的语义边界。
AST 在各种编译、分析源代码工具中都广泛使用。例如前端的 Babel、TypeScript 编译器（TSC），就利用 AST 来将 es6 或者 TypeScript 代码转换成浏览器可理解的 js 代码。
下面是一个简单的例子，展示 AST 如何把 TypeScript 代码转换成树形结构，假设有一段 TypeScript 函数：
function greet(name: string) { return "Hello, " + name; } 经过 AST 工具的转换，它被抽象成下面的语法树结构：
SourceFile： FunctionDeclaration Identifier：“greet” Parameter： Identifier：“name” Block： ReturnStatement： BinaryExpression： StringLiteral：“Hello, " Identifier：“name” 后续编译器就可以遍历这个语法树，按节点转换成 Javascript 代码。
理解了 AST，就大致可以理解 DeepWIKI、甚至是 Cursor 这种代码编辑器如何构建代码索引的。
Cursor 在Cursor 的官方文档中，可以看到关于它如何索引用户代码的相关描述。
Cursor 会扫描用户代码仓库，计算文件哈希值并构建 Merkle 树，类似 Git 比较文件差异的原理，Cursor 用 Merkle 树来比较用户空间文件的差异，并且将用户修改过的文件以增量的方式上传到 Cursor 的服务器。'><meta itemprop=name content="Cursor等AI编程工具的背后原理"><meta itemprop=description content='在上一篇文章DeepWIKI 是如何工作的我分享了 DeepWIKI 可能的实现方式。文中留了一个问题：DeepWIKI 是如何将源代码仓库分块的？
这个问题的答案就是 AST 分块。
这篇文章我想分析一下两个软件开发辅助工具（Cursor, Cline）都是怎么实现「索引代码」的，其实它们和 DeepWIKI 的原理没有本质区别，都使用了 AST 分块的方法。
AST Abstract Syntax Tree（AST，抽象语法树）是源代码的树形表示，它反映了代码的语法结构。在代码分块时，AST 可以帮助我们更好地理解代码的语义边界。
AST 在各种编译、分析源代码工具中都广泛使用。例如前端的 Babel、TypeScript 编译器（TSC），就利用 AST 来将 es6 或者 TypeScript 代码转换成浏览器可理解的 js 代码。
下面是一个简单的例子，展示 AST 如何把 TypeScript 代码转换成树形结构，假设有一段 TypeScript 函数：
function greet(name: string) { return "Hello, " + name; } 经过 AST 工具的转换，它被抽象成下面的语法树结构：
SourceFile： FunctionDeclaration Identifier：“greet” Parameter： Identifier：“name” Block： ReturnStatement： BinaryExpression： StringLiteral：“Hello, " Identifier：“name” 后续编译器就可以遍历这个语法树，按节点转换成 Javascript 代码。
理解了 AST，就大致可以理解 DeepWIKI、甚至是 Cursor 这种代码编辑器如何构建代码索引的。
Cursor 在Cursor 的官方文档中，可以看到关于它如何索引用户代码的相关描述。
Cursor 会扫描用户代码仓库，计算文件哈希值并构建 Merkle 树，类似 Git 比较文件差异的原理，Cursor 用 Merkle 树来比较用户空间文件的差异，并且将用户修改过的文件以增量的方式上传到 Cursor 的服务器。'><meta itemprop=datePublished content="2025-06-02T07:58:17+08:00"><meta itemprop=dateModified content="2025-06-02T07:58:17+08:00"><meta itemprop=wordCount content="225"><meta itemprop=image content="https://sund.site/images/share.png"><meta itemprop=keywords content="AI"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width-max:720px;--font-primary:Verdana, sans-serif;--font-secondary:monospace;--font-size-primary:1em;--font-size-secondary:0.8em;--body-bg-color:#fcfcfc;--bold-text-color:#222;--body-text-color:#444;--link-color:#3273dc;--link-visited-color:#8b6fcb;--table-border-color:#f2f2f2;--table-th-bg-color:#f2f2f2;--img-border-color:#f2f2f2;--code-bg-color:#f2f2f2;--code-text-color:#222;--blockquote-border-color:#666;--blockquote-text-color:#666;--upvoted-color:#FA8072}@media(prefers-color-scheme:dark){:root{--body-bg-color:#1c1c1c;--bold-text-color:#eee;--body-text-color:#ddd;--link-color:#8cc2dd;--link-visited-color:#c3b1ee;--table-border-color:#999;--table-th-bg-color:#999;--img-border-color:#999;--code-bg-color:#555;--code-text-color:#ddd;--blockquote-border-color:#ccc;--blockquote-text-color:#ccc}}body{font-family:var(--font-primary);font-size:var(--font-size-primary);margin:auto;padding:20px;max-width:var(--width-max);text-align:left;background-color:var(--body-bg-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--body-text-color)}h1,h2,h3,h4,h5,h6,strong,b{color:var(--bold-text-color)}h1,h2,h3,h4,h5,h6{margin:16px 0}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}.title{text-decoration:none;border:0}.title:hover{text-decoration:none}.title span{font-weight:400}nav a{margin-right:8px}textarea{width:100%;font-size:16px}input{font-size:14px}content{line-height:1.6}table{width:100%;border-collapse:collapse;border:1px solid var(--table-border-color);border-radius:4px}th,td{border:1px solid var(--table-border-color);padding:4px}th{background-color:var(--table-th-bg-color)}hr{border:0;border-top:1px dashed}img{max-width:100%;display:block;margin-left:auto;margin-right:auto;border:1px solid var(--img-border-color);border-radius:4px;content-visibility:auto;loading:lazy}img[src*="#minipic"]{max-width:50%;margin-left:0;margin-right:auto}i{font-style:normal}time{font-family:var(--font-secondary);font-size:15px}code{font-family:var(--font-secondary);background-color:var(--code-bg-color);color:var(--code-text-color);padding:2px;border-radius:4px}pre code{display:block;padding:16px;white-space:pre-wrap;overflow-x:auto}div.highlight pre{border-radius:4px}div.highlight code{background-color:var(--code-bg-color);color:var(--code-text-color)}blockquote{border-left:2px solid var(--blockquote-border-color);color:var(--blockquote-text-color);margin:0;padding-left:16px;font-style:normal}blockquote p{margin:0}footer{padding:25px 0;text-align:center;font-size:var(--font-size-secondary)}ul li:has(input){list-style-type:none;margin-left:-25.5px}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li span.grouped{flex:0 0 80px}ul.blog-posts li a:visited{color:var(--link-visited-color)}div.toc{position:fixed;top:50%;left:calc((100vw + var(--width-max))/2);transform:translateY(-50%);width:calc((90vw - var(--width-max))/2);max-height:80vh;overflow-y:auto;padding:20px 8px;z-index:99;&::-webkit-scrollbar { display:none; } -ms-overflow-style:none;scrollbar-width:none}div.toc ul{list-style-type:none;padding-left:0}div.toc ul li{margin:8px 0}div.toc ul li a{text-decoration:none;color:var(--blockquote-text-color)}div.toc ul li a:hover{color:var(--link-color)}button.upvote-btn{margin:0;padding:0;border:none;background:0 0;cursor:pointer;display:flex;flex-direction:column;align-items:center;color:var(--body-text-color)}button.upvoted{color:var(--upvoted-color)}span.upvote-count{margin-top:-4px;font-size:smaller}@media(max-width:500px){img[src*="#minipic"]{max-width:100%;margin-left:auto;margin-right:auto}div.toc{display:none}}</style><link rel=stylesheet href=https://chinese-fonts-cdn.deno.dev/packages/GuanKiapTsingKhai/dist/GuanKiapTsingKhai/result.css><style>body,div.post-body,h1,h2,h3,h4{font-family:microsoft yahei,pingfang sc,avenir,segoe ui,hiragino sans gb,STHeiti,microsoft sans serif,wenquanyi micro hei,sans-serif}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-XJJVVQ0LBH"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XJJVVQ0LBH")</script></head><body><header><a href=/ class=title><h1>Steve Sun</h1></a><nav><a href=/>Home</a>
<a href=/friends/>Friends</a>
<a href=/posts/>Posts</a></nav></header><main><h1>Cursor等AI编程工具的背后原理</h1><p><i><time datetime=2025-06-02 pubdate>02 Jun, 2025</time></i></p><content><p>在上一篇文章<a href=/posts/2025/build-deepwiki>DeepWIKI 是如何工作的</a>我分享了 DeepWIKI 可能的实现方式。文中留了一个问题：DeepWIKI 是如何将源代码仓库分块的？</p><p>这个问题的答案就是 AST 分块。</p><p>这篇文章我想分析一下两个软件开发辅助工具（Cursor, Cline）都是怎么实现「索引代码」的，其实它们和 DeepWIKI 的原理没有本质区别，都使用了 AST 分块的方法。</p><h2 id=ast>AST</h2><p><strong>Abstract Syntax Tree</strong>（<strong>AST</strong>，抽象语法树）是源代码的树形表示，它反映了代码的语法结构。在代码分块时，AST 可以帮助我们更好地理解代码的语义边界。</p><p>AST 在各种编译、分析源代码工具中都广泛使用。例如前端的 Babel、TypeScript 编译器（TSC），就利用 AST 来将 es6 或者 TypeScript 代码转换成浏览器可理解的 js 代码。</p><p>下面是一个简单的例子，展示 AST 如何把 TypeScript 代码转换成树形结构，假设有一段 TypeScript 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>greet</span>(<span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;Hello, &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>name</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>经过 AST 工具的转换，它被抽象成下面的语法树结构：</p><ul><li>SourceFile：<ul><li>FunctionDeclaration<ul><li>Identifier：&ldquo;greet&rdquo;</li><li>Parameter：<ul><li>Identifier：&ldquo;name&rdquo;</li></ul></li><li>Block：<ul><li>ReturnStatement：<ul><li>BinaryExpression：<ul><li>StringLiteral：&ldquo;Hello, "</li><li>Identifier：&ldquo;name&rdquo;</li></ul></li></ul></li></ul></li></ul></li></ul></li></ul><p>后续编译器就可以遍历这个语法树，按节点转换成 Javascript 代码。</p><p>理解了 AST，就大致可以理解 DeepWIKI、甚至是 Cursor 这种代码编辑器如何构建代码索引的。</p><h2 id=cursor>Cursor</h2><p>在<a href=https://www.cursor.com/ja/security#codebase-indexing>Cursor 的官方文档</a>中，可以看到关于它如何索引用户代码的相关描述。</p><p>Cursor 会扫描用户代码仓库，计算文件哈希值并构建 Merkle 树，类似 Git 比较文件差异的原理，Cursor 用 Merkle 树来比较用户空间文件的差异，并且将用户修改过的文件以增量的方式上传到 Cursor 的服务器。</p><p>被上传的文件，会被分块并嵌入，存储在 Turbopuffer 数据库中。这就是将源代码构建成 RAG 的过程。</p><p>这里的分块使用了 AST 工具将代码先结构化成语法树，然后将序列化后的语法树节点切成小块，最后嵌入成向量存储起来。</p><p>Turbopuffer 中不仅存储了向量化后的代码，而且存储了一些元信息，如这段代码的行号，源文件路径等。</p><p>当 Cursor 试图补全用户代码或根据上下文生成新代码时，Cursor 会检索这个 Turbopuffer 数据库，匹配到相似度最高的向量并得到这段代码的文件路径、行号。之后 Cursor 在用户代码仓库中查找到对应的源代码并放入 LLM 的系统上下文里。最后 LLM 返回生成的新代码给 Cursor。</p><p>有<a href=https://x.com/ProgramerJohann/status/1927296026861252934>网友</a>整理了这张流程图：</p><p><img src=/images/ast-chunk/cursor.png alt></p><h2 id=cline>Cline</h2><p><a href=https://cline.bot/blog/why-cline-doesnt-index-your-codebase-and-why-thats-a-good-thing>Cline 的官方博客</a> 可以让我们窥见它的实现思路。</p><p>Cline 是一个辅助编码的 AI Agent。Cline 并不上传代码并构建 RAG，而是主张更安全、可靠的方式管理用户的代码仓库。</p><p>下面是开发者对 Cline 原理的介绍：</p><blockquote><p>When you point Cline at a codebase, it doesn&rsquo;t immediately try to read every file. Instead, it begins by understanding the architecture. Using Abstract Syntax Trees (ASTs), Cline extracts a high-level map of your code – the classes, functions, methods, and their relationships. This happens through our list_code_definition_names tool, which provides structural understanding without requiring full implementation details.</p></blockquote><p>Cline 会使用它们的 <code>list_code_definition_names</code>工具将源代码转换成 AST。Cline 把这个 AST 当作整个源代码的「地图」。</p><p>当 Cline 自动执行任务时，它会分析当前要修改的文件，从文件构建 AST，从 AST 生成自然语言上下文（类似 DeepWIKI 把代码转换成文档）。并将上下文传给 LLM，让 LLM 决定下一步是该修改文件，还是需要查看另一个文件补充更多上下文。</p><p><img src=/images/ast-chunk/cline.png alt></p><p>如果说 Cursor 比较的是向量空间代码片段的相似度，Cline 就是将代码片段转换成自然语言的描述，然后让 LLM 通过语义的理解，在源代码仓库中搜寻线索，比较代码片段之间的语义相似度。</p><p>Cline 这种实现方式，显然更安全，企业用户不用担心 Cline 滥用源代码。但是副作用就是消耗了更多 Token。不断在不同文件之间获取上下文也花费更多时间。对于一些特殊情况，它甚至会在两个文件之间循环跳转，陷入死循环。</p><p>从我自身感受来说，Cline 在一些模型（Deepseek-r1, OpenAI-4o）的表现上比 Cursor 的 Agent 模式更好，因为 Cline 的语义理解比向量相似度更充分利用这些模型的自然语言能力。</p><p>但是对于专门为编程优化过的 Claude-Sonnet，则没有明显差异，这时就要看用户希望更高的安全性还是更快的响应速度。</p><h2 id=小结>小结</h2><p>本文主要介绍了代码编辑器如何利用抽象语法树（AST）来构建代码索引和实现代码补全功能。</p><p>总的来说，AST 是理解代码语法结构的重要工具,不同的实现方式各有优劣。</p><h2 id=扩展阅读>扩展阅读</h2><ul><li><a href=http://www.hubwiz.com/blog/ast-based-rag-code-chunking/>http://www.hubwiz.com/blog/ast-based-rag-code-chunking/</a></li></ul></content><p><a href=https://sund.site/tags/ai/>#AI</a></p><div class=toc><nav id=TableOfContents><ul><li><a href=#ast>AST</a></li><li><a href=#cursor>Cursor</a></li><li><a href=#cline>Cline</a></li><li><a href=#小结>小结</a></li><li><a href=#扩展阅读>扩展阅读</a></li></ul></nav></div></main><footer>Subscribe via <a href=/index.xml>RSS</a>.<br>Made with
<a href=https://github.com/rokcso/hugo-bearblog-neo/>Hugo Bear Neo</a>.<br>Copyright © 2013-2025, Steve Sun.
🗺️ <a href=/sitemap.xml>Sitemap</a>.</footer></body></html>