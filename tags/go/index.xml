<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Steve Sun</title><link>https://sund.site/tags/go/</link><description>Recent content in Go on Steve Sun</description><generator>Hugo</generator><language>zh-CN</language><copyright>Copyright © 2013-2025, Steve Sun.</copyright><lastBuildDate>Tue, 06 May 2025 10:35:41 +0800</lastBuildDate><follow_challenge><feedId>41397727810093074</feedId><userId>56666701051455488</userId></follow_challenge><atom:link href="https://sund.site/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go服务端性能的一般解决思路</title><link>https://sund.site/posts/2025/go-performance/</link><pubDate>Tue, 06 May 2025 10:35:41 +0800</pubDate><guid>https://sund.site/posts/2025/go-performance/</guid><description>&lt;p>最近遇到一个性能问题，客户反馈，在他们的 IPC 设备后台有两个 Go 语言编写的服务进程占用内存一直在上涨，最大时候达到了总内存的 40% 。其中一个进程就是我们日志采集 Agent。&lt;/p>
&lt;p>我首先怀疑是内存泄漏，因为过去发生过 goroutine 阻塞造成的内存泄漏（我在&lt;a href="https://sund.site/posts/2023/goroutine-leak/">Go 内存泄漏常见模式&lt;/a>中讨论过)，所以我先针对所有创建和释放 goroutine 的地方进行排查。&lt;/p>
&lt;p>在上一次教训之后，我们对代码单元测试层面做了 goruntine 内存泄漏的检测——使用&lt;code>go.uber.org/goleak&lt;/code>。只需要在单元测试开头加上一句:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">TestXXX&lt;/span>(t *testing.T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">defer&lt;/span> goleak.&lt;span style="color:#41a1c0">VerifyNone&lt;/span>(t)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它就会在测试结束后自动检查是否有残留的 goroutine 协程。对于一些延迟执行的后台 goroutine 可以在单元测试里用 wait 或者 sleep 等待后台释放再结束测试用例。&lt;/p>
&lt;p>经过第一轮排查可以排除代码本身 goroutine 造成的问题。于是我把注意力转向了另一个地方：定时任务。&lt;/p>
&lt;p>根据客户反馈，在无任何前台操作的情况下，内存也会缓慢上升。&lt;/p>
&lt;p>在我们代码里，使用了&lt;code>github.com/robfig/cron/v3&lt;/code>这个第三方包，它的作用是编排定时任务。用法是&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>c = cron.&lt;span style="color:#41a1c0">New&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c.&lt;span style="color:#41a1c0">AddFunc&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;@every 10s&amp;#34;&lt;/span>, callbackFunc)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种结构定义一个定时任务。它的实现也基于 goroutine，所以我把 go 自带的 pprof 加入到 main.go 的依赖中，重新编译了项目二进制文件并部署到测试环境上（使用跟用户相同的硬件配置）。这样启动项目后就可以在特定端口获取内存信息。（关于 pprof，你可以参考 &lt;a href="https://go.dev/blog/pprof">Profiling Go Programs&lt;/a>）&lt;/p>
&lt;p>我使用 pprof 的接口获取了不同时间间隔的 heap 数据&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>curl -o heap&lt;span style="color:#d0bf69">.1&lt;/span>.out http:&lt;span style="color:#6c7986">//127.0.0.1:6060/debug/pprof/heap
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">go&lt;/span> tool pprof -http=:&lt;span style="color:#d0bf69">8099&lt;/span> -base heap&lt;span style="color:#d0bf69">.1&lt;/span>.out heap&lt;span style="color:#d0bf69">.2&lt;/span>.out
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>比较两次结果的差异，在 Web UI 上选择 In Use Space 选项，可以查看到哪些内存没有释放。&lt;/p>
&lt;p>虽然经过第二轮排查，依然没有发现内存泄漏。但这一次我注意到服务中的一个定时任务会每隔 10 秒执行一次，执行过程中 CPU 占用率明显上升。在这个任务的代码里，它使用了&lt;code>github.com/shirou/gopsutil/process&lt;/code>这个第三方库来查询系统进程 ID 和进程名等信息。&lt;/p>
&lt;p>我查看它的源码后发现，这个库查询进程 ID 的方式，是把系统中所有的进程信息加载到内存中，然后匹配 ID 或者名称。因此，如果用户设备上的进程过多，就会每次查询时占用大量内存。&lt;/p>
&lt;p>在一个 10 秒执行一次的定时任务中调用这个库，显然是非常低效的。&lt;/p>
&lt;p>经过与客户进一步沟通，我们发现出现内存过高的两个进程中，另一个进程也有 CPU 占用过高的现象。于是我们让客户把 &lt;code>top&lt;/code> 命令的截图发给我们。在看到截图的一瞬间，问题的真相就浮出水面了:&lt;/p>
&lt;p>客户使用的 IPC 设备是性能比较低的版本，虽然内存较大，但 CPU 性能捉急。如果有多个进程同时执行后台任务，CPU 就会周期性打满，造成任务阻塞。而我们使用的第三方库基于 goroutine 来实现定时任务。在上一个任务被阻塞时，下一个任务依然会继续创建新的后台 goroutine，导致内存中的 goroutine 协程堆积地越来越多。&lt;/p>
&lt;p>这是一个定时任务的 CPU 占用过高，间隔过短，造成的 goroutine 阻塞问题。&lt;/p>
&lt;p>知道了原因，剩下的工作就是优化代码逻辑、更新版本、跟客户解释原因……&lt;/p>
&lt;p>以上就是这次排查 Go 服务性能问题的过程，如果你也遇到类似情况，希望对你有所帮助。&lt;/p></description></item><item><title>Go 语言的依赖倒置</title><link>https://sund.site/posts/2024/go-dependency-inject/</link><pubDate>Thu, 21 Nov 2024 11:26:22 +0800</pubDate><guid>https://sund.site/posts/2024/go-dependency-inject/</guid><description>&lt;blockquote>
&lt;p>这篇文章比较基础，是我在给 Java 程序员做 go 语言培训时用到的。&lt;/p>
&lt;/blockquote>
&lt;h2 id="为什么要做依赖倒置dip">为什么要做依赖倒置（DIP）？&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">依赖倒置&lt;/a>，或叫依赖反转、DIP，是软件开发非常重要的设计原则。很多程序员没有了解过相关知识，或者只从 Java Spring 知道大致思想。我今天想用一篇简短的文章，用 Go 语言做一个简单的例子，讲解一下怎么最简单地实现依赖倒置。&lt;/p>
&lt;p>如果你还不知道它是什么，可以参考 wiki 中的描述，或者阅读&lt;a href="https://martinfowler.com/articles/dipInTheWild.html">马丁福勒关于 DIP 的文章&lt;/a>。&lt;/p>
&lt;p>依赖倒置原则要解决一个软件开发中常见的风险：依赖。&lt;/p>
&lt;p>尝试回忆一下：&lt;/p>
&lt;ol>
&lt;li>当你尝试通过 Mock 方式屏蔽底层细节做测试时，你发现你要测试的类引用了大量框架提供的接口，导致你需要 mock 大量底层的实现。&lt;/li>
&lt;li>当你尝试修改一个旧的底层类，但是依赖该类的上层服务类太多，你一边担心造成副作用，一边在所有依赖的位置重构上层代码。&lt;/li>
&lt;/ol>
&lt;p>我们分析一下这两个场景：&lt;/p>
&lt;p>场景 1 里，应用类依赖于框架提供的实现，导致应用类很难从框架上剥离出来，业内处理这种问题的方法叫&lt;strong>控制反转&lt;/strong>（IoC, Inversion of Control）。即应用类不应该依赖框架，而是框架提供插槽一样，把应用类注册给框架，由框架统一调度应用，执行对应的方法。&lt;/p>
&lt;p>场景 2 里，服务类依赖底层类，导致底层修改难度越来越大。解决办法是&lt;strong>依赖注入&lt;/strong>（DI, Dependency Injection）。即上层类不直接引用底层类，而是在使用的地方把上层类依赖的底层类注入进来。&lt;/p>
&lt;p>把这两个场景结合起来，就是依赖倒置原则的核心：&lt;/p>
&lt;ul>
&lt;li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口。&lt;/li>
&lt;li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口。&lt;/li>
&lt;/ul>
&lt;p>这两个原则保证了代码中模块的高内聚、低耦合，同时给 Mock、迭代更新模块创造了条件。&lt;/p>
&lt;h2 id="用-go-语言实现它">用 Go 语言实现它&lt;/h2>
&lt;p>假设现在要从一个用户的服务中查询用户的信息。有两个接口，UserRepository 作为数据层负责查询数据库， UserService 负责业务逻辑，它依赖 UserRepository。同时为了方便测试，我们还要写一个 Mock 的数据层实现。 整个结构如下图。&lt;/p>
&lt;p>&lt;img src="https://sund.site/images/go-dependency-inject/example.png" alt="Go example">&lt;/p>
&lt;p>接下来非常轻松地，我们实现两个接口，并写了他们的实现类。同时我们还在 UserService 的实现类里写了一个 NewUserService，来把它依赖的 UserRepository 实现注入进来。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// 在 user_repository.go 中实现具体的接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">type&lt;/span> UserRepository &lt;span style="color:#fc5fa3">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#41a1c0">GetByID&lt;/span>(id &lt;span style="color:#fc5fa3">int&lt;/span>) (*User, &lt;span style="color:#fc5fa3">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#41a1c0">Save&lt;/span>(user *User) &lt;span style="color:#fc5fa3">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// ... 具体实现 UserRepository，略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// user_service.go 中实现
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">type&lt;/span> UserService &lt;span style="color:#fc5fa3">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#41a1c0">GetUser&lt;/span>(id &lt;span style="color:#fc5fa3">int&lt;/span>) (*User, &lt;span style="color:#fc5fa3">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#41a1c0">CreateUser&lt;/span>(name &lt;span style="color:#fc5fa3">string&lt;/span>, age &lt;span style="color:#fc5fa3">int&lt;/span>) &lt;span style="color:#fc5fa3">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// ... 具体实现 UserService，略
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">NewUserService&lt;/span>(repo UserRepository) UserService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">return&lt;/span> &amp;amp;UserServiceImpl{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repo: repo,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那么问题来了，可不可以直接在 &lt;code>user_service.go&lt;/code> 中直接把 repository 引用进来呢？显然不行，因为这样，两个模块就形成了依赖关系。&lt;/p>
&lt;p>这一点是依赖反转的核心，上层模块不直接引用下层模块，而是由执行的类来初始化 Service 并将依赖的下层服务注入进来。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// 在main.go 中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repo := &amp;amp;MySQLUserRepository{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userService := &lt;span style="color:#41a1c0">NewUserService&lt;/span>(repo)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，当编写测试 Mock 代码时，不需要修改任何代码逻辑，直接在测试中将&lt;code>NewUserService&lt;/code> 的参数替换成测试的假实例即可。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// 在 user_service_test.go 中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">TestUserService&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repo := &amp;amp;MockTestUserRepository{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> userService := &lt;span style="color:#41a1c0">NewUserService&lt;/span>(repo)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另外，如果数据层修改了实现，或者迁移到另外的数据库，你只需要修改两个地方：数据层的实现者和依赖注入者。对于调用者 &lt;code>UserService&lt;/code> 则完全不受到影响。整个项目也不会形成依赖陷阱。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>依赖倒置原则的两个核心原则：&lt;/p>
&lt;ul>
&lt;li>模块不依赖于其他模块，而是都依赖于抽象接口&lt;/li>
&lt;li>抽象接口不依赖于实现，而实现依赖于抽象接口&lt;/li>
&lt;/ul>
&lt;p>在 Go 语言中实现这两条原则并不麻烦，只要将原本的调用方-实现方，转换成注册方-调用方-实现方。在 Go 中也有一些库和框架实现依赖反转，其实核心思想并没有差异。&lt;/p></description></item><item><title>Go Server Side Events</title><link>https://sund.site/posts/2023/go-server-side-events/</link><pubDate>Wed, 13 Sep 2023 09:19:18 +0800</pubDate><guid>https://sund.site/posts/2023/go-server-side-events/</guid><description>&lt;p>Server-Sent Events (&lt;strong>SSE&lt;/strong>) is a technology that enables real-time communication between a web browser and a server. It allows the server to send updates or event notifications to the browser without the need for the browser to repeatedly make requests.&lt;/p>
&lt;p>SSE is often used in applications that require real-time updates, such as chat applications, social media feeds, stock market tickers, or notifications systems. It provides a lightweight and efficient way to deliver server-side updates to clients, improving responsiveness and reducing unnecessary network traffic.&lt;/p>
&lt;p>Following is an example of SSE in golang framework &lt;a href="https://github.com/gin-gonic/gin">Gin&lt;/a>:&lt;/p>
&lt;p>The Gin API handler &lt;code>SSEDemoGetStatus&lt;/code> will call &lt;code>service.CheckStatus()&lt;/code> every 10 seconds and respond to client with message event.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">SSEDemoGetStatus&lt;/span>(c *gin.Context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	chanStream := &lt;span style="color:#d0a8ff">make&lt;/span>(&lt;span style="color:#fc5fa3">chan&lt;/span> &lt;span style="color:#fc5fa3">interface&lt;/span>{}, StreamBufferSize)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	clientGone := c.Writer.&lt;span style="color:#41a1c0">CloseNotify&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">go&lt;/span> &lt;span style="color:#fc5fa3">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">defer&lt;/span> &lt;span style="color:#d0a8ff">close&lt;/span>(chanStream)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		ticker := time.&lt;span style="color:#41a1c0">NewTicker&lt;/span>(&lt;span style="color:#d0bf69">10&lt;/span>*time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">defer&lt;/span> ticker.&lt;span style="color:#41a1c0">Stop&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			status := service.&lt;span style="color:#41a1c0">CheckStatus&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			chanStream &amp;lt;- status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">case&lt;/span> &amp;lt;-ticker.C:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc5fa3">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">case&lt;/span> &amp;lt;-clientGone:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc5fa3">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	c.Writer.&lt;span style="color:#41a1c0">Header&lt;/span>().&lt;span style="color:#41a1c0">Set&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;Connection&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;keep-alive&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	c.Writer.&lt;span style="color:#41a1c0">Header&lt;/span>().&lt;span style="color:#41a1c0">Set&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;X-Accel-Buffering&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;no&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	c.Writer.&lt;span style="color:#41a1c0">Header&lt;/span>().&lt;span style="color:#41a1c0">Set&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;Cache-Control&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;no-cache&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	c.&lt;span style="color:#41a1c0">Stream&lt;/span>(&lt;span style="color:#fc5fa3">func&lt;/span>(w io.Writer) &lt;span style="color:#fc5fa3">bool&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">if&lt;/span> msg, ok := &amp;lt;-chanStream; ok {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			c.&lt;span style="color:#41a1c0">SSEvent&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;message&amp;#34;&lt;/span>, msg)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">return&lt;/span> &lt;span style="color:#fc5fa3">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		c.&lt;span style="color:#41a1c0">SSEvent&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;status&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;Done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">return&lt;/span> &lt;span style="color:#fc5fa3">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In this way, the client side will receive an HTTP request that establishes an TCP connection that continuely sent data from server side.&lt;/p>
&lt;p>What have to be noticed is the HTTP header. In my case, I need to tell web server (like Nginx) do not cache the TCP traffic. For the javascript &lt;a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource">EventSource&lt;/a> API, the header &lt;code>Connection: keep-alive&lt;/code> is important.&lt;/p>
&lt;p>A better place to put these headers is the Gin middleware function:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">HeadersMiddleware&lt;/span>() gin.HandlerFunc {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">return&lt;/span> &lt;span style="color:#fc5fa3">func&lt;/span>(c *gin.Context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		c.Writer.&lt;span style="color:#41a1c0">Header&lt;/span>().&lt;span style="color:#41a1c0">Set&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;Content-Type&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;text/event-stream&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		c.Writer.&lt;span style="color:#41a1c0">Header&lt;/span>().&lt;span style="color:#41a1c0">Set&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;Cache-Control&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;no-cache&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		c.Writer.&lt;span style="color:#41a1c0">Header&lt;/span>().&lt;span style="color:#41a1c0">Set&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;Connection&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;keep-alive&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		c.Writer.&lt;span style="color:#41a1c0">Header&lt;/span>().&lt;span style="color:#41a1c0">Set&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;Transfer-Encoding&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;chunked&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		c.&lt;span style="color:#41a1c0">Next&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Looking for more details please move to &lt;a href="https://github.com/gin-gonic/examples/blob/master/server-sent-event/main.go">Gin SSE example&lt;/a>.&lt;/p></description></item><item><title>Go 内存泄漏常见模式</title><link>https://sund.site/posts/2023/goroutine-leak/</link><pubDate>Tue, 27 Jun 2023 14:46:59 +0800</pubDate><guid>https://sund.site/posts/2023/goroutine-leak/</guid><description>&lt;p>最近在工作中排查 Go 语言内存泄漏问题时，发现&lt;a href="https://www.uber.com/blog/leakprof-featherlight-in-production-goroutine-leak-detection/">这篇 Uber 写的博客&lt;/a>，其中分享了几种常见的 goroutine 内存泄漏模式，于是把整理了 goroutine 的相关问题，希望更多人搜索到到这篇文章，帮助大家快速定位内存泄漏问题。&lt;/p>
&lt;h2 id="goroutine-内存泄漏的原因">Goroutine 内存泄漏的原因&lt;/h2>
&lt;p>Go 语言的内存泄漏通常因为错误地使用 goroutine 和 channel。例如以下几种情况：&lt;/p>
&lt;ol>
&lt;li>在 goroutine 里打开一个连接（如 gRPC）但是忘记 close&lt;/li>
&lt;li>在 goroutine 里的全局变量对象没有释放&lt;/li>
&lt;li>在 goroutine 里读 channel， 但是没有写入端，而被阻塞&lt;/li>
&lt;li>在 goroutine 里写入无缓冲的 channel，但是由于 channel 的读端被其他协程关闭而阻塞&lt;/li>
&lt;li>在 goroutine 里写入有缓冲的 channel，但是 channel 缓冲已满&lt;/li>
&lt;/ol>
&lt;p>这几种情况，通常掺杂在复杂的代码里逻辑里，很难调试发现问题。因此衍生出以下几种日常工作中&lt;strong>最容易出现问题的模式&lt;/strong>。&lt;/p>
&lt;h2 id="常见-goroutine-内存泄漏模式">常见 Goroutine 内存泄漏模式&lt;/h2>
&lt;h3 id="premature-function-return-功能过早返回">Premature Function Return /功能过早返回&lt;/h3>
&lt;p>一个 goroutine 要写入 channel，但是在另一个端意外退出导致 channel 读取的代码没有执行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">Example&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a := &lt;span style="color:#d0bf69">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c := &lt;span style="color:#d0a8ff">make&lt;/span>(&lt;span style="color:#fc5fa3">chan&lt;/span> &lt;span style="color:#fc5fa3">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">go&lt;/span> &lt;span style="color:#fc5fa3">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &amp;lt;- err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">if&lt;/span> a &amp;gt; &lt;span style="color:#d0bf69">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err := &amp;lt;-c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码中主进程在&lt;code>if a &amp;gt; 0&lt;/code> 处 return，导致 channel 无法写入而被阻塞。&lt;/p>
&lt;p>解决这种问题的一个思路是把无缓冲 channel 转化为缓冲大小为 1 的 channel。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>c := &lt;span style="color:#d0a8ff">make&lt;/span>(&lt;span style="color:#fc5fa3">chan&lt;/span> &lt;span style="color:#fc5fa3">error&lt;/span>, &lt;span style="color:#d0bf69">1&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有缓冲 channel 即使没有读取操作，也不会阻塞。&lt;/p>
&lt;h3 id="the-timeout-leak-超时泄漏">The Timeout Leak /超时泄漏&lt;/h3>
&lt;p>这是我们工作中遇到的问题，经常需要执行一个可能超时的异步操作时被使用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">Example&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timeoutOption := &lt;span style="color:#41a1c0">SomeTimeoutOption&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> done := &lt;span style="color:#d0a8ff">make&lt;/span>(&lt;span style="color:#fc5fa3">chan&lt;/span> any)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">go&lt;/span> &lt;span style="color:#fc5fa3">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> done &amp;lt;- result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">case&lt;/span> &amp;lt;- done:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">case&lt;/span> &amp;lt;- timeoutOption.&lt;span style="color:#41a1c0">Timeout&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这段代码里，一旦 timeoutOption 操作超时，就会通知 select，接着程序退出，于是 goroutine 写入 done 的操作被阻塞而无法退出。&lt;/p>
&lt;p>解决思路同上一个模式，用有缓冲 channel 替代无缓冲 channel。&lt;/p>
&lt;h3 id="the-ncast-leak-多端读写泄漏">The NCast Leak /多端读写泄漏&lt;/h3>
&lt;p>如果 channel 的读端只有一个，但是写端有多个，就会发生这种情况。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">Example&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c := &lt;span style="color:#d0a8ff">make&lt;/span>(&lt;span style="color:#fc5fa3">chan&lt;/span> any)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">for&lt;/span> _, i := &lt;span style="color:#fc5fa3">range&lt;/span> items {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">go&lt;/span> &lt;span style="color:#fc5fa3">func&lt;/span>(c &lt;span style="color:#fc5fa3">chan&lt;/span> any) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &amp;lt;- result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data := &amp;lt;- c
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种情况也适用于“多个写端一个读端”的情况，解决方法是把 channel 设置成和写或读数量一致的缓冲数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>c := &lt;span style="color:#d0a8ff">make&lt;/span>(&lt;span style="color:#fc5fa3">chan&lt;/span> any, &lt;span style="color:#d0a8ff">len&lt;/span>(items))
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="channel-iteration-misuse-通道迭代误用">Channel Iteration Misuse /通道迭代误用&lt;/h3>
&lt;p>Go 支持一种特性 &lt;a href="https://gobyexample.com/range-over-channels">&amp;ldquo;Range over channels&amp;rdquo;&lt;/a>, 可以用 range 来循环读取 channel 的内容。&lt;/p>
&lt;p>但是一旦读取不到内容，range 就会等待 channel 的写入，而 range 如果正好在 goroutine 内部，这个 goroutine 就会被阻塞。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">Example&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wg := &amp;amp;sync.WaitGroup{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c := &lt;span style="color:#d0a8ff">make&lt;/span>(&lt;span style="color:#fc5fa3">chan&lt;/span> any, &lt;span style="color:#d0bf69">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">for&lt;/span> _, i := items {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wg.&lt;span style="color:#41a1c0">Add&lt;/span>(&lt;span style="color:#d0bf69">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">go&lt;/span> &lt;span style="color:#fc5fa3">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> c &amp;lt;- data
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">go&lt;/span> &lt;span style="color:#fc5fa3">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#fc5fa3">for&lt;/span> data := &lt;span style="color:#fc5fa3">range&lt;/span> c {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wg.&lt;span style="color:#41a1c0">Done&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wg.&lt;span style="color:#41a1c0">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>解决这个问题的方式手动定义关闭 channel。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>wg := &amp;amp;sync.WaitGroup{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>c := &lt;span style="color:#d0a8ff">make&lt;/span>(&lt;span style="color:#fc5fa3">chan&lt;/span> any, &lt;span style="color:#d0bf69">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">defer&lt;/span> &lt;span style="color:#d0a8ff">close&lt;/span>(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">//...
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样在 WaitGroup 全部结束后，主程序会关闭 channel，从而让异步的 goroutine 内部的 range 退出循环等待。&lt;/p>
&lt;h2 id="小结">小结&lt;/h2>
&lt;p>Goroutine 内存泄漏是 Go 语言最容易发生的内存泄漏情况，它通常伴随着错误地使用 goroutine 和 channel。而 channel 的特殊用法如 select 和 range 又让 channel 阻塞变得更加隐蔽不易发现，进而增加排查内存泄漏的难度。&lt;/p>
&lt;p>在写 goroutine 和调试内存泄漏问题时，要重点关注 channel 相关的操作，尤其涉及到文中列举的四类模式：功能过早返回、超时泄漏、多端读写泄漏、通道迭代误用。&lt;/p></description></item><item><title>Implementing a Prometheus Exporter for Fluent-bit</title><link>https://sund.site/posts/2022/implementing-prometheus-exporter-for-fluentbit/</link><pubDate>Thu, 24 Nov 2022 12:26:23 +0800</pubDate><guid>https://sund.site/posts/2022/implementing-prometheus-exporter-for-fluentbit/</guid><description>&lt;h2 id="background">Background&lt;/h2>
&lt;p>Fluent-bit is a great tool for logging and monitoring, many teams are using it to collect metrics and logs. Prometheus is also a popular tool for metrics analysis, but if you want to output Fluent-bit data to Prometheus, the only way is to use the node-exporter input plugin, which has fixed metrics and data format.&lt;/p>
&lt;p>In our case, we want to export specific input data into Prometheus, therefore we have to implement our Prometheus exporter in a customized Fluent-bit output plugin.&lt;/p>
&lt;p>Today I want to share the final solution for this case. The complete demo code can be found on this Github repo: &lt;a href="https://github.com/stevedsun/fluent-bit-output-prometheus-demo">https://github.com/stevedsun/fluent-bit-output-prometheus-demo&lt;/a>&lt;/p>
&lt;h2 id="fluent-bit-output-plugin">Fluent-bit Output Plugin&lt;/h2>
&lt;p>Fluent-bit provides a way to implement your Golang plugin. (See &lt;a href="https://docs.fluentbit.io/manual/v/1.9-pre/development/golang-output-plugins">Fluent-bit Go Output Plugin&lt;/a>)&lt;/p>
&lt;p>We can run an asynchronous HTTP server as the Prometheus exporter when Fluent-bit plugin initializing, and transform the Fluent-bit records to Prometheus metrics format when Fluent-bit flushes a record to the output plugin.&lt;/p>
&lt;p>To implement a Fluent-bit output plugin, there are four call-back functions we need to overwrite.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">//export FLBPluginRegister
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">FLBPluginRegister&lt;/span>(def unsafe.Pointer) &lt;span style="color:#fc5fa3">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// Here we define the plugin name and description.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	&lt;span style="color:#fc5fa3">return&lt;/span> output.&lt;span style="color:#41a1c0">FLBPluginRegister&lt;/span>(def, &lt;span style="color:#fc6a5d">&amp;#34;promexporter&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;Prometheus Exporter&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">//export FLBPluginInit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">FLBPluginInit&lt;/span>(plugin unsafe.Pointer) &lt;span style="color:#fc5fa3">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// We can extract output plugin parameters from `FLBPlguinConfigKey`.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	user := output.&lt;span style="color:#41a1c0">FLBPluginConfigKey&lt;/span>(plugin, &lt;span style="color:#fc6a5d">&amp;#34;username&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	passwd := output.&lt;span style="color:#41a1c0">FLBPluginConfigKey&lt;/span>(plugin, &lt;span style="color:#fc6a5d">&amp;#34;password&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// Here we can run a new Prometheus exporter server.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	&lt;span style="color:#41a1c0">NewExporter&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">return&lt;/span> output.FLB_OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">//export FLBPluginFlushCtx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">FLBPluginFlushCtx&lt;/span>(ctx, data unsafe.Pointer, length C.&lt;span style="color:#fc5fa3">int&lt;/span>, tag *C.char) &lt;span style="color:#fc5fa3">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// Here we process every record, extract it and ship to exporter
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	dec := output.&lt;span style="color:#41a1c0">NewDecoder&lt;/span>(data, &lt;span style="color:#d0a8ff">int&lt;/span>(length))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#6c7986">// Extract Record
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>		ret, _, record := output.&lt;span style="color:#41a1c0">GetRecord&lt;/span>(dec)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">if&lt;/span> ret != &lt;span style="color:#d0bf69">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">for&lt;/span> k, v := &lt;span style="color:#fc5fa3">range&lt;/span> record {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#6c7986">// You have to extract record here, ship them to exporter.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">return&lt;/span> output.FLB_OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">//export FLBPluginExit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">FLBPluginExit&lt;/span>() &lt;span style="color:#fc5fa3">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">if&lt;/span> err := server.srv.&lt;span style="color:#41a1c0">Shutdown&lt;/span>(context.&lt;span style="color:#41a1c0">TODO&lt;/span>()); err != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#d0a8ff">panic&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// Here we have to close go channel and daemon exporter server.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	&lt;span style="color:#d0a8ff">close&lt;/span>(collector.buff)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	server.wg.&lt;span style="color:#41a1c0">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">return&lt;/span> output.FLB_OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Note&lt;/strong>! You should not remove the comment lines above the function, they are important for building .so files.&lt;/p>
&lt;pre>&lt;code> //export FLBPluginExit
&lt;/code>&lt;/pre>
&lt;h2 id="the-exporter-http-server">The Exporter HTTP Server&lt;/h2>
&lt;p>The next step is to implement the HTTP server and make it run on a daemon.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// Here we start a background server on port 8989, the server will handle `/metrics` path, prometheus exporter will implement the handler.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">startHttpServer&lt;/span>(wg *sync.WaitGroup, reg *prometheus.Registry) *http.Server {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	srv := &amp;amp;http.Server{Addr: &lt;span style="color:#fc6a5d">&amp;#34;:8989&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	http.&lt;span style="color:#41a1c0">Handle&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;/metrics&amp;#34;&lt;/span>, promhttp.&lt;span style="color:#41a1c0">HandlerFor&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		reg,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		promhttp.HandlerOpts{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			EnableOpenMetrics: &lt;span style="color:#fc5fa3">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			Registry: reg,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">go&lt;/span> &lt;span style="color:#fc5fa3">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">defer&lt;/span> wg.&lt;span style="color:#41a1c0">Done&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">if&lt;/span> err := srv.&lt;span style="color:#41a1c0">ListenAndServe&lt;/span>(); err != http.ErrServerClosed {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#41a1c0">Println&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;ListenAndServe():&amp;#34;&lt;/span>, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">return&lt;/span> srv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">NewExporter&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	reg := prometheus.&lt;span style="color:#41a1c0">NewRegistry&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	reg.&lt;span style="color:#41a1c0">MustRegister&lt;/span>(collector)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// Here, we start a new HTTP server and save the instance object into a golang sync.WaitGroup, so that we can watch its status in `FLBPluginExit`
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	server.wg = &amp;amp;sync.WaitGroup{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	server.wg.&lt;span style="color:#41a1c0">Add&lt;/span>(&lt;span style="color:#d0bf69">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	server.srv = &lt;span style="color:#41a1c0">startHttpServer&lt;/span>(server.wg, reg)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="the-exporter-collector">The Exporter Collector&lt;/h2>
&lt;p>Now we have an HTTP server, but if we want to make it an exporter, we have to define the &lt;strong>collector&lt;/strong>. The collector is a Prometheus concept that implements two call-back functions:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// Here for instance, we define metrics to collect cpu info, which reuses the default Fluent-bit CPU metrics input data
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">NewMyCollector&lt;/span>() *myCollector {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">return&lt;/span> &amp;amp;myCollector{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		metrics: &lt;span style="color:#fc5fa3">map&lt;/span>[&lt;span style="color:#fc5fa3">string&lt;/span>]*prometheus.Desc{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc6a5d">&amp;#34;cpu&amp;#34;&lt;/span>: prometheus.&lt;span style="color:#41a1c0">NewDesc&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc6a5d">&amp;#34;cpu&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc6a5d">&amp;#34;Collect CPU usage&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				[]&lt;span style="color:#fc5fa3">string&lt;/span>{&lt;span style="color:#fc6a5d">&amp;#34;cpu&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;mode&amp;#34;&lt;/span>}, &lt;span style="color:#fc5fa3">nil&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#6c7986">// this buff is a golang channel object, which receive data sending from `FLBPluginFlushCtx` function
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>		buff: &lt;span style="color:#d0a8ff">make&lt;/span>(&lt;span style="color:#fc5fa3">chan&lt;/span> cpuMetrics),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// `Describe` send our metrics name and defination to Prometheus exporter
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> (collector *myCollector) &lt;span style="color:#41a1c0">Describe&lt;/span>(ch &lt;span style="color:#fc5fa3">chan&lt;/span>&amp;lt;- *prometheus.Desc) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">for&lt;/span> _, desc := &lt;span style="color:#fc5fa3">range&lt;/span> collector.metrics {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		ch &amp;lt;- desc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// `Collect` will read data from golang channel `buff` and send data to HTTP server handler
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> (collector *myCollector) &lt;span style="color:#41a1c0">Collect&lt;/span>(ch &lt;span style="color:#fc5fa3">chan&lt;/span>&amp;lt;- prometheus.Metric) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">for&lt;/span> _, desc := &lt;span style="color:#fc5fa3">range&lt;/span> collector.metrics {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">case&lt;/span> metric := &amp;lt;-collector.buff:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#41a1c0">Println&lt;/span>(metric.cpu, metric.mode, metric.value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			ch &amp;lt;- prometheus.&lt;span style="color:#41a1c0">MustNewConstMetric&lt;/span>(desc, prometheus.GaugeValue, metric.value, metric.cpu, metric.mode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">var&lt;/span> collector = &lt;span style="color:#41a1c0">NewMyCollector&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="building-so-file-and-running-in-fluent-bit">Building so file and running in Fluent-bit&lt;/h2>
&lt;p>Last but not least, building Golang plugin into so file.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go build -buildmode=c-shared -o out_prom_exporter.so prom_exporter.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Run Fluent-bit with CLI flags:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>fluent-bit -v -e ./out_prom_exporter.so -i cpu -o promexporter
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s all steps to implement a customized Fluent-bit Prometheus exporter plugin. To see more details, please go to the Github repo &lt;a href="https://github.com/stevedsun/fluent-bit-output-prometheus-demo%3E">https://github.com/stevedsun/fluent-bit-output-prometheus-demo&amp;gt;&lt;/a>.&lt;/p></description></item><item><title>Building a File Parser</title><link>https://sund.site/posts/2022/2022-5-8_lexer_design/</link><pubDate>Sun, 08 May 2022 14:00:00 +0800</pubDate><guid>https://sund.site/posts/2022/2022-5-8_lexer_design/</guid><description>&lt;p>Last week, after reading this article - &lt;a href="https://www.aaronraff.dev/blog/how-to-write-a-lexer-in-go">How to Write a Lexer in Go&lt;/a>, I found that it is not so difficult to design a configuration file parser by this article&amp;rsquo;s mindset. Then I tried to write a fluent-bit configuration parser and finally got this &lt;a href="https://github.com/stevedsun/go-fluentbit-conf-parser">Fluent-Bit configuration parser for Golang&lt;/a>.&lt;/p>
&lt;p>In this article, I want to introduce how to parse Fluent-bit configuration &lt;code>.conf&lt;/code> file, and the thinking behind it.&lt;/p>
&lt;h2 id="fluent-bit-configuration-format-and-schema">Fluent-bit configuration format and schema&lt;/h2>
&lt;pre tabindex="0">&lt;code>[FIRST_SECTION]
 Key1 some value
 Key2 another value

[SECOND_SECTION]
 KeyN 3.14
&lt;/code>&lt;/pre>&lt;p>Here is a classic mode configuration of Fluent-bit, it includes two parts:&lt;/p>
&lt;ul>
&lt;li>Section&lt;/li>
&lt;li>Key/value pair&lt;/li>
&lt;/ul>
&lt;p>First of all, we need to define a struct that represents the Fluent-bit configuration file.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">type&lt;/span> FluentBitConf &lt;span style="color:#fc5fa3">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Sections []Section
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">type&lt;/span> Section &lt;span style="color:#fc5fa3">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Name &lt;span style="color:#fc5fa3">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Entries []Entry
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">type&lt;/span> Entry &lt;span style="color:#fc5fa3">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Key &lt;span style="color:#fc5fa3">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Value &lt;span style="color:#fc5fa3">interface&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once we have a struct, the next step is to parse tokens from the file and save their values into golang struct. We can copy the logic of the lexer to develop our fluent bit parser.&lt;/p>
&lt;p>In a lexer program, the target characters which we want to parse out are called &amp;ldquo;Token&amp;rdquo;, Token is also the keyword that our parser program is searching for. A parser program will read characters in a file one by one, whenever it found a token, the parser saves the value between tokens into the final structure and go ahead.&lt;/p>
&lt;h2 id="parse-a-single-token">Parse a single token&lt;/h2>
&lt;p>If we want to parse a Section, we have to make the parser read characters one by one and stop at &lt;code>[&lt;/code> character, which means the beginning of a Section. The parser must save the current state as &lt;code>t_section&lt;/code> and keep the parser reading until &lt;code>]&lt;/code> character, the word between &lt;code>[&lt;/code> and &lt;code>]&lt;/code> is the Section value we need to persist into go struct.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// define some tag to tell parser state
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">const&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	t_section = &lt;span style="color:#fc5fa3">iota&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> (parser *FluentBitConfParser) &lt;span style="color:#41a1c0">Parse&lt;/span>() *FluentBitConf {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">var&lt;/span> currSection *Section = &lt;span style="color:#fc5fa3">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// read charector one by one
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>		r, _, err := parser.reader.&lt;span style="color:#41a1c0">ReadRune&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">if&lt;/span> err != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// stop at the end of file
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>			&lt;span style="color:#fc5fa3">if&lt;/span> err == io.EOF {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc5fa3">if&lt;/span> currSection != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					parser.Conf.Sections = &lt;span style="color:#d0a8ff">append&lt;/span>(parser.Conf.Sections, *currSection)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc5fa3">return&lt;/span> parser.Conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">return&lt;/span> parser.Conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">switch&lt;/span> r {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">case&lt;/span> &lt;span style="color:#fc6a5d">&amp;#39;\n&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">case&lt;/span> &lt;span style="color:#fc6a5d">&amp;#39;[&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#6c7986">// save last config item
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>			&lt;span style="color:#fc5fa3">if&lt;/span> currSection != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				parser.Conf.Sections = &lt;span style="color:#d0a8ff">append&lt;/span>(parser.Conf.Sections, *currSection)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#6c7986">// create new config item
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>			currSection = &amp;amp;Section{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				Name: &lt;span style="color:#fc6a5d">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				Entries: []Entry{},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			parser.token = t_section
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">if&lt;/span> unicode.&lt;span style="color:#41a1c0">IsSpace&lt;/span>(r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc5fa3">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// here is important function, read the charectors after token-chareactor and save them into struct
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>			strValue, _ := parser.&lt;span style="color:#41a1c0">parseString&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">switch&lt;/span> parser.token {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">case&lt;/span> t_section:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				currSection.Name = strValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				parser.token = t_entry_key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In function &lt;code>parser.parseString()&lt;/code>, we have to read until the end of a value (for section, it&amp;rsquo;s &lt;code>]&lt;/code>), then return the value.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> (parser *FluentBitConfParser) &lt;span style="color:#41a1c0">parseString&lt;/span>() (&lt;span style="color:#fc5fa3">string&lt;/span>, &lt;span style="color:#fc5fa3">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">var&lt;/span> val &lt;span style="color:#fc5fa3">string&lt;/span> = &lt;span style="color:#fc6a5d">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">if&lt;/span> err := parser.reader.&lt;span style="color:#41a1c0">UnreadRune&lt;/span>(); err != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">return&lt;/span> &lt;span style="color:#fc6a5d">&amp;#34;&amp;#34;&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		r, _, err := parser.reader.&lt;span style="color:#41a1c0">ReadRune&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">if&lt;/span> err != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">if&lt;/span> err == io.EOF {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc5fa3">return&lt;/span> val, &lt;span style="color:#fc5fa3">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">return&lt;/span> &lt;span style="color:#fc6a5d">&amp;#34;&amp;#34;&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">if&lt;/span> parser.token == t_section &amp;amp;&amp;amp; r == &lt;span style="color:#fc6a5d">&amp;#39;]&amp;#39;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">return&lt;/span> val, &lt;span style="color:#fc5fa3">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		val = val + &lt;span style="color:#d0a8ff">string&lt;/span>(r)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s all logic for parsing a section. Parse key/value pair is the same process, just note to make the parser know which state it is and save values between whitespace or &lt;code>\n&lt;/code>, you can see the code in &lt;a href="https://github.com/stevedsun/go-fluentbit-conf-parser/blob/master/parser.go">the Github repo&lt;/a>.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>To parse a configuration file, we have to&lt;/p>
&lt;ul>
&lt;li>Defining token (key characters)&lt;/li>
&lt;li>Reading characters and looking for a token&lt;/li>
&lt;li>Saving current state to tell parser which struct the following characters belong&lt;/li>
&lt;/ul></description></item></channel></rss>