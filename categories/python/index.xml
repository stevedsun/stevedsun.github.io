<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Python - Category - 電波障害</title><link>https://sund.site/categories/python/</link><description>Python - Category - 電波障害</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 19 Jan 2023 08:05:27 +0800</lastBuildDate><atom:link href="https://sund.site/categories/python/" rel="self" type="application/rss+xml"/><item><title>Python 依赖管理工具的研究</title><link>https://sund.site/posts/2023/python-packaging/</link><pubDate>Thu, 19 Jan 2023 08:05:27 +0800</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2023/python-packaging/</guid><description><![CDATA[<h2 id="太长不读">太长不读</h2>
<p>如果你从事工程项目，<a href="https://python-poetry.org/" target="_blank" rel="noopener noreffer ">poetry</a> 是目前最好的方案，但是如果你不喜欢 Python 的 virtualenv，可以试试 <a href="https://pdm.fming.dev/latest/" target="_blank" rel="noopener noreffer ">pdm</a>。</p>
<h2 id="混乱的-python">混乱的 Python</h2>
<p>Python 的依赖管理工具 <code>pip</code> 一直被众多开发者吐槽。从我个人角度，<code>pip</code> 有三点致命缺陷：</p>
<ul>
<li>无法解决 Python 依赖环境的隔离问题</li>
<li>依赖管理文件 <code>requirements.txt</code> 无法真正开箱即用</li>
<li>打包部署非常麻烦，需要手动配置</li>
</ul>
<h3 id="环境隔离问题">环境隔离问题</h3>
<p>Python 的依赖库可以安装到系统全局，也可以安装到用户目录（<code>/home/${USER}/.local</code>）。但如果你同时管理多个 Python 项目，就需要将不同项目的依赖拆分到不同的文件夹分开管理。</p>
<p>传统方式是基于 virtualenv 创建隔离的 Python bin 文件和项目依赖的虚拟环境（所谓虚拟环境并不是虚拟机，只是个绑定 terminal session 的命令环境）。这种方式的缺点是：</p>
<ul>
<li>开发者需要经常关注“我现在处于哪个项目目录？我需要切换到当前虚拟环境里吗？”之类的问题。</li>
<li>virtualenv 只解决环境隔离，但是无法同步更新依赖文件、打包发布。</li>
</ul>
<h3 id="依赖安装问题">依赖安装问题</h3>
<p>Python 管理依赖的手段，最早是手动执行<code>pip install xxx</code>来安装依赖，最后 <code>pip freeze</code> 来导出依赖列表到一个 <code>requirements.txt</code> 文件里。但是这个 txt 文件非常令人困惑。</p>
<ul>
<li>不像 NodeJS 那么方便，想要升、降级某个依赖版本，无法自动同步到 txt 文件里。</li>
<li>平铺式地列出了所有一级、二级依赖包（即依赖包的依赖包）。因为 Python 某些依赖又基于系统上安装的 C 库版本，这就导致不同系统环境上执行 <code>pip install -r requirements.txt</code> 得到的效果并不一致，经常报错。</li>
</ul>
<h3 id="打包部署问题">打包部署问题</h3>
<p>Python 一般使用 <code>wheel</code> 打包二进制，它只解决打包问题，环境依赖是靠 pip 和 setuptools 完成，所以使用 wheel 你仍然要操心环境隔离和依赖管理问题。</p>
<p>另外基于 Python 各版本之间兼容性问题和底层实现上的不可抗拒力量，wheel 也经常会莫名其妙失败。</p>
<h2 id="现有的解决方案">现有的解决方案</h2>
<p>一直以来，出现过 <code>pipx</code>，<code>pipenv</code>， <code>conda</code>，<code>poetry</code> 以及我最近接触的 <code>pdm</code>。他们都在某种程度上解决了 Python 的问题，这篇文章：</p>
<p><a href="https://chriswarrick.com/blog/2023/01/15/how-to-improve-python-packaging" target="_blank" rel="noopener noreffer ">How to improve Python packaging, or why fourteen tools are at least twelve too many</a></p>
<p>对比了各种工具的利弊。最后得出结论是 poetry 和 pdm 是目前最合适的工具。而 pdm 是目前唯一支持 <a href="https://peps.python.org/pep-0582/" target="_blank" rel="noopener noreffer ">PEP 582</a> 的依赖管理工具。</p>
<h3 id="什么是-pep-582">什么是 PEP 582</h3>
<blockquote>
<p>This PEP proposes to add to Python a mechanism to automatically recognize a <code>__pypackages__</code> directory and prefer importing packages installed in this location over user or global site-packages. This will avoid the steps to create, activate or deactivate “virtual environments”. Python will use the <code>__pypackages__</code> from the base directory of the script when present.</p>
</blockquote>
<p>这个 PEP 的目的就是基于一个文件夹 <code>__pypackages__ </code>来管理 Python 的依赖，类似 nodejs 的<code>node_modules</code>，用户不需要再创建虚拟环境来隔离依赖包。Python 会自动识别和安装依赖。</p>
<blockquote>
<p>更新于 2023 年 7 月 2 日：PEP 582 提案已经被拒绝，PDM 暂时仍然支持，但是不建议开发者使用这一特性。</p>
</blockquote>
<h3 id="pdm">PDM</h3>
<p>PDM 实现了 PEP 582！这让我们在解决 Python 依赖问题时不用再考虑虚拟环境。</p>
<h4 id="初始化项目">初始化项目</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">pdm init
</code></pre></td></tr></table>
</div>
</div><p>之后 PDM 会问几个问题，记得选择<strong>不使用虚拟机环境</strong>，这样 PDM 就会默认使用 PEP 582 的解决方案，在项目下生成一个类似 NodeJS 的 <code>__pypackages__</code>。</p>
<p>剩下的操作就跟 NodeJS 的 npm 非常像了。</p>
<p>添加一个依赖之后，PDM 会自动更新<code>pyproject.toml</code>文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">pdm add requests
</code></pre></td></tr></table>
</div>
</div><h4 id="安装项目依赖">安装项目依赖</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">pdm install
</code></pre></td></tr></table>
</div>
</div><h4 id="启动项目">启动项目</h4>
<p>先在 <code>pyproject.toml</code>里添加</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>tool.pdm.scripts<span class="o">]</span>
<span class="nv">start</span> <span class="o">=</span> <span class="s2">&#34;flask run -p 54321&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>然后执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">pdm run start
</code></pre></td></tr></table>
</div>
</div><h4 id="打包部署">打包部署</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">pdm build
pdm publish
</code></pre></td></tr></table>
</div>
</div><h2 id="总结">总结</h2>
<p>如果你从事科研工作，用 <code>conda</code>。</p>
<p>如果你从事工程项目，<code>poetry</code>是目前业内用的最多的方案，大多数情况下它是个不错的依赖管理工具。但是如果你不喜欢 Python 的 virtualenv，<code>pdm</code>是更好的选择。</p>
]]></description></item><item><title>《Python源码剖析》第三部分——Python虚拟机进阶</title><link>https://sund.site/posts/2017/python-3/</link><pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2017/python-3/</guid><description><![CDATA[<h2 id="python-环境初始化">Python 环境初始化</h2>
<p>进程启动后创建 PyInterpreterObject，PyInterpreterObject 里面维护了全局 module 映射表<code>interp-&gt;modules</code>，该表默认初始化为<strong>buildin</strong>模块，</p>
<h2 id="python-的-import-机制">Python 的 import 机制</h2>
<blockquote>
<p>Python 虚拟机在执行“import A”时，会为 package A 创建一个 module 对象，同时会在该 module 维护的 dict 中添加两个表示元信息的属性：<strong>name</strong>和<strong>path</strong>。而 Python 虚拟机从 A/<strong>init</strong>.py 中执行“import mod1”时，也会为 mod1 创建一个 module 对象，同时也会设置<strong>name</strong>属性，但是这时就不设置<strong>path</strong>属性了。</p>
</blockquote>
<blockquote>
<p>package 是由 module 聚合而成。更清楚的表述是：module 属于一个 package。我们不能说，module1 属于 module2。我们前面已经看到，module 的路径实际上是一种树状结构，从图 14-11 中可以看到，在这个树状结构中，module 的父节点只能是 package，而不可能是另一个 module。</p>
</blockquote>
<h2 id="gil">GIL</h2>
<p>Python 虚拟机使用一个全局解释器锁（Global Interpreter Lock，GIL）来互斥线程对 python 虚拟机的使用。</p>
<p>注意这里 GIL 是解释器一级的互斥锁，也就是同一时间只能有一个线程占用 python 解释器。所以<strong>GIL 是用来让操作系统中分配的多个线程互斥的使用 python 解释器的，是建立在系统线程调度基础之上的一套 C API 互斥机制</strong>，是比操作系统线程资源更大粒度的锁。</p>
<p>Python 的线程是基于操作系统原生线程的，所以 python 的线程不是「虚拟出来的」。</p>
<blockquote>
<p>那么究竟 Python 会在众多的等待线程中选择哪一个幸运儿呢？答案是，不知道。没错，对于这个问题，Python 完全没有插手，而是交给了底层的操作系统来解决。也就是说，Python 借用了底层操作系统所提供的线程调度机制来决定下一个进入 Python 解释器的线程究竟是谁。</p>
</blockquote>
<p>GIL 在 C 里对应的结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="p">[</span><span class="n">thread_nt</span><span class="p">.</span><span class="n">h</span><span class="p">]</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">NRMUTEX</span> <span class="p">{</span>
    <span class="n">LONG</span>   <span class="n">owned</span> <span class="p">;</span>
    <span class="n">DWORD</span>  <span class="n">thread_id</span> <span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">hevent</span> <span class="p">;</span>
<span class="p">}</span> <span class="n">NRMUTEX</span><span class="p">,</span> <span class="o">*</span><span class="n">PNRMUTEX</span> <span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>其中<code>owned</code>初始化为-1，表示锁可用，否则为不可用。<code>thread_id</code>代表线程 id，最后一个是平台相关的变量，win32 上是一个 event 内核对象。</p>
<h2 id="多线程---标准调度">多线程 - 标准调度</h2>
<blockquote>
<p>当 Python 启动时，是并不支持多线程的。换句话说，Python 中支持多线程的数据结构以及 GIL 都是没有创建的，Python 之所以有这种行为是因为大多数的 Python 程序都不需要多线程的支持</p>
</blockquote>
<p>书中指出，由于 python 的多线程标准调度机制是有代价的，所以默认单线程不初始化 GIL。</p>
<ol>
<li>主线程启动后，会用<code>ident = PyThread_start_new_thread(t_bootstrap, (void*) boot);</code>函数调用操作系统内核接口创建子线程，然后主线程挂起等待<code>obj.done</code>。注意，此时主线程中持有 GIL。</li>
<li>主线程等待的这段时间里，子线程将自己的线程 id 等信息设置好，通知内核对象<code>obj.done</code>，唤醒等待中的主线程。此刻，主线程和子线程都同时由操作系统调度，但是主线程一直持有着 GIL。</li>
<li>子线程继续执行后进入 python 解释器，发现需要等待获取 GIL。此时子线程主动将自己挂起(而不是由操作系统挂起)。这样就进入了两个线程通过 GIL 调度的阶段。</li>
<li>主线程被唤醒后，继续执行，直到 python 内置的时钟计时器<code>_Py_Ticker</code>结束才将自己挂起，让出 GIL(<code>_Py_Ticker</code>会在每次执行一条字节码后自动减 1，初始默认为 100)。</li>
</ol>
<p>通过上面 4 步，python 的两个线程就完成了从系统调度上升到 python 标准 GIL 调度的流程。</p>
<h2 id="阻塞调度">阻塞调度</h2>
<p>如同上面流程介绍的，标准调度是 python 使用软件时钟调度线程，那么有时候 python 的线程会自我阻塞，比如<code>raw_input()</code>、<code>sleep()</code>等函数，这时 python 就会使用阻塞调度的方式。</p>
<ol>
<li>主线程调用<code>sleep(1)</code>后，调用<code>Py_BEGIN_ALLOW_THREADS</code>立刻释放 GIL，然后调用操作系统的 sleep 操作。此时主线程就由操作系统自动管理。</li>
<li>子线程拿到 GIL。此时主线程和子线程同时可被操作系统调度。操作系统在执行一段时间子线程后会挂起，调度主线程，发现主线程 sleep 没结束就挂起主线程，就继续唤醒子线程执行。</li>
<li>当主线程 sleep 结束，操作系统唤醒主线程。主线程调用<code>Py_END_ALLOW_THREADS</code>再次申请 GIL，重新进入 python 标准调度流程。</li>
</ol>
<p><strong>可见 python 在保证线程安全的前提下，允许线程在某些时刻脱离 GIL 标准调度流程。</strong></p>
<p>其中<code>Py_BEGIN_ALLOW_THREADS</code>和<code>Py_END_ALLOW_THREADS</code>两个负责释放和等待 GIL 的宏的实现如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="p">[</span><span class="n">ceval</span><span class="p">.</span><span class="n">h</span><span class="p">]</span>
<span class="cp">#define Py_BEGIN_ALLOW_THREADS { \
</span><span class="cp">            PyThreadState *_save; \
</span><span class="cp">            _save = PyEval_SaveThread();
</span><span class="cp">#define Py_END_ALLOW_THREADS    PyEval_RestoreThread(_save); \
</span><span class="cp">         }
</span><span class="cp"></span>
<span class="p">[</span><span class="n">ceval</span><span class="p">.</span><span class="n">c</span><span class="p">]</span>
<span class="n">PyThreadState</span><span class="o">*</span> <span class="n">PyEval_SaveThread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyThreadState</span> <span class="o">*</span><span class="n">tstate</span> <span class="o">=</span> <span class="n">PyThreadState_Swap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">interpreter_lock</span><span class="p">)</span>
        <span class="n">PyThread_release_lock</span><span class="p">(</span><span class="n">interpreter_lock</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tstate</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">PyEval_RestoreThread</span><span class="p">(</span><span class="n">PyThreadState</span> <span class="o">*</span><span class="n">tstate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">interpreter_lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
        <span class="n">PyThread_acquire_lock</span><span class="p">(</span><span class="n">interpreter_lock</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">PyThreadState_Swap</span><span class="p">(</span><span class="n">tstate</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="用户级互斥">用户级互斥</h2>
<p>用户级的互斥锁利用操作系统的互斥机制实现，同时要考虑防止和 GIL 形成死锁。所以过程与阻塞调度类似需要使用<code>Py_BEGIN_ALLOW_THREADS</code>和<code>Py_END_ALLOW_THREADS</code>这两个宏。</p>
<ol>
<li>线程 a 调用 lock 对象加锁，lock 对象内部调用系统互斥机制，同时执行<code>Py_BEGIN_ALLOW_THREADS</code>释放 GIL 防止死锁。</li>
<li>线程 b 获得 GIL，执行到某处释放锁，lock 对象内部调用系统机制释放锁，同时底层调用了<code>Py_END_ALLOW_THREADS</code>等待 GIL。</li>
<li>线程 a 被系统唤醒，获取 GIL，一气呵成。</li>
</ol>
<h2 id="子线程的销毁">子线程的销毁</h2>
<blockquote>
<p>在线程的全部计算完成之后，Python 将销毁线程。需要注意的是，Python 主线程的销毁与子线程的销毁是不同的，因为主线程的销毁动作必须要销毁 Python 的运行时环境，而子线程的销毁则不需要进行这些动作。</p>
</blockquote>
<h2 id="内存管理">内存管理</h2>
<p>大块内存管理直接调用 C 的 malloc 和 free 接口，小块内存分配则由 python 的内存池管理机制调度。</p>
<h3 id="小块内存管理的对象">小块内存管理的对象</h3>
<p>Python 的内存块叫 block，每个 block 大小不同，都是 8 的整数倍。管理 block 的叫 pool，一个 pool 是 4K。pool 管理<strong>相同大小</strong>的一堆 block。pool 对象的 szindex 变量保存了这个 pool 对应的 block 大小。</p>
<blockquote>
<p>，一个 pool 可能管理了 100 个 32 个字节的 block，也可能管理了 100 个 64 个字节的 block，但是绝不会有一个管理了 50 个 32 字节的 block 和 50 个 64 字节的 block 的 pool 存在</p>
</blockquote>
<p>Python 对于内存块的管理类似对象的策略，每次内存分配一整个 block，回收时先将不用的 Block 加入闲置的队列里等待重新利用，不是直接回收。(惰性回收策略)</p>
<p>管理多个 pool 的数据对象是 arena。下图可见，pool 结构是一次性分配好一块内存，而 arena 则是通过指针连向一块 pool。</p>
<p></p>
<p>而 python 维护一个名叫 arenas 的数组，数组元素就是 arena 对象。arena 之间通过由两条链表相连。它们分别是：</p>
<ul>
<li><em>unused_arena_objects</em> 是单向量表，指向未分配 pool 的 arena</li>
<li><em>usable_arenas</em> 是双向链表，表示已经分配了 pool 的 arena</li>
</ul>
<p></p>
<blockquote>
<p>当一个 arena 的 area_object 没有与 pool 集合建立联系时，这时的 arena 处于“未使用”状态；一旦建立了联系，这时 arena 就转换到了“可用”状态。对于每一种状态，都有一个 arena 的链表。“未使用”的 arena 的链表表头是 unused_arena_objects、arena 与 arena 之间通过 nextarena 连接，是一个单向链表；而“可用”的 arena 的链表表头是 usable_arenas、arena 与 arena 之间通过 nextarena 和 prevarena 连接，是一个双向链表。</p>
</blockquote>
<p><strong>Pool 是 python 管理内存的对象，arena 虽然更上层，但是 arena 内的 pool 集合可能管理 32 字节的 block，也可能管理 64 字节的 block，所以 arena 无法决定销毁和分配内存。Python 仍然以 pool 为单位管理内存开销。(pool 有 size 概念，arena 没有 size 概念)</strong></p>
<p>Pool 有三种状态 full、empty 和 used。其中 full 不需要连接起来，其他两种状态会被 freepools 和 usedpools 连接起来方便管理。</p>
<p></p>
<h3 id="arena-的分配">arena 的分配</h3>
<p>arena 可以指向 32 位 pool 集合，也可以指向 64 位 pool 集合。分配内存的过程如下：</p>
<ol>
<li>先在 usable_arenas 链表上找可用的 arena，然后找到符合要求的 pool</li>
<li>如果没有可用的 arena，则从 arenas 数组里摘下来新的 arena，放在 usable_arenas 里，然后初始化 pool</li>
<li>从 usedpools 链表里找可用的 blocks</li>
<li>usedpools 没有可用的 pool，就从 freepools 链表分配一个 empty 状态的 pool</li>
</ol>
<h3 id="python-编译时指定内存上限">Python 编译时指定内存上限</h3>
<blockquote>
<p>当 Python 在 WITH_MEMORY_LIMITS 编译符号打开的背景下进行编译时，Python 内部的另一个符号会被激活，这个名为 SMALL_MEMORY_LIMIT 的符号限制了整个内存池的大小，同时，也就限制了可以创建的 arena 的个数。在默认情况下，不论是 Win32 平台，还是 unix 平台，这个编译符号都是没有打开的，所以通常 Python 都没有对小块内存的内存池的大小做任何的限制。</p>
</blockquote>
<h3 id="小块内存管理的流程">小块内存管理的流程</h3>
<p><em>(此部分摘自书中代码注释)</em></p>
<ol>
<li>如果申请的内存小于 SMALL_REQUEST_THRESHOLD，使用 Python 的小块内存的内存池。否则，转向 malloc</li>
<li>根据申请内存的大小获得对应的 size class index</li>
<li>如果 usedpools 中可用的 pool，使用这个 pool 来分配 block</li>
<li>分配结束后，如果 pool 中的 block 都被分配了，将 pool 从 usedpools 中摘除</li>
<li>如果 usedpools 中没有可用的 pool，从 usable_arenas 中获取 pool</li>
<li>如果 usable_arenas 中没有就“可用”的 arena，开始申请 arena</li>
<li>从 usable_arenas 的第一个 arena 中获取一个 pool</li>
<li>获取 pool 成功，进行 init pool 的动作，将 pool 放入 used_pools 中，并返回分配得到的 block</li>
<li>获取 pool 失败，对 arena 中的 pool 集合进行初始化，然后转入 goto 到 init pool 的动作处，初始化一个特定的 pool</li>
</ol>
<h3 id="python-25-对多次分配小内存造成内存泄漏的处理">Python 2.5 对多次分配小内存造成内存泄漏的处理</h3>
<p>在 2.5 之前版本，Python 的 arena 从来不释放 pool。这就造成反复分配小内存后造成的 arena 太多而内存无法回收。</p>
<p>2.5 之后的处理办法：arena 有两种状态，unused 和 usable。上文已经介绍过。</p>
<ol>
<li>如果 arena 中所有的 pool 都是 empty 的，释放 pool 集合占用的内存。arena 变成 unused 状态，从 usable_arenas 剔除</li>
<li>如果 arena 初始化了新的 pool，arena 变成 usable 状态，从 usable_arenas 链表中顺序查找位置插入该 arena。注意，usable_arenas 是有序链表(按照 arena 中 pool 的个数排序，pool 多的 arena 排前边，pool 少的排后边)</li>
<li>这样，再有分配内存的请求时，先从 usable_arenas 表头顺序查，排在前边 pool 多的 arena 就被利用的充分，pool 少的 arena 就更有可能变成 unused 状态，容易被释放掉。达到节省内存的目的</li>
</ol>
<h3 id="内存池全景">内存池全景</h3>
<p></p>
<h2 id="python-垃圾回收机制">Python 垃圾回收机制</h2>
<p>除了计数器，python 还是使用了标记-清除，分代回收机制。</p>
<h3 id="标记---清除">标记 - 清除</h3>
<h4 id="三色模型">三色模型</h4>
<p>根据系统内所有对象的引用情况建立有向图，沿着有向图从根开始的逐层染色，黑色代表该节点所有引用都检查过了，灰色表示节点是可达的，当所有灰色节点都变为黑色，检查结束。</p>
<p></p>
<h3 id="python-中的标记清除">Python 中的标记清除</h3>
<p>Python 的对象由三大部分组成，PyGC_Head，PyObject_Head 和本体。其中 PyObject_Head 里存计数器用来标记当前节点是否可回收，但是对于循环引用的情况，就需要 PyGC_Head 里的 refs，python 会根据一些触发条件进行三色模型的标记，某个对象的「可达次数」标记在 PyGC_Head 里，当这个可达次数为 0 时，代表对象不可达，也就需要回收之。PyGC_Head 之间有一条双向链表连接了所有对象，将他们纳入内存回收管理系统里。</p>
<p></p>
<h4 id="流程">流程</h4>
<ol>
<li>在垃圾收集的第一步，就是遍历可收集对象链表，将每个对象的 gc.gc_ref 值设置为其 ob_refcnt 值。</li>
<li>接下来的动作就是要将环引用从引用中摘除。</li>
<li>有一些 container 对象的<code>PyGC_Head.gc.gc_ref</code>还不为 0，这就意味着存在对这些对象的外部引用，这些对象，就是开始标记 - 清除算法的 root object 集合。</li>
</ol>
<h3 id="分代回收">分代回收</h3>
<blockquote>
<p>这种以空间换时间的总体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就称为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小，也就是说，活得越长的对象，就越可能不是垃圾，就应该越少去收集。</p>
</blockquote>
<p></p>
<blockquote>
<p>Python 采用了三代的分代收集机制，如果当前收集的是第 1 代，那么在开始垃圾收集之前，Python 会将比其“年轻”的所有代的内存链表（当然，在这里只有第 0 代）整个地链接到第 1 代内存链表之后，这个操作是通过 gc_list_merge 实现的。</p>
</blockquote>
<h3 id="总结">总结</h3>
<ol>
<li>将比当前处理的“代”更年轻的“代”的链表合并到当前“代”中</li>
<li>在待处理链表上进行打破循环的模拟，寻找 root object</li>
<li>将待处理链表中的 unreachable object 转移到 unreachable 链表中，处理完成后，当前“代”中只剩下 reachable object 了</li>
<li>如果可能，将当前“代”中的 reachable object 合并到更老的“代”中</li>
<li>对于 unreachable 链表中的对象，如果其带有<code>__del__</code>函数，则不能安全回收，需要将这些对象收集到 finalizers 链表中，因此，这些对象引用的对象也不能回收,也需要放入 finalizers 链表中</li>
<li>处理弱引用（weakref），如果可能，调用弱引用中注册的 callback 操作</li>
<li>对 unreachable 链表上的对象进行垃圾回收操作</li>
<li>将含有<code>__del__</code>操作的实例对象收集到 Python 内部维护的名为 garbage 的链表中，同时将 finalizers 链表中所有对象加入 old 链表中</li>
</ol>
<p><strong>注意，如果对象拥有<code>__del__</code>方法，就不能通过垃圾回收来自动回收</strong>，所以要慎重使用这个方法。</p>
]]></description></item><item><title>《Python源码剖析》第二部分——Python虚拟机基础</title><link>https://sund.site/posts/2017/python-2/</link><pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2017/python-2/</guid><description><![CDATA[<h2 id="python-执行环境">Python 执行环境</h2>
<blockquote>
<p>在编译过程中，这些包含在 Python 源代码中的静态信息都会被 Python 编译器收集起来，编译的结果中包含了字符串，常量值，字节码等在源代码中出现的一切有用的静态信息。在 Python 运行期间，这些源文件中提供的静态信息最终会被存储在一个运行时的对象中，当 Python 运行结束后，这个运行时对象中所包含的信息甚至还会被存储在一种文件中。这个对象和文件就是我们这章探索的重点：PyCodeObject 对象和 pyc 文件。</p>
</blockquote>
<blockquote>
<p>在程序运行期间，编译结果存在于内存的 PyCodeObject 对象中；而 Python 结束运行后，编译结果又被保存到了 pyc 文件中。当下一次运行相同的程序时，Python 会根据 pyc 文件中记录的编译结果直接建立内存中的 PyCodeObject 对象，而不用再次对源文件进行编译了。</p>
</blockquote>
<p>从文章摘录可见，python 生成的不是编译后的文件，而是<code>.py</code>文件对应的静态信息——PyCodeObject，这里包括了字节码指令序列、字符串、常量。每个名字空间(类、模块、函数)都对应一个独立的 PyCodeObject。(python 连编译后的文件里存的都是个对象！)</p>
<p>不被 import 的 py 文件不会生成 pyc。标准库里有 py_compile 等方法也可以生成 pyc。</p>
<p><strong>import 机制</strong> 导入某个模块时，先查找对应的 pyc，如果没有 pyc 就生成然后 import 这个 pyc。(所以实际导入的并不是 py 文件，而是 py 文件编译后的 PyCodeObject)。</p>
<p><strong>PyFrameObject</strong> Python 程序运行时的「执行环境」。参考操作系统执行可执行文件的过程。Python 也是将函数对应的执行环境封装成栈帧的形式加载进内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_frame</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="k">struct</span> <span class="n">_frame</span> <span class="o">*</span><span class="n">f_back</span><span class="p">;</span>  <span class="c1">//执行环境链上的前一个frame
</span><span class="c1"></span>    <span class="n">PyCodeObject</span> <span class="o">*</span><span class="n">f_code</span><span class="p">;</span>   <span class="c1">//PyCodeObject对象
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_builtins</span><span class="p">;</span>   <span class="c1">//builtin名字空间
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_globals</span><span class="p">;</span>    <span class="c1">//global名字空间
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_locals</span><span class="p">;</span>     <span class="c1">//local名字空间
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">**</span><span class="n">f_valuestack</span><span class="p">;</span>    <span class="c1">//运行时栈的栈底位置
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">**</span><span class="n">f_stacktop</span><span class="p">;</span>      <span class="c1">//运行时栈的栈顶位置
</span><span class="c1"></span>    <span class="err">……</span>
    <span class="kt">int</span> <span class="n">f_lasti</span><span class="p">;</span>        <span class="c1">//上一条字节码指令在f_code中的偏移位置
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">f_lineno</span><span class="p">;</span>       <span class="c1">//当前字节码对应的源代码行
</span><span class="c1"></span>    <span class="err">……</span>
    <span class="c1">//动态内存，维护（局部变量+cell对象集合+free对象集合+运行时栈）所需要的空间
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_localsplus</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">PyFrameObject</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Python 标准库的<code>sys._getframe()</code>可以动态的在程序执行时获取当前内存中活跃的 PyFrameObject 信息。</p>
<h2 id="legb-规则">LEGB 规则</h2>
<p>即 python 作用域的查找顺序是<code>local</code>-<code>enclosing</code>-<code>global</code>-<code>buildin</code>。看下面代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
  <span class="k">print</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
  <span class="k">print</span> <span class="n">a</span> <span class="o">//</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">//</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
  <span class="k">print</span> <span class="n">a</span>

<span class="n">g</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>代码在[1]处会抛出异常，原因是 python 在编译阶段就把静态数据(局部变量、全局变量、字节码)放入 pyc 里，执行到<code>f()</code>里时，查找到<code>a</code>是在 local 作用域里定义的而不是 global 里，但是此时 local 的 a 还没赋值，所以就会抛出异常。由此可见，<strong>python 作用域信息是在静态编译时就处理好了的</strong>。</p>
<h2 id="python-虚拟机运行框架">Python 虚拟机运行框架</h2>
<blockquote>
<p>运行时环境是一个全局的概念，而执行环境实际就是一个栈帧，是一个与某个 Code Block 对应的概念。</p>
</blockquote>
<blockquote>
<p>在 PyCodeObject 对象的 co_code 域中保存着字节码指令和字节码指令的参数，Python 虚拟机执行字节码指令序列的过程就是从头到尾遍历整个 co_code、依次执行字节码指令的过程。</p>
</blockquote>
<p>由上文引用可见，python 在编译阶段将代码块的字节码保存在 PyCodeObject 的 co_code 属性里，然后在执行阶段从头到尾遍历这个 co_code 属性解读字节码。</p>
<p><strong>Python 运行时环境</strong> Python 在运行时用 PyInterpreterState 结构维护进程运行环境，PyThreadState 维护线程运行环境，PyFrameObject 维护栈帧运行环境，三者是依次包含关系，如下图所示：</p>
<p></p>
<p>Python 虚拟机就是一个「软 CPU」，动态加载上述三种结构进内存，并模拟操作系统执行过程。程序执行后，先创建各个运行时环境，再将栈帧中的字节码载入，循环遍历解释执行。</p>
<h2 id="python-字节码">Python 字节码</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="mi">0</span>   <span class="n">LOAD_CONST</span>   <span class="mi">0</span>  <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">3</span>   <span class="n">STORE_NAME</span>   <span class="mi">0</span>  <span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>例如 python 的一条语句<code>i=1</code>可以解释为下面两行字节码，最左边的第 1 列数字代表这行字节码在内存中的偏移位置，第 2 列是字节码的名字(CPU 并不关心名字，它只是根据偏移量读出字节码，所以这个名字是方便阅读用的)，第 3 列是字节码的参数，如<code>LOAD_CONST</code>对应的数据在变量<code>f-&gt;f_code-&gt;co_consts</code>里，0 就是这个参数位于<code>f-&gt;f_code-&gt;co_consts</code>的偏移量。最后一列的括号里是从参数里取到的 value。</p>
<h2 id="python-的异常抛出机制">Python 的异常抛出机制</h2>
<p>异常处理的操作都在<code>Python/traceback.c</code>文件里，python 每次调用一层函数，就创建改函数对应的 PyFrameObject 对象来保存函数运行时信息，PythonFrameObject 里调用 PyEval_EvalFrameEx 循环解释字节码，如果抛出异常就创建 PyTraceBackObject 对象，将对象交给上一层 PyFrameObject 里的 PyTracebackObject 组成链表，最后返回最上层 PyRun_SimpleFileExFlags 函数，该函数调用 PyErr_Print 遍历 PyTraceBackObject 链表打印出异常信息。</p>
<p></p>
<h2 id="函数对象的实现">函数对象的实现</h2>
<p>PyFunctionObject 是函数对象。在 python 调用函数时，生成 PyFunctionObject 对象，该对象的 f_global 指针用来将外层的全局变量传递给函数内部，然后在<code>ceval.c</code>文件的<code>fast_function</code>里解出 PyFunctionObject 对象里携带的信息，创建新的 PyFrameObject 对象(上文说过这个对象是维护运行时环境的)，最后调用执行字节码的函数<code>PyEval_EvalFrameEx</code>执行真正函数字节码。</p>
<p><strong>Python 执行一段代码需要什么？</strong> 从书中描述可见，python 执行一段代码需要做几件事：</p>
<ul>
<li>从源码编译出 PyCodeObject 保存变量和字节码</li>
<li>执行阶段，从 PyCodeObject 里取出信息交给 PyFrameObject，执行 PyEval_EvalFrameEx 解释字节码</li>
<li>如果遇到函数调用，就把函数对应的代码段从 PyCodeObject 存入 PyFunctionObject 对象，然后把这个函数对象通过参数传给新创建的 PyFrameObject ，在内层空间执行 PyEval_EvalFrameEx 解释字节码</li>
<li>将结果或异常存入 PyFrameObject 的变量( 异常是存入 f_blockstack 里，外层判断 f_blockstack 里的数据是被 except 捕获还是没有捕获而继续下一步操作) 抛给外层</li>
</ul>
<p>值得注意的是，<strong>python 在执行阶段，将对函数参数的键值查找，转换为索引查找</strong>，即在转换 PyCodeObject 为 PyFrameObject 时，将参数信息按位置参数、键参数按照一定顺序存储在 f_localsplus 变量中，再用索引来查找对应参数，而需要查找键值。这样提高了运行时效率。下图是<code>foo('Rboert', age=5)</code>在内存中的存储形式。</p>
<p></p>
<h2 id="闭包的实现">闭包的实现</h2>
<p>Python 在编译阶段就把函数闭包内层和闭包外层使用的变量存入 PyCodeObject 中：</p>
<ul>
<li>co_cellvars：通常是一个 tuple，保存嵌套的作用域中使用的变量名集合；</li>
<li>co_freevars：通常也是一个 tuple，保存使用了的外层作用域中的变量名集合。</li>
</ul>
<p>在执行阶段，PyFrameObject 的 f_localsplus 中也为闭包的变量划分的内存区域，如下图所示：</p>
<p></p>
<h2 id="元类">元类</h2>
<p>元类<code>&lt;type type&gt;</code>和其他类的关系如下图：</p>
<p></p>
<p><strong>可调用性（callable）</strong> ，只要一个对象对应的 class 对象中实现了“<strong>call</strong>”操作（更确切地说，在 Python 内部的 PyTypeObject 中，tp_call 不为空）那么这个对象就是一个可调用的对象，换句话说，在 Python 中，所谓“调用”，就是执行对象的 type 所对应的 class 对象的 tp_call 操作。</p>
<h2 id="descriptor">Descriptor</h2>
<blockquote>
<p>在 PyType_Ready 中，Python 虚拟机会填充 tp_dict，其中与操作名对应的是一个个 descriptor
对于一个 Python 中的对象 obj，如果 obj.** class**对应的 class 对象中存在**get**、**set**和**delete**三种操作，那么 obj 就可称为 Python 一个 descriptor。</p>
</blockquote>
<blockquote>
<p>如果细分，那么 descriptor 还可分为如下两种：</p>
</blockquote>
<ol>
<li>data descriptor : type 中定义了<strong>get</strong>和<strong>set</strong>的 descriptor；</li>
<li>non data descriptor : type 中只定义了<strong>get</strong>的 descriptor。
在 Python 虚拟机访问 instance 对象的属性时，descriptor 的一个作用是影响 Python 虚拟机对属性的选择。从 PyObject_GenericGetAttr 的伪代码可以看出，Python 虚拟机会在 instance 对象自身的<strong>dict</strong>中寻找属性，也会在 instance 对象对应的 class 对象的 mro 列表中寻找</li>
</ol>
<blockquote>
<ol>
<li>Python 虚拟机按照 instance 属性、class 属性的顺序选择属性，即 instance 属性优先于 class 属性；</li>
<li>如果在 class 属性中发现同名的 data descriptor，那么该 descriptor 会优先于 instance 属性被 Python 虚拟机选择</li>
</ol>
</blockquote>
<p></p>
<h3 id="引申python-黑魔法-descriptor-描述器">引申：Python 黑魔法 Descriptor (描述器)</h3>
<ul>
<li><a href="http://www.jianshu.com/p/250f0d305c35">http://www.jianshu.com/p/250f0d305c35</a></li>
<li><a href="http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html">http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html</a></li>
</ul>
<h2 id="bound-method-和-unbound-method">Bound Method 和 Unbound Method</h2>
<p>假设有下面两种对类方法的调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="c1"># [1]</span>
<span class="n">a</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>

<span class="c1"># [2]</span>
<span class="n">A</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c1"># [3]</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">f</span>
<span class="n">func</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>在代码[1]里，实例 a 调用类方法 f，python 底层会自动完成实例 a 和类方法 f 之间的绑定动作(调用<code>func_ descr_get(A.f, a, A)</code>，将实例地址和函数对象 PyFunctionObject 封装到一个 PyMethodObject)，而代码[2]里直接通过 A 调用，则 f 为非绑定的 PyMethodObject，里面没有实例信息，需要传入 a。</p>
<p>比较绑定方法与非绑定方法可知，通过[1]的方式每次都要绑定一次实例，开销非常大，下图比较的是[1]和[3]两种方式，绑定操作的执行次数。</p>
<p></p>
<p>结论： <strong>调用类实例绑定的方法时，如果方法执行次数非常多，最好将方法赋值给一个变量，防止重复绑定增加开销</strong></p>
]]></description></item><item><title>《Python源码剖析》第一部分——Python对象基础</title><link>https://sund.site/posts/2017/python/</link><pubDate>Wed, 12 Jul 2017 00:00:00 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2017/python/</guid><description><![CDATA[<h2 id="python-的对象初始化">Python 的对象初始化</h2>
<blockquote>
<p>在 Python 中，对象就是为 C 中的结构体在堆上申请的一块内存，一般来说，对象是不能被静态初始化的，并且也不能在栈空间上生存。唯一的例外就是类型对象，Python 中所有的内建的类型对象（如整数类型对象，字符串类型对象）都是被静态初始化的。</p>
</blockquote>
<p>python 的对象不像 C 是分配在栈、堆、data segment 等位置，而是全部分配在堆上！只有 python 内置类型在初始化时候才是被 C 语言层静态初始化。</p>
<p>PyObject 内部就两样：引用计数器、类型对象指针。</p>
<p>类型对象的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_typeobject</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* For printing, in format &#34;&lt;module&gt;.&lt;name&gt;&#34; */</span>
    <span class="kt">int</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* For allocation */</span>

    <span class="cm">/* Methods to implement standard operations */</span>
    <span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
    <span class="n">printfunc</span> <span class="n">tp_print</span><span class="p">;</span>
    <span class="err">……</span>
    <span class="cm">/* More standard operations (here for binary compatibility) */</span>
    <span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
    <span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
    <span class="err">……</span>
<span class="p">}</span> <span class="n">PyTypeObject</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>PyObject_VAR_HEAD</code>是可变类型的头信息，其中除了<code>PyObject_HEAD</code>的内容外，额外添加了一个代表该对象元素数量的整型。从上边代码可见，python 的类型也是一个可变对象。</p>
<h2 id="python-的多态">Python 的多态</h2>
<p>Python 中所有类型在初始化后，在 C 语言层面都使用同一种指针<code>PyObject *</code>，所以 python 实现多态就非常容易。任何函数的参数都是一个 PyObject 类型指针，也就不存在编译器需要判断函数参数类型。</p>
<h2 id="python-对象内存池">Python 对象内存池</h2>
<p>Python 为了避免频繁的释放对象，采用了内存池的机制，在对象引用计数为 0 时，不会释放内存，而是将内存交还给内存池供 python 重新分配使用。<strong>每一种 python 类型，都有特定的内存池机制。</strong></p>
<h2 id="整数对象">整数对象</h2>
<p>-5 至 257 之间的小整数，存储在「小整数数组」里，这个数组 Python 自动创建，每次创建一个小整数，就指向这个数组里对应的 PyIntObject 值并把 PyIntObject 的计数加 1。(因此在-5 到 257 之间的数实际指向同一片内存空间，整数-5 和-5 的内存地址肯定是一样的)</p>
<p>大整数则由一个叫<code>block_list</code>的链表管理，每次分配一个大整数就在<code>free_list</code>(一个指向空闲内存 block 的指针)里拿出一个节点并把<code>free_list</code>后移一个<code>block</code>。关于<code>free_list</code>是如何把尚未分配的内存和已被释放的内存链接起来的，可以参见书中 113 页的插图理解。</p>
<p>值得注意的是，python 用于分配给整型的堆内存是不会自行销毁的，而是不断复用。也就是说，<strong>同一时间如果同时使用的整型太多，会消耗大量内存，并且这些内存在 python 关闭之前一直被 python 持有着。</strong></p>
<h2 id="字符串对象">字符串对象</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="kt">long</span> <span class="n">ob_shash</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ob_sstate</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">ob_sval</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">PyStringObject</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>在 Python 源码中的注释显示，预存字符串的 hash 值(为了节省字符串比较的时间)和这里的 intern 机制将 Python 虚拟机的执行效率提升了 20%。</p>
<p><strong>intern 机制</strong> 将新建的字符串缓存在一个 PyDictObject 里，相同的字符串共用同一内存。</p>
<p>单一字符的字符串，除了用 intern 缓存外，还会缓存在系统自带的一个字符串缓冲池里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">PyStringObject</span> <span class="o">*</span><span class="n">characters</span><span class="p">[</span><span class="n">UCHAR_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</code></pre></td></tr></table>
</div>
</div><p><strong><code>+</code>操作符和<code>join</code>的效率问题</strong> <code>+</code>连接 n 个操作符会创建 n-1 次临时空间，<code>join</code>会直接处理一个 list 里的字符串，只分配一次内存。节省开销。</p>
<h2 id="列表对象">列表对象</h2>
<p>参见 C++ vector 对象的存储方式。</p>
<h2 id="字典对象">字典对象</h2>
<p>Python 使用散列表(时间复杂度 O(1))而非红黑树(时间复杂度 O(logN))来存储 map 结构。</p>
<p>**Hash 冲突(碰撞)**不同的值映射到相同的键时，就产生了冲突。一般解决办法有：</p>
<ul>
<li>
<p>开链法(哈希桶)：
</p>
</li>
<li>
<p>开放定址法：
hash 一次没有命中就再 hash 一次，直到找到为止……(二次探测)</p>
</li>
</ul>
<p>小于 8 个元素的 Dict，python 使用 PyDIctObject 内部的 smalltable 数组保存元素内容。</p>
<p>PyDictObject 对 String 类型的 key 做了特殊对待——简化了计算 hash 函数的过程(正常情况下 key 值是一个<code>PyObject *</code>对象，需要做大量类型判断，但是对 PyStringObject 就省了)。</p>
<p>**装载率(使用的空间/预先分配的空间)**大于 2/3 时，hash 冲突的概率会急速升高，这时 python 就会动态分配更多的空间。与其他类型一样，如果装载率太小，也会自动缩减分配的空间。</p>
<blockquote>
<p>在确定新的 table 的大小时，通常选用的策略是时新的 table 中 entry 的数量是现在 table 中 Active 态 entry 数量的 4 倍，选用 4 倍是为了使 table 中处于 Active 态的 entry 的分布更加稀疏，减少插入元素时的冲突概率……所以当 table 中 Active 态的 entry 数量非常大时，Python 只会要求 2 倍的空间，这次又是以执行速度来交换内存空间。</p>
</blockquote>
<p>注意这段话，执行速度和内存大小是反比关系，划分的空间越大，执行一次查找就越费时，所以分配的内存空间不是越大越好。</p>
<p>PyDictObject 也使用了同 PyListObject 一样的缓冲池方式。参考列表对象部分内容。</p>
<p><em><strong>笔者总结：从上面的各种类型的处理规律可以总结出 Python 遵循的原则：小变量缓存，大变量尽量整块分配内存，回收变量时不释放内存而是尽量复用，预分配的空间既要满足需要又不能太大(太大就缩减)</strong></em></p>
]]></description></item><item><title>Python2 中字符类型的一些坑</title><link>https://sund.site/posts/2017/py-str/</link><pubDate>Wed, 11 Jan 2017 11:09:00 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2017/py-str/</guid><description><![CDATA[<h2 id="问题">问题</h2>
<p>有一道面试题是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;China&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="s1">&#39;China&#39;</span>
<span class="n">c</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;中国&#39;</span>
<span class="n">d</span> <span class="o">=</span> <span class="s1">&#39;中国&#39;</span>
<span class="c1"># 1</span>
<span class="k">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="c1"># 2</span>
<span class="k">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">c</span>
<span class="c1"># 3</span>
<span class="k">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">d</span>
<span class="c1"># 4</span>
<span class="k">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>判断打印后的效果。</p>
<p>先说正确答案，只有最后一行会报错。</p>
<h2 id="分析">分析</h2>
<p>在 Python2 里，默认的字符类型是<code>str</code>，这个<code>str</code>和 Python3 的<code>str</code>完全不同，Python2 的<code>str</code>类型是 8 位的 ascii 序列。Python2 在处理<code>str</code>类型转换时遵循这样的规则：<strong>如果被处理的<code>str</code>型变量值小于 7 位，就可以和<code>unicode</code>类型混用。可以做<code>+</code>连接，格式化等操作，同 unicode 享受同样的待遇。</strong></p>
<p>Python2 在格式化字符时，会把<code>str</code>格式化为<code>str</code>，如果字符串里混入了<code>unicode</code>，就会把其他字符都转化为<code>unicode</code>。所以这道题里 1 处的 a，b 两个值混合后的字符就是一个 unicode 字符串，c 和 d 单独格式化后仍保留了自己的格式。但是 Python2 在格式化代码位置 4 时，发现 c 是 unicode 而 d 不是，就会尝试按照上面的混用规则，格式化 d 为 unicode 类型，但是 d 的值<code>'中国'</code>显然是一个大于 7 位的<code>str</code>，因此 Python2 抛出 UnicodeDecodeError。</p>
<p>在 Python3 里，<code>str</code>类型则变成了一个纯 unicode 字符，也就是说 Python3 里的<code>str</code>等价于 Python2 里的<code>unicode</code>类型。Python3 里为了清晰明了，使用<code>bytes</code>代表 8 位 ascii 序列。除此之外，Python3 严格禁止混用两种类型。</p>
<h2 id="总结">总结</h2>
<ul>
<li>使用 Python2 处理字符串，尤其是中文字符串，最好前边加上 u</li>
<li>Python2 里不要混用<code>str</code>和<code>unicode</code>，如果处理文本时，先将全部数据格式化成 unicode</li>
<li>能用 Python3 尽量不用 Python2 <del>(废话)</del></li>
</ul>
<h2 id="参考资料">参考资料：</h2>
<ul>
<li>《Effective Python》 Brett Slatkin.</li>
<li>不愿意透露姓名的某厂面试官</li>
</ul>
]]></description></item><item><title>Python yield关键字的底层实现</title><link>https://sund.site/posts/2016/py-yield/</link><pubDate>Wed, 28 Dec 2016 18:00:00 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2016/py-yield/</guid><description><![CDATA[<p>这几天面试被问到类似的问题，顺便看了看 Python 的源码，参考网上的教程，总结一下 yield 关键字在 C 层面是如何实现的。</p>
<h2 id="举个栗子">举个栗子</h2>
<p>我们先看一个 python 生成器函数的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">dis</span> <span class="kn">import</span> <span class="n">dis</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">yield</span> <span class="n">i</span>
    <span class="k">print</span> <span class="n">i</span>

<span class="n">dis</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span><span class="n">func</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 python 的库 dis 可以直接查看 python 虚拟机运行的字节码。<code>dis(func)</code>的打印如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  6           0 LOAD_CONST               1 (4)
              3 STORE_FAST               0 (i)

  7           6 LOAD_FAST                0 (i)
              9 YIELD_VALUE
             10 POP_TOP

  8          11 LOAD_FAST                0 (i)
             14 PRINT_ITEM
             15 PRINT_NEWLINE
             16 LOAD_CONST               0 (None)
             19 RETURN_VALUE
</code></pre></td></tr></table>
</div>
</div><p>我们猜测其中第二列(代表字节码偏移量)为 9 的指令<code>YIELD_VALUE</code>就是 yield 关键字的执行代码，进入 Python2.7.12 源码目录，在解释器执行字节码的主函数<code>PyEval_EvalFrameEx</code>中找到了下面一段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">          <span class="n">TARGET_NOARG</span><span class="p">(</span><span class="n">YIELD_VALUE</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">retval</span> <span class="o">=</span> <span class="n">POP</span><span class="p">();</span>
              <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_stacktop</span> <span class="o">=</span> <span class="n">stack_pointer</span><span class="p">;</span>
              <span class="n">why</span> <span class="o">=</span> <span class="n">WHY_YIELD</span><span class="p">;</span>
              <span class="c1">// 跳转到fast_yield处。fast_yield里处理了一下状态位然后返回结果
</span><span class="c1"></span>              <span class="k">goto</span> <span class="n">fast_yield</span><span class="p">;</span>
          <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中<code>TARGET_NOARG</code>为封装了<code>case</code>语句的宏，这句话的意思是，如果字节码是<code>YIELD_VALUE</code>，就把栈顶元素赋值给<code>retval</code>，然后跳转到<code>fast_yield</code>处，<code>fast_yield</code>处代码进行了一些状态判断后直接返回了<code>retval</code>。</p>
<h2 id="生成器是如何记录代码返回位置的">生成器是如何记录代码返回位置的</h2>
<p>显然，如果这时候调用代码<code>a.next()</code>就会直接返回 yield 后边的表达式结果。这对应了上面 C 代码的<code>fast_yield</code>部分，那生成器怎么记录上次执行的位置并在下一次调用<code>a.next()</code>的时候从上次的位置继续执行的呢？</p>
<p>Python 在解释代码时，是将代码块加载为一个叫 PyFrameObject 的对象，这个对象代表了当前运行的栈帧。PyFrameObject 里有个<code>f_lasti</code>变量用于保存代码当前执行到了字节码的哪个位置。在第二次执行<code>a.next()</code>时，生成器对象把之前携带了<code>f_lasti</code>的 PyFrameObject 当参数传给<code>PyEval_EvalFrameEx</code>，在<code>PyEval_EvalFrameEx</code>里的执行一个 JUMPTO 就直接跳转到了上一次结束生成器时的字节码位置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyEval_EvalFrameEx</span><span class="p">(</span><span class="n">PyFrameObject</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">throwflag</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
<span class="cp">#define FAST_DISPATCH() \
</span><span class="cp">          { \
</span><span class="cp">      if (!lltrace &amp;&amp; !_Py_TracingPossible) { \
</span><span class="cp">          f-&gt;f_lasti = INSTR_OFFSET(); \
</span><span class="cp">          goto *opcode_targets[*next_instr++]; \
</span><span class="cp">      } \
</span><span class="cp">      </span><span class="c1">// 跳转到fast_next_opcode处
</span><span class="c1"></span>      <span class="k">goto</span> <span class="n">fast_next_opcode</span><span class="p">;</span> \
          <span class="p">}</span>
<span class="p">...</span>
<span class="nl">fast_next_opcode</span><span class="p">:</span>
          <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_lasti</span> <span class="o">=</span> <span class="n">INSTR_OFFSET</span><span class="p">();</span>

          <span class="cm">/* line-by-line tracing support */</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">_Py_TracingPossible</span> <span class="o">&amp;&amp;</span>
              <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">c_tracefunc</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">tracing</span><span class="p">)</span> <span class="p">{</span>
              <span class="p">...</span>
              <span class="cm">/* Reload possibly changed frame fields */</span>
              <span class="c1">// 按照f-&gt;f_lasti中的偏移量跳转字节码
</span><span class="c1"></span>              <span class="n">JUMPTO</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_lasti</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中<code>INSTR_OFFSET</code>宏正是字节码的偏移量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define INSTR_OFFSET()  ((int)(next_instr - first_instr))
</span><span class="cp"></span>
<span class="c1">// co-&gt;co_code里保存的是字节码
</span><span class="c1"></span><span class="n">first_instr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">co</span><span class="o">-&gt;</span><span class="n">co_code</span><span class="p">);</span>
<span class="n">next_instr</span> <span class="o">=</span> <span class="n">first_instr</span> <span class="o">+</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_lasti</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>所以生成器对象每次执行结束都把字节码的偏移量记录下来，并把运行状态保存在 PyFrameObject 里，下一次运行时生成器时，python 解释器直接按照偏移量寻找下一个字节码指令。</p>
]]></description></item><item><title>Python 巧妙地将rpc接口封装成pythonic的链式调用</title><link>https://sund.site/posts/2016/py-pythonic/</link><pubDate>Tue, 25 Oct 2016 15:40:43 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2016/py-pythonic/</guid><description><![CDATA[<p>这是一个外国人实现的 Zabbix(一个开源监控工具)的 Python Client——pyzabbix 里的代码片段。</p>
<h2 id="rpc-调用">RPC 调用</h2>
<p>Rpc 调用的流程是向 rpc 服务端指定的 uri(如http://www.abc.com/jsonrpc.php) 发送 json(或其他双方约定格式)数据包，数据包里有 rpc 版本信息、方法名、参数等。下面<code>Zabbix</code>类里的<code>do_request</code>方法就完成了将方法名和方法参数打包 json 后发送请求的过程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Zabbix</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># ... skip other class methods</span>

    <span class="k">def</span> <span class="nf">do_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">request_json</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;jsonrpc&#39;</span><span class="p">:</span> <span class="s1">&#39;2.0&#39;</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
            <span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{},</span>
            <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">post</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">request_json</span><span class="p">),</span>
            <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>
        <span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="技巧">技巧</h2>
<p>但是为了方便，我们在 python 里一般使用<code>zabbixclient.host.get(args)</code>这样的链式调用，而不用<code>zabbixclient('host.get', args)</code>这样的调用方式。pyzabbix 的作者巧妙的实现了这样的转换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Zabbix</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># ... skip other class methods</span>

    <span class="k">def</span> <span class="nf">do_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">request_json</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;jsonrpc&#39;</span><span class="p">:</span> <span class="s1">&#39;2.0&#39;</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
            <span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{},</span>
            <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">post</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">request_json</span><span class="p">),</span>
            <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>
        <span class="p">)</span>

    <span class="c1"># python内建方法，当获取某个对象的属性时，调用该对象的该方法</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Dynamically create an object class (ie: host)&#34;&#34;&#34;</span>
        <span class="c1"># 此处把self传给ZabbixAPIObjectClass的self.parent</span>
        <span class="k">return</span> <span class="n">ZabbixAPIObjectClass</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ZabbixAPIObjectClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Dynamically create a method (ie: get)&#34;&#34;&#34;</span>

        <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">args</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&#34;Found both args and kwargs&#34;</span><span class="p">)</span>

            <span class="c1"># 此处把父类传进来的方法名name和子方法attr拼成rpc的方法名</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">do_request</span><span class="p">(</span>
                <span class="s1">&#39;{0}.{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span>
                <span class="n">args</span> <span class="ow">or</span> <span class="n">kwargs</span>
            <span class="p">)[</span><span class="s1">&#39;result&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">fn</span>
</code></pre></td></tr></table>
</div>
</div><p>类似地，很多接口的实现都可以照搬这种方式把参数调用改成链式调用，如 pymongo，redis-py 等。</p>
<h2 id="参考资料">参考资料：</h2>
<p><a href="https://github.com/lukecyca/pyzabbix">https://github.com/lukecyca/pyzabbix</a></p>
]]></description></item><item><title>Python Fabric库无法启动后台进程的问题和解决办法</title><link>https://sund.site/posts/2016/py-fabric/</link><pubDate>Wed, 19 Oct 2016 16:25:51 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2016/py-fabric/</guid><description><![CDATA[<h2 id="问题和处理方法">问题和处理方法</h2>
<p>Python 的 Fabric 库能够方便的远程操作 Linux 主机执行命令或传输文件。其实现方式就是底层实现 ssh 协议，例如执行下面代码的 run 方法，在目标主机上启动一个 zabbix 后台服务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">fabric</span> <span class="kn">import</span> <span class="n">api</span>
<span class="kn">from</span> <span class="nn">fabric.tasks</span> <span class="kn">import</span> <span class="n">Task</span>


<span class="k">class</span> <span class="nc">Zabbix</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">api</span><span class="o">.</span><span class="n">settings</span><span class="p">(</span><span class="n">host_string</span><span class="o">=</span><span class="s1">&#39;192.168.1.2&#39;</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="s1">&#39;123456&#39;</span><span class="p">):</span>
            <span class="n">api</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;service zabbix_agentd start&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>但是这样操作后虽然 Fabric 的 output 返回结果打印是启动成功，但是 ssh 登录目标主机，却不见 zabbix_agentd 进程，这说明没有真正启动起来。</p>
<p>我查询了 Fabric 文档，发现需要在 api.run 里添加参数<code>pty=False</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">            <span class="n">api</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;service zabbix_agentd start&#39;</span><span class="err">，</span> <span class="n">pty</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这样就成功启动了后台进程。</p>
<h2 id="原因">原因</h2>
<h3 id="什么是-pty">什么是 pty？</h3>
<p>pty 是 pseudo-tty，众所周知 tty 是 Linux 支持输入与输出的终端设备，在 shell 下执行<code>ps</code>可以查看每个进程对应的 tty 设备号，如<code>ttys0001</code>。</p>
<p>pty 是为了解决远程连接时一方不希望对方直接 ssh 连接到主机上而诞生的「虚拟设备」，即伪 tty，其原理是在远程主机和本地之间同时启动 pty 端口连接终端，可以类比进程间的通道，pty 两端同时执行输入输出操作，如同本地直接连接到远程主机。但是一旦断开本地与远程主机的连接，pty 就会结束所有刚才的进程。</p>
<p>根据网上的资料，Github 仓库的 ssh 连接就采用 pty， Github 不希望用户创建一个可与它的主机交互的 ssh 连接，所以采用这种模式。</p>
<p>Fabric 在默认情况下就采用 pty ，所以想要用 fabric 登录目标主机启动后台进程，必须加上 <code>pty=False</code>。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://github.com/fabric/fabric/issues/395">https://github.com/fabric/fabric/issues/395</a>
<a href="http://ytliu.info/blog/2013/09/28/ttyde-na-xie-shi-er/">http://ytliu.info/blog/2013/09/28/ttyde-na-xie-shi-er/</a>
<a href="http://7056824.blog.51cto.com/69854/276610">http://7056824.blog.51cto.com/69854/276610</a></p>
]]></description></item><item><title>Python defaultdict结构作计数器的用法</title><link>https://sund.site/posts/2016/py-defaultdict/</link><pubDate>Tue, 11 Oct 2016 15:00:16 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2016/py-defaultdict/</guid><description><![CDATA[<p>在开发中经常需要用到计数器，当函数 foo 调用另一个函数 bar 时，为了确认调用 bar 之后处理的结果正确性，经常需要使用计数器来统计 bar 函数里处理成功了多少次。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">success_num</span> <span class="o">=</span> <span class="n">bar</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">success_num</span>

<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># 假设这个任务要迭代100次.</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">100</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count</span><span class="p">:</span>
            <span class="c1"># Do something.</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
</code></pre></td></tr></table>
</div>
</div><p>但是，这里需要定义多个计数器变量来保存计数。每多一个 bar 函数就要多定义两次计数器。有没有类似 C 语言指针一样的方法，可以在 foo 中定义后直接传给 bar，在 bar 里修改值呢。</p>
<p>众所周知，Python 的参数传值实际传的是变量的拷贝，但是对于像字典、列表等非基本数据结构，实际传给参数的是这个数据结构的指针地址，修改指针地址指向的实际值就可以在函数内外实现传递数据的效果了。那么利用这个特性，可以结合 python 标准库 collections 里的 defaultdict 结构来实现一个更方便的计数器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">bar</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Do something.</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;fail&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><p>这样，变量<code>result</code>就是存有正确计数和错误计数的字典。</p>
]]></description></item></channel></rss>