<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>python - Tag - 電波障害</title><link>https://sund.site/tags/python/</link><description>python - Tag - 電波障害</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Thu, 19 Jan 2023 08:05:27 +0800</lastBuildDate><atom:link href="https://sund.site/tags/python/" rel="self" type="application/rss+xml"/><item><title>Python 依赖管理工具的研究</title><link>https://sund.site/posts/2023/python-packaging/</link><pubDate>Thu, 19 Jan 2023 08:05:27 +0800</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2023/python-packaging/</guid><description><![CDATA[<h2 id="太长不读">太长不读</h2>
<p>请使用 <a href="https://pdm.fming.dev/latest/" target="_blank" rel="noopener noreffer ">PDM</a>.</p>
<h2 id="混乱的-python">混乱的 Python</h2>
<p>Python 的依赖管理工具 <code>pip</code> 一直被众多开发者吐槽。从我个人角度，<code>pip</code> 有三点致命缺陷：</p>
<ul>
<li>无法解决 Python 依赖环境的隔离问题</li>
<li>依赖管理文件 <code>requirements.txt</code> 无法真正开箱即用</li>
<li>打包部署非常麻烦，需要手动配置</li>
</ul>
<h3 id="环境隔离问题">环境隔离问题</h3>
<p>Python 的依赖库可以安装到系统全局，也可以安装到用户目录（<code>/home/${USER}/.local</code>）。但如果你同时管理多个 Python 项目，就需要将不同项目的依赖拆分到不同的文件夹分开管理。</p>
<p>传统方式是基于 virtualenv 创建隔离的 Python bin 文件和项目依赖的虚拟环境（所谓虚拟环境并不是虚拟机，只是个绑定 terminal session 的命令环境）。这种方式的缺点是：</p>
<ul>
<li>开发者需要经常关注“我现在处于哪个项目目录？我需要切换到当前虚拟环境里吗？”之类的问题。</li>
<li>virtualenv 只解决环境隔离，但是无法同步更新依赖文件、打包发布。</li>
</ul>
<h3 id="依赖安装问题">依赖安装问题</h3>
<p>Python 管理依赖的手段，最早是手动执行<code>pip install xxx</code>来安装依赖，最后 <code>pip freeze</code> 来导出依赖列表到一个 <code>requirements.txt</code> 文件里。但是这个 txt 文件非常令人困惑。</p>
<ul>
<li>不像 NodeJS 那么方便，想要升、降级某个依赖版本，无法自动同步到 txt 文件里。</li>
<li>平铺式地列出了所有一级、二级依赖包（即依赖包的依赖包）。因为 Python 某些依赖又基于系统上安装的 C 库版本，这就导致不同系统环境上执行 <code>pip install -r requirements.txt</code> 得到的效果并不一致，经常报错。</li>
</ul>
<h3 id="打包部署问题">打包部署问题</h3>
<p>Python 一般使用 <code>wheel</code> 打包二进制，它只解决打包问题，环境依赖是靠 pip 和 setuptools 完成，所以使用 wheel 你仍然要操心环境隔离和依赖管理问题。</p>
<p>另外基于 Python 各版本之间兼容性问题和底层实现上的不可抗拒力量，wheel 也经常会莫名其妙失败。</p>
<h2 id="现有的解决方案">现有的解决方案</h2>
<p>一直以来，出现过 <code>pipx</code>，<code>pipenv</code>， <code>conda</code>，<code>poetry</code> 以及我最近接触的 <code>pdm</code>。他们都在某种程度上解决了 Python 的问题，这篇文章：</p>
<p><a href="https://chriswarrick.com/blog/2023/01/15/how-to-improve-python-packaging" target="_blank" rel="noopener noreffer ">How to improve Python packaging, or why fourteen tools are at least twelve too many</a></p>
<p>对比了各种工具的利弊。最后得出结论是 poetry 和 pdm 是目前最合适的工具。而 pdm 是目前唯一支持 <a href="https://peps.python.org/pep-0582/" target="_blank" rel="noopener noreffer ">PEP 582</a> 的依赖管理工具。</p>
<h3 id="什么是-pep-582">什么是 PEP 582</h3>
<blockquote>
<p>This PEP proposes to add to Python a mechanism to automatically recognize a <code>__pypackages__</code> directory and prefer importing packages installed in this location over user or global site-packages. This will avoid the steps to create, activate or deactivate “virtual environments”. Python will use the <code>__pypackages__</code> from the base directory of the script when present.</p>
</blockquote>
<p>这个 PEP 的目的就是基于一个文件夹 <code>__pypackages__ </code>来管理 Python 的依赖，类似 nodejs 的<code>node_modules</code>，用户不需要再创建虚拟环境来隔离依赖包。Python 会自动识别和安装依赖。</p>
<h3 id="pdm">PDM</h3>
<p>PDM 实现了 PEP 582！这让我们在解决 Python 依赖问题时不用再考虑虚拟环境。</p>
<h4 id="初始化项目">初始化项目</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">pdm init
</code></pre></td></tr></table>
</div>
</div><p>之后 PDM 会问几个问题，记得选择<strong>不使用虚拟机环境</strong>，这样 PDM 就会默认使用 PEP 582 的解决方案，在项目下生成一个类似 NodeJS 的 <code>__pypackages__</code>。</p>
<p>剩下的操作就跟 NodeJS 的 npm 非常像了。</p>
<p>添加一个依赖之后，PDM 会自动更新<code>pyproject.toml</code>文件。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">pdm add requests
</code></pre></td></tr></table>
</div>
</div><h4 id="安装项目依赖">安装项目依赖</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">pdm install
</code></pre></td></tr></table>
</div>
</div><h4 id="启动项目">启动项目</h4>
<p>先在 <code>pyproject.toml</code>里添加</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>tool.pdm.scripts<span class="o">]</span>
<span class="nv">start</span> <span class="o">=</span> <span class="s2">&#34;flask run -p 54321&#34;</span>
</code></pre></td></tr></table>
</div>
</div><p>然后执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">pdm run start
</code></pre></td></tr></table>
</div>
</div><h4 id="打包部署">打包部署</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">pdm build
pdm publish
</code></pre></td></tr></table>
</div>
</div><h2 id="总结">总结</h2>
<p>如果你从事科研工作，用 <code>conda</code>。</p>
<p>如果你从事工程项目，<code>poetry</code>是目前业内用的最多的方案，大多数情况下它是个不错的依赖管理工具。但是如果你不喜欢 Python 的 virtualenv，<code>pdm</code>是更好的选择。</p>
]]></description></item><item><title>《Python源码剖析》第三部分——Python虚拟机进阶</title><link>https://sund.site/posts/2017/python-3/</link><pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2017/python-3/</guid><description><![CDATA[<h2 id="python-环境初始化">Python 环境初始化</h2>
<p>进程启动后创建PyInterpreterObject，PyInterpreterObject里面维护了全局module映射表<code>interp-&gt;modules</code>，该表默认初始化为__buildin__模块，</p>
<h2 id="python-的-import-机制">Python 的 import 机制</h2>
<blockquote>
<p>Python虚拟机在执行“import A”时，会为package A创建一个module对象，同时会在该module维护的dict中添加两个表示元信息的属性：<strong>name__和__path</strong>。而Python虚拟机从A/<strong>init</strong>.py中执行“import mod1”时，也会为mod1创建一个module对象，同时也会设置__name__属性，但是这时就不设置__path__属性了。</p>
</blockquote>
<blockquote>
<p>package是由module聚合而成。更清楚的表述是：module属于一个package。我们不能说，module1属于module2。我们前面已经看到，module的路径实际上是一种树状结构，从图14-11中可以看到，在这个树状结构中，module的父节点只能是package，而不可能是另一个module。</p>
</blockquote>
<h2 id="gil">GIL</h2>
<p>Python虚拟机使用一个全局解释器锁（Global Interpreter Lock，GIL）来互斥线程对python虚拟机的使用。</p>
<p>注意这里GIL是解释器一级的互斥锁，也就是同一时间只能有一个线程占用python解释器。所以<strong>GIL是用来让操作系统中分配的多个线程互斥的使用python解释器的，是建立在系统线程调度基础之上的一套C API互斥机制</strong>，是比操作系统线程资源更大粒度的锁。</p>
<p>Python的线程是基于操作系统原生线程的，所以python的线程不是「虚拟出来的」。</p>
<blockquote>
<p>那么究竟Python会在众多的等待线程中选择哪一个幸运儿呢？答案是，不知道。没错，对于这个问题，Python完全没有插手，而是交给了底层的操作系统来解决。也就是说，Python借用了底层操作系统所提供的线程调度机制来决定下一个进入Python解释器的线程究竟是谁。</p>
</blockquote>
<p>GIL在C里对应的结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="p">[</span><span class="n">thread_nt</span><span class="p">.</span><span class="n">h</span><span class="p">]</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">NRMUTEX</span> <span class="p">{</span>
    <span class="n">LONG</span>   <span class="n">owned</span> <span class="p">;</span>
    <span class="n">DWORD</span>  <span class="n">thread_id</span> <span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">hevent</span> <span class="p">;</span>
<span class="p">}</span> <span class="n">NRMUTEX</span><span class="p">,</span> <span class="o">*</span><span class="n">PNRMUTEX</span> <span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>其中<code>owned</code>初始化为-1，表示锁可用，否则为不可用。<code>thread_id</code>代表线程id，最后一个是平台相关的变量，win32上是一个event内核对象。</p>
<h2 id="多线程---标准调度">多线程 - 标准调度</h2>
<blockquote>
<p>当Python启动时，是并不支持多线程的。换句话说，Python中支持多线程的数据结构以及GIL都是没有创建的，Python之所以有这种行为是因为大多数的Python程序都不需要多线程的支持</p>
</blockquote>
<p>书中指出，由于python的多线程标准调度机制是有代价的，所以默认单线程不初始化GIL。</p>
<ol>
<li>主线程启动后，会用<code>ident = PyThread_start_new_thread(t_bootstrap, (void*) boot);</code>函数调用操作系统内核接口创建子线程，然后主线程挂起等待<code>obj.done</code>。注意，此时主线程中持有GIL。</li>
<li>主线程等待的这段时间里，子线程将自己的线程id等信息设置好，通知内核对象<code>obj.done</code>，唤醒等待中的主线程。此刻，主线程和子线程都同时由操作系统调度，但是主线程一直持有着GIL。</li>
<li>子线程继续执行后进入python解释器，发现需要等待获取GIL。此时子线程主动将自己挂起(而不是由操作系统挂起)。这样就进入了两个线程通过GIL调度的阶段。</li>
<li>主线程被唤醒后，继续执行，直到python内置的时钟计时器<code>_Py_Ticker</code>结束才将自己挂起，让出GIL(<code>_Py_Ticker</code>会在每次执行一条字节码后自动减1，初始默认为100)。</li>
</ol>
<p>通过上面4步，python的两个线程就完成了从系统调度上升到python标准GIL调度的流程。</p>
<h2 id="阻塞调度">阻塞调度</h2>
<p>如同上面流程介绍的，标准调度是python使用软件时钟调度线程，那么有时候python的线程会自我阻塞，比如<code>raw_input()</code>、<code>sleep()</code>等函数，这时python就会使用阻塞调度的方式。</p>
<ol>
<li>主线程调用<code>sleep(1)</code>后，调用<code>Py_BEGIN_ALLOW_THREADS</code>立刻释放GIL，然后调用操作系统的sleep操作。此时主线程就由操作系统自动管理。</li>
<li>子线程拿到GIL。此时主线程和子线程同时可被操作系统调度。操作系统在执行一段时间子线程后会挂起，调度主线程，发现主线程sleep没结束就挂起主线程，就继续唤醒子线程执行。</li>
<li>当主线程sleep结束，操作系统唤醒主线程。主线程调用<code>Py_END_ALLOW_THREADS</code>再次申请GIL，重新进入python标准调度流程。</li>
</ol>
<p><strong>可见python在保证线程安全的前提下，允许线程在某些时刻脱离GIL标准调度流程。</strong></p>
<p>其中<code>Py_BEGIN_ALLOW_THREADS</code>和<code>Py_END_ALLOW_THREADS</code>两个负责释放和等待GIL的宏的实现如下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="p">[</span><span class="n">ceval</span><span class="p">.</span><span class="n">h</span><span class="p">]</span>
<span class="cp">#define Py_BEGIN_ALLOW_THREADS { \
</span><span class="cp">            PyThreadState *_save; \
</span><span class="cp">            _save = PyEval_SaveThread();
</span><span class="cp">#define Py_END_ALLOW_THREADS    PyEval_RestoreThread(_save); \
</span><span class="cp">         }
</span><span class="cp"></span>
<span class="p">[</span><span class="n">ceval</span><span class="p">.</span><span class="n">c</span><span class="p">]</span>
<span class="n">PyThreadState</span><span class="o">*</span> <span class="n">PyEval_SaveThread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">PyThreadState</span> <span class="o">*</span><span class="n">tstate</span> <span class="o">=</span> <span class="n">PyThreadState_Swap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">interpreter_lock</span><span class="p">)</span>
        <span class="n">PyThread_release_lock</span><span class="p">(</span><span class="n">interpreter_lock</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tstate</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">PyEval_RestoreThread</span><span class="p">(</span><span class="n">PyThreadState</span> <span class="o">*</span><span class="n">tstate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">interpreter_lock</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
        <span class="n">PyThread_acquire_lock</span><span class="p">(</span><span class="n">interpreter_lock</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">errno</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">PyThreadState_Swap</span><span class="p">(</span><span class="n">tstate</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="用户级互斥">用户级互斥</h2>
<p>用户级的互斥锁利用操作系统的互斥机制实现，同时要考虑防止和GIL形成死锁。所以过程与阻塞调度类似需要使用<code>Py_BEGIN_ALLOW_THREADS</code>和<code>Py_END_ALLOW_THREADS</code>这两个宏。</p>
<ol>
<li>线程a调用lock对象加锁，lock对象内部调用系统互斥机制，同时执行<code>Py_BEGIN_ALLOW_THREADS</code>释放GIL防止死锁。</li>
<li>线程b获得GIL，执行到某处释放锁，lock对象内部调用系统机制释放锁，同时底层调用了<code>Py_END_ALLOW_THREADS</code>等待GIL。</li>
<li>线程a被系统唤醒，获取GIL，一气呵成。</li>
</ol>
<h2 id="子线程的销毁">子线程的销毁</h2>
<blockquote>
<p>在线程的全部计算完成之后，Python将销毁线程。需要注意的是，Python主线程的销毁与子线程的销毁是不同的，因为主线程的销毁动作必须要销毁Python的运行时环境，而子线程的销毁则不需要进行这些动作。</p>
</blockquote>
<h2 id="内存管理">内存管理</h2>
<p>大块内存管理直接调用C的malloc和free接口，小块内存分配则由python的内存池管理机制调度。</p>
<h3 id="小块内存管理的对象">小块内存管理的对象</h3>
<p>Python的内存块叫block，每个block大小不同，都是8的整数倍。管理block的叫pool，一个pool是4K。pool管理<strong>相同大小</strong>的一堆block。pool对象的szindex变量保存了这个pool对应的block大小。</p>
<blockquote>
<p>，一个pool可能管理了100个32个字节的block，也可能管理了100个64个字节的block，但是绝不会有一个管理了50个32字节的block和50个64字节的block的pool存在</p>
</blockquote>
<p>Python对于内存块的管理类似对象的策略，每次内存分配一整个block，回收时先将不用的Block加入闲置的队列里等待重新利用，不是直接回收。(惰性回收策略)</p>
<p>管理多个pool的数据对象是arena。下图可见，pool结构是一次性分配好一块内存，而arena则是通过指针连向一块pool。</p>
<p></p>
<p>而python维护一个名叫arenas的数组，数组元素就是arena对象。arena之间通过由两条链表相连。它们分别是：</p>
<ul>
<li><em>unused_arena_objects</em> 是单向量表，指向未分配pool的arena</li>
<li><em>usable_arenas</em> 是双向链表，表示已经分配了pool的arena</li>
</ul>
<p></p>
<blockquote>
<p>当一个arena的area_object没有与pool集合建立联系时，这时的arena处于“未使用”状态；一旦建立了联系，这时arena就转换到了“可用”状态。对于每一种状态，都有一个arena的链表。“未使用”的arena的链表表头是unused_arena_objects、arena与arena之间通过nextarena连接，是一个单向链表；而“可用”的arena的链表表头是usable_arenas、arena与arena之间通过nextarena和prevarena连接，是一个双向链表。</p>
</blockquote>
<p><strong>Pool是python管理内存的对象，arena虽然更上层，但是arena内的pool集合可能管理32字节的block，也可能管理64字节的block，所以arena无法决定销毁和分配内存。Python仍然以pool为单位管理内存开销。(pool有size概念，arena没有size概念)</strong></p>
<p>Pool有三种状态full、empty和used。其中full不需要连接起来，其他两种状态会被freepools和usedpools连接起来方便管理。</p>
<p></p>
<h3 id="arena的分配">arena的分配</h3>
<p>arena可以指向32位pool集合，也可以指向64位pool集合。分配内存的过程如下：</p>
<ol>
<li>先在usable_arenas链表上找可用的arena，然后找到符合要求的pool</li>
<li>如果没有可用的arena，则从arenas数组里摘下来新的arena，放在usable_arenas里，然后初始化pool</li>
<li>从usedpools链表里找可用的blocks</li>
<li>usedpools没有可用的pool，就从freepools链表分配一个empty状态的pool</li>
</ol>
<h3 id="python编译时指定内存上限">Python编译时指定内存上限</h3>
<blockquote>
<p>当Python在WITH_MEMORY_LIMITS编译符号打开的背景下进行编译时，Python内部的另一个符号会被激活，这个名为SMALL_MEMORY_LIMIT的符号限制了整个内存池的大小，同时，也就限制了可以创建的arena的个数。在默认情况下，不论是Win32平台，还是unix平台，这个编译符号都是没有打开的，所以通常Python都没有对小块内存的内存池的大小做任何的限制。</p>
</blockquote>
<h3 id="小块内存管理的流程">小块内存管理的流程</h3>
<p><em>(此部分摘自书中代码注释)</em></p>
<ol>
<li>如果申请的内存小于SMALL_REQUEST_THRESHOLD，使用Python的小块内存的内存池。否则，转向malloc</li>
<li>根据申请内存的大小获得对应的size class index</li>
<li>如果usedpools中可用的pool，使用这个pool来分配block</li>
<li>分配结束后，如果pool中的block都被分配了，将pool从usedpools中摘除</li>
<li>如果usedpools中没有可用的pool，从usable_arenas中获取pool</li>
<li>如果usable_arenas中没有就“可用”的arena，开始申请arena</li>
<li>从usable_arenas的第一个arena中获取一个pool</li>
<li>获取pool成功，进行init pool的动作，将pool放入used_pools中，并返回分配得到的block</li>
<li>获取pool失败，对arena中的pool集合进行初始化，然后转入goto到init pool的动作处，初始化一个特定的pool</li>
</ol>
<h3 id="python-25对多次分配小内存造成内存泄漏的处理">Python 2.5对多次分配小内存造成内存泄漏的处理</h3>
<p>在2.5之前版本，Python的arena从来不释放pool。这就造成反复分配小内存后造成的arena太多而内存无法回收。</p>
<p>2.5之后的处理办法：arena有两种状态，unused和usable。上文已经介绍过。</p>
<ol>
<li>如果arena中所有的pool都是empty的，释放pool集合占用的内存。arena变成unused状态，从usable_arenas剔除</li>
<li>如果arena初始化了新的pool，arena变成usable状态，从usable_arenas链表中顺序查找位置插入该arena。注意，usable_arenas是有序链表(按照arena中pool的个数排序，pool多的arena排前边，pool少的排后边)</li>
<li>这样，再有分配内存的请求时，先从usable_arenas表头顺序查，排在前边pool多的arena就被利用的充分，pool少的arena就更有可能变成unused状态，容易被释放掉。达到节省内存的目的</li>
</ol>
<h3 id="内存池全景">内存池全景</h3>
<p></p>
<h2 id="python垃圾回收机制">Python垃圾回收机制</h2>
<p>除了计数器，python还是使用了标记-清除，分代回收机制。</p>
<h3 id="标记---清除">标记 - 清除</h3>
<h4 id="三色模型">三色模型</h4>
<p>根据系统内所有对象的引用情况建立有向图，沿着有向图从根开始的逐层染色，黑色代表该节点所有引用都检查过了，灰色表示节点是可达的，当所有灰色节点都变为黑色，检查结束。</p>
<p></p>
<h3 id="python-中的标记清除">Python 中的标记清除</h3>
<p>Python的对象由三大部分组成，PyGC_Head，PyObject_Head和本体。其中PyObject_Head里存计数器用来标记当前节点是否可回收，但是对于循环引用的情况，就需要PyGC_Head里的refs，python会根据一些触发条件进行三色模型的标记，某个对象的「可达次数」标记在PyGC_Head里，当这个可达次数为0时，代表对象不可达，也就需要回收之。PyGC_Head之间有一条双向链表连接了所有对象，将他们纳入内存回收管理系统里。</p>
<p></p>
<h4 id="流程">流程</h4>
<ol>
<li>在垃圾收集的第一步，就是遍历可收集对象链表，将每个对象的gc.gc_ref值设置为其ob_refcnt值。</li>
<li>接下来的动作就是要将环引用从引用中摘除。</li>
<li>有一些container对象的<code>PyGC_Head.gc.gc_ref</code>还不为0，这就意味着存在对这些对象的外部引用，这些对象，就是开始标记 - 清除算法的root object集合。</li>
</ol>
<h3 id="分代回收">分代回收</h3>
<blockquote>
<p>这种以空间换时间的总体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就称为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小，也就是说，活得越长的对象，就越可能不是垃圾，就应该越少去收集。</p>
</blockquote>
<p></p>
<blockquote>
<p>Python采用了三代的分代收集机制，如果当前收集的是第1代，那么在开始垃圾收集之前，Python会将比其“年轻”的所有代的内存链表（当然，在这里只有第0代）整个地链接到第1代内存链表之后，这个操作是通过gc_list_merge实现的。</p>
</blockquote>
<h3 id="总结">总结</h3>
<ol>
<li>将比当前处理的“代”更年轻的“代”的链表合并到当前“代”中</li>
<li>在待处理链表上进行打破循环的模拟，寻找root object</li>
<li>将待处理链表中的unreachable object转移到unreachable链表中，处理完成后，当前“代”中只剩下reachable object了</li>
<li>如果可能，将当前“代”中的reachable object合并到更老的“代”中</li>
<li>对于unreachable链表中的对象，如果其带有<code>__del__</code>函数，则不能安全回收，需要将这些对象收集到finalizers链表中，因此，这些对象引用的对象也不能回收,也需要放入finalizers链表中</li>
<li>处理弱引用（weakref），如果可能，调用弱引用中注册的callback操作</li>
<li>对unreachable链表上的对象进行垃圾回收操作</li>
<li>将含有<code>__del__</code>操作的实例对象收集到Python内部维护的名为garbage的链表中，同时将finalizers链表中所有对象加入old链表中</li>
</ol>
<p><strong>注意，如果对象拥有<code>__del__</code>方法，就不能通过垃圾回收来自动回收</strong>，所以要慎重使用这个方法。</p>
]]></description></item><item><title>《Python源码剖析》第二部分——Python虚拟机基础</title><link>https://sund.site/posts/2017/python-2/</link><pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2017/python-2/</guid><description><![CDATA[<h2 id="python执行环境">Python执行环境</h2>
<blockquote>
<p>在编译过程中，这些包含在Python源代码中的静态信息都会被Python编译器收集起来，编译的结果中包含了字符串，常量值，字节码等在源代码中出现的一切有用的静态信息。在Python运行期间，这些源文件中提供的静态信息最终会被存储在一个运行时的对象中，当Python运行结束后，这个运行时对象中所包含的信息甚至还会被存储在一种文件中。这个对象和文件就是我们这章探索的重点：PyCodeObject对象和pyc文件。</p>
</blockquote>
<blockquote>
<p>在程序运行期间，编译结果存在于内存的PyCodeObject对象中；而Python结束运行后，编译结果又被保存到了pyc文件中。当下一次运行相同的程序时，Python会根据pyc文件中记录的编译结果直接建立内存中的PyCodeObject对象，而不用再次对源文件进行编译了。</p>
</blockquote>
<p>从文章摘录可见，python生成的不是编译后的文件，而是<code>.py</code>文件对应的静态信息——PyCodeObject，这里包括了字节码指令序列、字符串、常量。每个名字空间(类、模块、函数)都对应一个独立的PyCodeObject。(python连编译后的文件里存的都是个对象！)</p>
<p>不被import的py文件不会生成pyc。标准库里有py_compile等方法也可以生成pyc。</p>
<p><strong>import机制</strong> 导入某个模块时，先查找对应的pyc，如果没有pyc就生成然后import这个pyc。(所以实际导入的并不是py文件，而是py文件编译后的PyCodeObject)。</p>
<p><strong>PyFrameObject</strong> Python程序运行时的「执行环境」。参考操作系统执行可执行文件的过程。Python也是将函数对应的执行环境封装成栈帧的形式加载进内存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_frame</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="k">struct</span> <span class="n">_frame</span> <span class="o">*</span><span class="n">f_back</span><span class="p">;</span>  <span class="c1">//执行环境链上的前一个frame
</span><span class="c1"></span>    <span class="n">PyCodeObject</span> <span class="o">*</span><span class="n">f_code</span><span class="p">;</span>   <span class="c1">//PyCodeObject对象
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_builtins</span><span class="p">;</span>   <span class="c1">//builtin名字空间
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_globals</span><span class="p">;</span>    <span class="c1">//global名字空间
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_locals</span><span class="p">;</span>     <span class="c1">//local名字空间
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">**</span><span class="n">f_valuestack</span><span class="p">;</span>    <span class="c1">//运行时栈的栈底位置
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">**</span><span class="n">f_stacktop</span><span class="p">;</span>      <span class="c1">//运行时栈的栈顶位置
</span><span class="c1"></span>    <span class="err">……</span>
    <span class="kt">int</span> <span class="n">f_lasti</span><span class="p">;</span>        <span class="c1">//上一条字节码指令在f_code中的偏移位置
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">f_lineno</span><span class="p">;</span>       <span class="c1">//当前字节码对应的源代码行
</span><span class="c1"></span>    <span class="err">……</span>
    <span class="c1">//动态内存，维护（局部变量+cell对象集合+free对象集合+运行时栈）所需要的空间
</span><span class="c1"></span>    <span class="n">PyObject</span> <span class="o">*</span><span class="n">f_localsplus</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>  
<span class="p">}</span> <span class="n">PyFrameObject</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>Python标准库的<code>sys._getframe()</code>可以动态的在程序执行时获取当前内存中活跃的PyFrameObject信息。</p>
<h2 id="legb-规则">LEGB 规则</h2>
<p>即python作用域的查找顺序是<code>local</code>-<code>enclosing</code>-<code>global</code>-<code>buildin</code>。看下面代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
  <span class="k">print</span> <span class="n">a</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
  <span class="k">print</span> <span class="n">a</span> <span class="o">//</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">//</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
  <span class="k">print</span> <span class="n">a</span>

<span class="n">g</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>代码在[1]处会抛出异常，原因是python在编译阶段就把静态数据(局部变量、全局变量、字节码)放入pyc里，执行到<code>f()</code>里时，查找到<code>a</code>是在local作用域里定义的而不是global里，但是此时local的a还没赋值，所以就会抛出异常。由此可见，<strong>python作用域信息是在静态编译时就处理好了的</strong>。</p>
<h2 id="python-虚拟机运行框架">Python 虚拟机运行框架</h2>
<blockquote>
<p>运行时环境是一个全局的概念，而执行环境实际就是一个栈帧，是一个与某个Code Block对应的概念。</p>
</blockquote>
<blockquote>
<p>在PyCodeObject对象的co_code域中保存着字节码指令和字节码指令的参数，Python虚拟机执行字节码指令序列的过程就是从头到尾遍历整个co_code、依次执行字节码指令的过程。</p>
</blockquote>
<p>由上文引用可见，python在编译阶段将代码块的字节码保存在PyCodeObject的co_code属性里，然后在执行阶段从头到尾遍历这个co_code属性解读字节码。</p>
<p><strong>Python运行时环境</strong> Python在运行时用PyInterpreterState结构维护进程运行环境，PyThreadState维护线程运行环境，PyFrameObject维护栈帧运行环境，三者是依次包含关系，如下图所示：</p>
<p></p>
<p>Python虚拟机就是一个「软CPU」，动态加载上述三种结构进内存，并模拟操作系统执行过程。程序执行后，先创建各个运行时环境，再将栈帧中的字节码载入，循环遍历解释执行。</p>
<h2 id="python字节码">Python字节码</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="mi">0</span>   <span class="n">LOAD_CONST</span>   <span class="mi">0</span>  <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="mi">3</span>   <span class="n">STORE_NAME</span>   <span class="mi">0</span>  <span class="p">(</span><span class="n">i</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>例如python的一条语句<code>i=1</code>可以解释为下面两行字节码，最左边的第1列数字代表这行字节码在内存中的偏移位置，第2列是字节码的名字(CPU并不关心名字，它只是根据偏移量读出字节码，所以这个名字是方便阅读用的)，第3列是字节码的参数，如<code>LOAD_CONST</code>对应的数据在变量<code>f-&gt;f_code-&gt;co_consts</code>里，0就是这个参数位于<code>f-&gt;f_code-&gt;co_consts</code>的偏移量。最后一列的括号里是从参数里取到的value。</p>
<h2 id="python-的异常抛出机制">Python 的异常抛出机制</h2>
<p>异常处理的操作都在<code>Python/traceback.c</code>文件里，python每次调用一层函数，就创建改函数对应的PyFrameObject对象来保存函数运行时信息，PythonFrameObject里调用PyEval_EvalFrameEx循环解释字节码，如果抛出异常就创建PyTraceBackObject对象，将对象交给上一层PyFrameObject里的PyTracebackObject组成链表，最后返回最上层PyRun_SimpleFileExFlags函数，该函数调用PyErr_Print遍历PyTraceBackObject链表打印出异常信息。</p>
<p></p>
<h2 id="函数对象的实现">函数对象的实现</h2>
<p>PyFunctionObject是函数对象。在python调用函数时，生成PyFunctionObject对象，该对象的f_global指针用来将外层的全局变量传递给函数内部，然后在<code>ceval.c</code>文件的<code>fast_function</code>里解出PyFunctionObject对象里携带的信息，创建新的PyFrameObject对象(上文说过这个对象是维护运行时环境的)，最后调用执行字节码的函数<code>PyEval_EvalFrameEx</code>执行真正函数字节码。</p>
<p><strong>Python执行一段代码需要什么？</strong> 从书中描述可见，python执行一段代码需要做几件事：</p>
<ul>
<li>从源码编译出 PyCodeObject 保存变量和字节码</li>
<li>执行阶段，从PyCodeObject里取出信息交给 PyFrameObject，执行 PyEval_EvalFrameEx 解释字节码</li>
<li>如果遇到函数调用，就把函数对应的代码段从 PyCodeObject 存入 PyFunctionObject 对象，然后把这个函数对象通过参数传给新创建的 PyFrameObject ，在内层空间执行 PyEval_EvalFrameEx 解释字节码</li>
<li>将结果或异常存入 PyFrameObject 的变量( 异常是存入f_blockstack里，外层判断f_blockstack里的数据是被except捕获还是没有捕获而继续下一步操作) 抛给外层</li>
</ul>
<p>值得注意的是，<strong>python在执行阶段，将对函数参数的键值查找，转换为索引查找</strong>，即在转换PyCodeObject为PyFrameObject时，将参数信息按位置参数、键参数按照一定顺序存储在f_localsplus变量中，再用索引来查找对应参数，而需要查找键值。这样提高了运行时效率。下图是<code>foo('Rboert', age=5)</code>在内存中的存储形式。</p>
<p></p>
<h2 id="闭包的实现">闭包的实现</h2>
<p>Python在编译阶段就把函数闭包内层和闭包外层使用的变量存入PyCodeObject中：</p>
<ul>
<li>co_cellvars：通常是一个tuple，保存嵌套的作用域中使用的变量名集合；</li>
<li>co_freevars：通常也是一个tuple，保存使用了的外层作用域中的变量名集合。</li>
</ul>
<p>在执行阶段，PyFrameObject的f_localsplus中也为闭包的变量划分的内存区域，如下图所示：</p>
<p></p>
<h2 id="元类">元类</h2>
<p>元类<code>&lt;type type&gt;</code>和其他类的关系如下图：</p>
<p></p>
<p><strong>可调用性（callable）</strong> ，只要一个对象对应的class对象中实现了“<strong>call</strong>”操作（更确切地说，在Python内部的PyTypeObject中，tp_call不为空）那么这个对象就是一个可调用的对象，换句话说，在Python中，所谓“调用”，就是执行对象的type所对应的class对象的tp_call操作。</p>
<h2 id="descriptor">Descriptor</h2>
<blockquote>
<p>在PyType_Ready中，Python虚拟机会填充tp_dict，其中与操作名对应的是一个个descriptor
对于一个Python中的对象obj，如果obj.__ class__对应的class对象中存在__get__、__set__和__delete__三种操作，那么obj就可称为Python一个descriptor。</p>
</blockquote>
<blockquote>
<p>如果细分，那么descriptor还可分为如下两种：</p>
</blockquote>
<ol>
<li>data descriptor : type中定义了__get__和__set__的descriptor；</li>
<li>non data descriptor : type中只定义了__get__的descriptor。
在Python虚拟机访问instance对象的属性时，descriptor的一个作用是影响Python虚拟机对属性的选择。从PyObject_GenericGetAttr的伪代码可以看出，Python虚拟机会在instance对象自身的__dict__中寻找属性，也会在instance对象对应的class对象的mro列表中寻找</li>
</ol>
<blockquote>
<ol>
<li>Python虚拟机按照instance属性、class属性的顺序选择属性，即instance属性优先于class属性；</li>
<li>如果在class属性中发现同名的data descriptor，那么该descriptor会优先于instance属性被Python虚拟机选择</li>
</ol>
</blockquote>
<p></p>
<h3 id="引申python-黑魔法-descriptor-描述器">引申：Python 黑魔法 Descriptor (描述器)</h3>
<ul>
<li><a href="http://www.jianshu.com/p/250f0d305c35">http://www.jianshu.com/p/250f0d305c35</a></li>
<li><a href="http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html">http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html</a></li>
</ul>
<h2 id="bound-method和unbound-method">Bound Method和Unbound Method</h2>
<p>假设有下面两种对类方法的调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">A</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">A</span><span class="p">()</span>
<span class="c1"># [1]</span>
<span class="n">a</span><span class="o">.</span><span class="n">f</span><span class="p">()</span>  

<span class="c1"># [2]</span>
<span class="n">A</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="c1"># [3]</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">f</span>
<span class="n">func</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>在代码[1]里，实例a调用类方法f，python底层会自动完成实例a和类方法f之间的绑定动作(调用<code>func_ descr_get(A.f, a, A)</code>，将实例地址和函数对象PyFunctionObject封装到一个PyMethodObject)，而代码[2]里直接通过A调用，则f为非绑定的PyMethodObject，里面没有实例信息，需要传入a。</p>
<p>比较绑定方法与非绑定方法可知，通过[1]的方式每次都要绑定一次实例，开销非常大，下图比较的是[1]和[3]两种方式，绑定操作的执行次数。</p>
<p></p>
<p>结论： <strong>调用类实例绑定的方法时，如果方法执行次数非常多，最好将方法赋值给一个变量，防止重复绑定增加开销</strong></p>
]]></description></item><item><title>《Python源码剖析》第一部分——Python对象基础</title><link>https://sund.site/posts/2017/python/</link><pubDate>Wed, 12 Jul 2017 00:00:00 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2017/python/</guid><description><![CDATA[<h2 id="python的对象初始化">Python的对象初始化</h2>
<blockquote>
<p>在Python中，对象就是为C中的结构体在堆上申请的一块内存，一般来说，对象是不能被静态初始化的，并且也不能在栈空间上生存。唯一的例外就是类型对象，Python中所有的内建的类型对象（如整数类型对象，字符串类型对象）都是被静态初始化的。</p>
</blockquote>
<p>python 的对象不像 C 是分配在栈、堆、data segment等位置，而是全部分配在堆上！只有python内置类型在初始化时候才是被C语言层静态初始化。</p>
<p>PyObject内部就两样：引用计数器、类型对象指针。</p>
<p>类型对象的定义：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">_typeobject</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">tp_name</span><span class="p">;</span> <span class="cm">/* For printing, in format &#34;&lt;module&gt;.&lt;name&gt;&#34; */</span>
    <span class="kt">int</span> <span class="n">tp_basicsize</span><span class="p">,</span> <span class="n">tp_itemsize</span><span class="p">;</span> <span class="cm">/* For allocation */</span>

    <span class="cm">/* Methods to implement standard operations */</span>
    <span class="n">destructor</span> <span class="n">tp_dealloc</span><span class="p">;</span>
    <span class="n">printfunc</span> <span class="n">tp_print</span><span class="p">;</span>
    <span class="err">……</span>
    <span class="cm">/* More standard operations (here for binary compatibility) */</span>
    <span class="n">hashfunc</span> <span class="n">tp_hash</span><span class="p">;</span>
    <span class="n">ternaryfunc</span> <span class="n">tp_call</span><span class="p">;</span>
    <span class="err">……</span>
<span class="p">}</span> <span class="n">PyTypeObject</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p><code>PyObject_VAR_HEAD</code>是可变类型的头信息，其中除了<code>PyObject_HEAD</code>的内容外，额外添加了一个代表该对象元素数量的整型。从上边代码可见，python的类型也是一个可变对象。</p>
<h2 id="python的多态">Python的多态</h2>
<p>Python中所有类型在初始化后，在C语言层面都使用同一种指针<code>PyObject *</code>，所以python实现多态就非常容易。任何函数的参数都是一个PyObject类型指针，也就不存在编译器需要判断函数参数类型。</p>
<h2 id="python对象内存池">Python对象内存池</h2>
<p>Python为了避免频繁的释放对象，采用了内存池的机制，在对象引用计数为0时，不会释放内存，而是将内存交还给内存池供python重新分配使用。<strong>每一种python类型，都有特定的内存池机制。</strong></p>
<h2 id="整数对象">整数对象</h2>
<p>-5至257之间的小整数，存储在「小整数数组」里，这个数组Python自动创建，每次创建一个小整数，就指向这个数组里对应的PyIntObject值并把PyIntObject的计数加1。(因此在-5到257之间的数实际指向同一片内存空间，整数-5和-5的内存地址肯定是一样的)</p>
<p>大整数则由一个叫<code>block_list</code>的链表管理，每次分配一个大整数就在<code>free_list</code>(一个指向空闲内存block的指针)里拿出一个节点并把<code>free_list</code>后移一个<code>block</code>。关于<code>free_list</code>是如何把尚未分配的内存和已被释放的内存链接起来的，可以参见书中113页的插图理解。</p>
<p>值得注意的是，python用于分配给整型的堆内存是不会自行销毁的，而是不断复用。也就是说，<strong>同一时间如果同时使用的整型太多，会消耗大量内存，并且这些内存在python关闭之前一直被python持有着。</strong></p>
<h2 id="字符串对象">字符串对象</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">PyObject_VAR_HEAD</span>
    <span class="kt">long</span> <span class="n">ob_shash</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ob_sstate</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">ob_sval</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">PyStringObject</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>在Python源码中的注释显示，预存字符串的hash值(为了节省字符串比较的时间)和这里的intern机制将Python虚拟机的执行效率提升了20%。</p>
<p><strong>intern机制</strong> 将新建的字符串缓存在一个PyDictObject里，相同的字符串共用同一内存。</p>
<p>单一字符的字符串，除了用intern缓存外，还会缓存在系统自带的一个字符串缓冲池里：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">static</span> <span class="n">PyStringObject</span> <span class="o">*</span><span class="n">characters</span><span class="p">[</span><span class="n">UCHAR_MAX</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> 
</code></pre></td></tr></table>
</div>
</div><p><strong><code>+</code>操作符和<code>join</code>的效率问题</strong> <code>+</code>连接n个操作符会创建n-1次临时空间，<code>join</code>会直接处理一个list里的字符串，只分配一次内存。节省开销。</p>
<h2 id="列表对象">列表对象</h2>
<p>参见C++ vector对象的存储方式。</p>
<h2 id="字典对象">字典对象</h2>
<p>Python使用散列表(时间复杂度O(1))而非红黑树(时间复杂度O(logN))来存储map结构。</p>
<p>**Hash冲突(碰撞)**不同的值映射到相同的键时，就产生了冲突。一般解决办法有：</p>
<ul>
<li>
<p>开链法(哈希桶)：
</p>
</li>
<li>
<p>开放定址法：
hash一次没有命中就再hash一次，直到找到为止……(二次探测)</p>
</li>
</ul>
<p>小于8个元素的Dict，python使用PyDIctObject内部的smalltable数组保存元素内容。</p>
<p>PyDictObject对String类型的key做了特殊对待——简化了计算hash函数的过程(正常情况下key值是一个<code>PyObject *</code>对象，需要做大量类型判断，但是对PyStringObject就省了)。</p>
<p>**装载率(使用的空间/预先分配的空间)**大于2/3时，hash冲突的概率会急速升高，这时python就会动态分配更多的空间。与其他类型一样，如果装载率太小，也会自动缩减分配的空间。</p>
<blockquote>
<p>在确定新的table的大小时，通常选用的策略是时新的table中entry的数量是现在table中Active态entry数量的4倍，选用4倍是为了使table中处于Active态的entry的分布更加稀疏，减少插入元素时的冲突概率……所以当table中Active态的entry数量非常大时，Python只会要求2倍的空间，这次又是以执行速度来交换内存空间。</p>
</blockquote>
<p>注意这段话，执行速度和内存大小是反比关系，划分的空间越大，执行一次查找就越费时，所以分配的内存空间不是越大越好。</p>
<p>PyDictObject也使用了同PyListObject一样的缓冲池方式。参考列表对象部分内容。</p>
<p><em><strong>笔者总结：从上面的各种类型的处理规律可以总结出Python遵循的原则：小变量缓存，大变量尽量整块分配内存，回收变量时不释放内存而是尽量复用，预分配的空间既要满足需要又不能太大(太大就缩减)</strong></em></p>
]]></description></item><item><title>Python2 中字符类型的一些坑</title><link>https://sund.site/posts/2017/py-str/</link><pubDate>Wed, 11 Jan 2017 11:09:00 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2017/py-str/</guid><description><![CDATA[<h2 id="问题">问题</h2>
<p>有一道面试题是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">a</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;China&#39;</span>
<span class="n">b</span> <span class="o">=</span> <span class="s1">&#39;China&#39;</span>
<span class="n">c</span> <span class="o">=</span> <span class="sa">u</span><span class="s1">&#39;中国&#39;</span>
<span class="n">d</span> <span class="o">=</span> <span class="s1">&#39;中国&#39;</span>
<span class="c1"># 1</span>
<span class="k">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="c1"># 2</span>
<span class="k">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">c</span>
<span class="c1"># 3</span>
<span class="k">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">d</span>
<span class="c1"># 4</span>
<span class="k">print</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>判断打印后的效果。</p>
<p>先说正确答案，只有最后一行会报错。</p>
<h2 id="分析">分析</h2>
<p>在Python2里，默认的字符类型是<code>str</code>，这个<code>str</code>和Python3的<code>str</code>完全不同，Python2的<code>str</code>类型是8位的ascii序列。Python2在处理<code>str</code>类型转换时遵循这样的规则：<strong>如果被处理的<code>str</code>型变量值小于7位，就可以和<code>unicode</code>类型混用。可以做<code>+</code>连接，格式化等操作，同unicode享受同样的待遇。</strong></p>
<p>Python2在格式化字符时，会把<code>str</code>格式化为<code>str</code>，如果字符串里混入了<code>unicode</code>，就会把其他字符都转化为<code>unicode</code>。所以这道题里1处的a，b两个值混合后的字符就是一个unicode字符串，c和d单独格式化后仍保留了自己的格式。但是Python2在格式化代码位置4时，发现c是unicode而d不是，就会尝试按照上面的混用规则，格式化d为unicode类型，但是d的值<code>'中国'</code>显然是一个大于7位的<code>str</code>，因此Python2抛出UnicodeDecodeError。</p>
<p>在Python3里，<code>str</code>类型则变成了一个纯unicode字符，也就是说Python3里的<code>str</code>等价于Python2里的<code>unicode</code>类型。Python3里为了清晰明了，使用<code>bytes</code>代表8位ascii序列。除此之外，Python3严格禁止混用两种类型。</p>
<h2 id="总结">总结</h2>
<ul>
<li>使用Python2处理字符串，尤其是中文字符串，最好前边加上u</li>
<li>Python2里不要混用<code>str</code>和<code>unicode</code>，如果处理文本时，先将全部数据格式化成unicode</li>
<li>能用Python3尽量不用Python2 <del>(废话)</del></li>
</ul>
<h2 id="参考资料">参考资料：</h2>
<ul>
<li>《Effective Python》 Brett Slatkin.</li>
<li>不愿意透露姓名的某厂面试官</li>
</ul>
]]></description></item><item><title>Python yield关键字的底层实现</title><link>https://sund.site/posts/2016/py-yield/</link><pubDate>Wed, 28 Dec 2016 18:00:00 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2016/py-yield/</guid><description><![CDATA[<p>这几天面试被问到类似的问题，顺便看了看Python的源码，参考网上的教程，总结一下yield关键字在C层面是如何实现的。</p>
<h2 id="举个栗子">举个栗子</h2>
<p>我们先看一个python生成器函数的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">dis</span> <span class="kn">import</span> <span class="n">dis</span>

<span class="k">def</span> <span class="nf">func</span><span class="p">():</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="k">yield</span> <span class="n">i</span>
    <span class="k">print</span> <span class="n">i</span>
    
<span class="n">dis</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span><span class="n">func</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
<span class="n">a</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</code></pre></td></tr></table>
</div>
</div><p>使用python的库dis可以直接查看python虚拟机运行的字节码。<code>dis(func)</code>的打印如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  6           0 LOAD_CONST               1 (4)
              3 STORE_FAST               0 (i)

  7           6 LOAD_FAST                0 (i)
              9 YIELD_VALUE         
             10 POP_TOP             

  8          11 LOAD_FAST                0 (i)
             14 PRINT_ITEM          
             15 PRINT_NEWLINE       
             16 LOAD_CONST               0 (None)
             19 RETURN_VALUE      
</code></pre></td></tr></table>
</div>
</div><p>我们猜测其中第二列(代表字节码偏移量)为9的指令<code>YIELD_VALUE</code>就是yield关键字的执行代码，进入Python2.7.12源码目录，在解释器执行字节码的主函数<code>PyEval_EvalFrameEx</code>中找到了下面一段：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c">          <span class="n">TARGET_NOARG</span><span class="p">(</span><span class="n">YIELD_VALUE</span><span class="p">)</span>
          <span class="p">{</span>
              <span class="n">retval</span> <span class="o">=</span> <span class="n">POP</span><span class="p">();</span>
              <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_stacktop</span> <span class="o">=</span> <span class="n">stack_pointer</span><span class="p">;</span>
              <span class="n">why</span> <span class="o">=</span> <span class="n">WHY_YIELD</span><span class="p">;</span>
              <span class="c1">// 跳转到fast_yield处。fast_yield里处理了一下状态位然后返回结果
</span><span class="c1"></span>              <span class="k">goto</span> <span class="n">fast_yield</span><span class="p">;</span>
          <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中<code>TARGET_NOARG</code>为封装了<code>case</code>语句的宏，这句话的意思是，如果字节码是<code>YIELD_VALUE</code>，就把栈顶元素赋值给<code>retval</code>，然后跳转到<code>fast_yield</code>处，<code>fast_yield</code>处代码进行了一些状态判断后直接返回了<code>retval</code>。</p>
<h2 id="生成器是如何记录代码返回位置的">生成器是如何记录代码返回位置的</h2>
<p>显然，如果这时候调用代码<code>a.next()</code>就会直接返回yield后边的表达式结果。这对应了上面C代码的<code>fast_yield</code>部分，那生成器怎么记录上次执行的位置并在下一次调用<code>a.next()</code>的时候从上次的位置继续执行的呢？</p>
<p>Python在解释代码时，是将代码块加载为一个叫PyFrameObject的对象，这个对象代表了当前运行的栈帧。PyFrameObject里有个<code>f_lasti</code>变量用于保存代码当前执行到了字节码的哪个位置。在第二次执行<code>a.next()</code>时，生成器对象把之前携带了<code>f_lasti</code>的PyFrameObject当参数传给<code>PyEval_EvalFrameEx</code>，在<code>PyEval_EvalFrameEx</code>里的执行一个JUMPTO就直接跳转到了上一次结束生成器时的字节码位置：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">PyObject</span> <span class="o">*</span>
<span class="nf">PyEval_EvalFrameEx</span><span class="p">(</span><span class="n">PyFrameObject</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">int</span> <span class="n">throwflag</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
<span class="cp">#define FAST_DISPATCH() \
</span><span class="cp">          { \
</span><span class="cp">      if (!lltrace &amp;&amp; !_Py_TracingPossible) { \
</span><span class="cp">          f-&gt;f_lasti = INSTR_OFFSET(); \
</span><span class="cp">          goto *opcode_targets[*next_instr++]; \
</span><span class="cp">      } \
</span><span class="cp">      </span><span class="c1">// 跳转到fast_next_opcode处
</span><span class="c1"></span>      <span class="k">goto</span> <span class="n">fast_next_opcode</span><span class="p">;</span> \
          <span class="p">}</span>
<span class="p">...</span>
<span class="nl">fast_next_opcode</span><span class="p">:</span>
          <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_lasti</span> <span class="o">=</span> <span class="n">INSTR_OFFSET</span><span class="p">();</span>
  
          <span class="cm">/* line-by-line tracing support */</span>
  
          <span class="k">if</span> <span class="p">(</span><span class="n">_Py_TracingPossible</span> <span class="o">&amp;&amp;</span>
              <span class="n">tstate</span><span class="o">-&gt;</span><span class="n">c_tracefunc</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tstate</span><span class="o">-&gt;</span><span class="n">tracing</span><span class="p">)</span> <span class="p">{</span>
              <span class="p">...</span>
              <span class="cm">/* Reload possibly changed frame fields */</span>
              <span class="c1">// 按照f-&gt;f_lasti中的偏移量跳转字节码
</span><span class="c1"></span>              <span class="n">JUMPTO</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">f_lasti</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中<code>INSTR_OFFSET</code>宏正是字节码的偏移量。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#define INSTR_OFFSET()  ((int)(next_instr - first_instr))
</span><span class="cp"></span>
<span class="c1">// co-&gt;co_code里保存的是字节码
</span><span class="c1"></span><span class="n">first_instr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span> <span class="n">PyString_AS_STRING</span><span class="p">(</span><span class="n">co</span><span class="o">-&gt;</span><span class="n">co_code</span><span class="p">);</span>
<span class="n">next_instr</span> <span class="o">=</span> <span class="n">first_instr</span> <span class="o">+</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">f_lasti</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>所以生成器对象每次执行结束都把字节码的偏移量记录下来，并把运行状态保存在PyFrameObject里，下一次运行时生成器时，python解释器直接按照偏移量寻找下一个字节码指令。</p>
]]></description></item><item><title>Python 巧妙地将rpc接口封装成pythonic的链式调用</title><link>https://sund.site/posts/2016/py-pythonic/</link><pubDate>Tue, 25 Oct 2016 15:40:43 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2016/py-pythonic/</guid><description><![CDATA[<p>这是一个外国人实现的Zabbix(一个开源监控工具)的Python Client——pyzabbix里的代码片段。</p>
<h2 id="rpc调用">RPC调用</h2>
<p>Rpc调用的流程是向rpc服务端指定的uri(如http://www.abc.com/jsonrpc.php) 发送json(或其他双方约定格式)数据包，数据包里有rpc版本信息、方法名、参数等。下面<code>Zabbix</code>类里的<code>do_request</code>方法就完成了将方法名和方法参数打包json后发送请求的过程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Zabbix</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># ... skip other class methods</span>
    
    <span class="k">def</span> <span class="nf">do_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">request_json</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;jsonrpc&#39;</span><span class="p">:</span> <span class="s1">&#39;2.0&#39;</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
            <span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{},</span>
            <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">post</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">request_json</span><span class="p">),</span>
            <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>
        <span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="技巧">技巧</h2>
<p>但是为了方便，我们在python里一般使用<code>zabbixclient.host.get(args)</code>这样的链式调用，而不用<code>zabbixclient('host.get', args)</code>这样的调用方式。pyzabbix的作者巧妙的实现了这样的转换。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Zabbix</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="c1"># ... skip other class methods</span>
    
    <span class="k">def</span> <span class="nf">do_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">request_json</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;jsonrpc&#39;</span><span class="p">:</span> <span class="s1">&#39;2.0&#39;</span><span class="p">,</span>
            <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">,</span>
            <span class="s1">&#39;params&#39;</span><span class="p">:</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{},</span>
            <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">session</span><span class="o">.</span><span class="n">post</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">url</span><span class="p">,</span>
            <span class="n">data</span><span class="o">=</span><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">request_json</span><span class="p">),</span>
            <span class="n">timeout</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">timeout</span>
        <span class="p">)</span>

    <span class="c1"># python内建方法，当获取某个对象的属性时，调用该对象的该方法</span>
    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Dynamically create an object class (ie: host)&#34;&#34;&#34;</span>
        <span class="c1"># 此处把self传给ZabbixAPIObjectClass的self.parent</span>
        <span class="k">return</span> <span class="n">ZabbixAPIObjectClass</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ZabbixAPIObjectClass</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="s2">&#34;&#34;&#34;Dynamically create a method (ie: get)&#34;&#34;&#34;</span>

        <span class="k">def</span> <span class="nf">fn</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">args</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&#34;Found both args and kwargs&#34;</span><span class="p">)</span>
        
            <span class="c1"># 此处把父类传进来的方法名name和子方法attr拼成rpc的方法名</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">do_request</span><span class="p">(</span>
                <span class="s1">&#39;{0}.{1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">attr</span><span class="p">),</span>
                <span class="n">args</span> <span class="ow">or</span> <span class="n">kwargs</span>
            <span class="p">)[</span><span class="s1">&#39;result&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">fn</span>
</code></pre></td></tr></table>
</div>
</div><p>类似地，很多接口的实现都可以照搬这种方式把参数调用改成链式调用，如pymongo，redis-py等。</p>
<h2 id="参考资料">参考资料：</h2>
<p><a href="https://github.com/lukecyca/pyzabbix">https://github.com/lukecyca/pyzabbix</a></p>
]]></description></item><item><title>Python Fabric库无法启动后台进程的问题和解决办法</title><link>https://sund.site/posts/2016/py-fabric/</link><pubDate>Wed, 19 Oct 2016 16:25:51 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2016/py-fabric/</guid><description><![CDATA[<h2 id="问题和处理方法">问题和处理方法</h2>
<p>Python 的 Fabric 库能够方便的远程操作Linux主机执行命令或传输文件。其实现方式就是底层实现ssh协议，例如执行下面代码的run方法，在目标主机上启动一个zabbix后台服务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">fabric</span> <span class="kn">import</span> <span class="n">api</span>
<span class="kn">from</span> <span class="nn">fabric.tasks</span> <span class="kn">import</span> <span class="n">Task</span>


<span class="k">class</span> <span class="nc">Zabbix</span><span class="p">(</span><span class="n">Task</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">api</span><span class="o">.</span><span class="n">settings</span><span class="p">(</span><span class="n">host_string</span><span class="o">=</span><span class="s1">&#39;192.168.1.2&#39;</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="n">password</span><span class="o">=</span><span class="s1">&#39;123456&#39;</span><span class="p">):</span>
            <span class="n">api</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;service zabbix_agentd start&#39;</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>但是这样操作后虽然 Fabric 的 output 返回结果打印是启动成功，但是ssh登录目标主机，却不见 zabbix_agentd 进程，这说明没有真正启动起来。</p>
<p>我查询了 Fabric 文档，发现需要在api.run里添加参数<code>pty=False</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python">            <span class="n">api</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;service zabbix_agentd start&#39;</span><span class="err">，</span> <span class="n">pty</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这样就成功启动了后台进程。</p>
<h2 id="原因">原因</h2>
<h3 id="什么是pty">什么是pty？</h3>
<p>pty 是 pseudo-tty，众所周知 tty 是 Linux 支持输入与输出的终端设备，在 shell 下执行<code>ps</code>可以查看每个进程对应的tty设备号，如<code>ttys0001</code>。</p>
<p>pty 是为了解决远程连接时一方不希望对方直接ssh连接到主机上而诞生的「虚拟设备」，即伪tty，其原理是在远程主机和本地之间同时启动pty端口连接终端，可以类比进程间的通道，pty两端同时执行输入输出操作，如同本地直接连接到远程主机。但是一旦断开本地与远程主机的连接，pty就会结束所有刚才的进程。</p>
<p>根据网上的资料，Github 仓库的 ssh 连接就采用 pty， Github 不希望用户创建一个可与它的主机交互的 ssh 连接，所以采用这种模式。</p>
<p>Fabric 在默认情况下就采用 pty ，所以想要用 fabric 登录目标主机启动后台进程，必须加上 <code>pty=False</code>。</p>
<h2 id="参考资料">参考资料</h2>
<p><a href="https://github.com/fabric/fabric/issues/395">https://github.com/fabric/fabric/issues/395</a>
<a href="http://ytliu.info/blog/2013/09/28/ttyde-na-xie-shi-er/">http://ytliu.info/blog/2013/09/28/ttyde-na-xie-shi-er/</a>
<a href="http://7056824.blog.51cto.com/69854/276610">http://7056824.blog.51cto.com/69854/276610</a></p>
]]></description></item><item><title>Python defaultdict结构作计数器的用法</title><link>https://sund.site/posts/2016/py-defaultdict/</link><pubDate>Tue, 11 Oct 2016 15:00:16 +0000</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2016/py-defaultdict/</guid><description><![CDATA[<p>在开发中经常需要用到计数器，当函数foo调用另一个函数bar时，为了确认调用bar之后处理的结果正确性，经常需要使用计数器来统计bar函数里处理成功了多少次。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">success_num</span> <span class="o">=</span> <span class="n">bar</span><span class="p">()</span>
    <span class="k">print</span> <span class="n">success_num</span>

<span class="k">def</span> <span class="nf">bar</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># 假设这个任务要迭代100次.</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">100</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count</span><span class="p">:</span>
            <span class="c1"># Do something.</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">n</span>
</code></pre></td></tr></table>
</div>
</div><p>但是，这里需要定义多个计数器变量来保存计数。每多一个bar函数就要多定义两次计数器。有没有类似C语言指针一样的方法，可以在foo中定义后直接传给bar，在bar里修改值呢。</p>
<p>众所周知，Python的参数传值实际传的是变量的拷贝，但是对于像字典、列表等非基本数据结构，实际传给参数的是这个数据结构的指针地址，修改指针地址指向的实际值就可以在函数内外实现传递数据的效果了。那么利用这个特性，可以结合python标准库collections里的defaultdict结构来实现一个更方便的计数器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">bar</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">print</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="n">result</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">count</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Do something.</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;success&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">result</span><span class="p">[</span><span class="s1">&#39;fail&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></td></tr></table>
</div>
</div><p>这样，变量<code>result</code>就是存有正确计数和错误计数的字典。</p>
]]></description></item></channel></rss>