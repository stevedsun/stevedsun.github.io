<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>memory leak - Tag - 電波障害</title><link>https://sund.site/tags/memory-leak/</link><description>memory leak - Tag - 電波障害</description><generator>Hugo -- gohugo.io</generator><language>en</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Tue, 27 Jun 2023 14:46:59 +0800</lastBuildDate><atom:link href="https://sund.site/tags/memory-leak/" rel="self" type="application/rss+xml"/><item><title>Go 内存泄漏常见模式</title><link>https://sund.site/posts/2023/goroutine-leak/</link><pubDate>Tue, 27 Jun 2023 14:46:59 +0800</pubDate><author>Steve Sun</author><guid>https://sund.site/posts/2023/goroutine-leak/</guid><description><![CDATA[<p>最近在工作中排查 Go 语言内存泄漏问题时，发现<a href="https://www.uber.com/blog/leakprof-featherlight-in-production-goroutine-leak-detection/" target="_blank" rel="noopener noreffer ">这篇 Uber 写的博客</a>，其中分享了几种常见的 goroutine 内存泄漏模式，于是把整理了 goroutine 的相关问题，希望更多人搜索到到这篇文章，帮助大家快速定位内存泄漏问题。</p>
<h2 id="goroutine-内存泄漏的原因">Goroutine 内存泄漏的原因</h2>
<p>Go 语言的内存泄漏通常因为错误地使用 goroutine 和 channel。例如以下几种情况：</p>
<ol>
<li>在 goroutine 里打开一个连接（如 gRPC）但是忘记 close</li>
<li>在 goroutine 里的全局变量对象没有释放</li>
<li>在 goroutine 里读 channel， 但是没有写入端，而被阻塞</li>
<li>在 goroutine 里写入无缓冲的 channel，但是由于 channel 的读端被其他协程关闭而阻塞</li>
<li>在 goroutine 里写入有缓冲的 channel，但是 channel 缓冲已满</li>
</ol>
<p>这几种情况，通常掺杂在复杂的代码里逻辑里，很难调试发现问题。因此衍生出以下几种日常工作中<strong>最容易出现问题的模式</strong>。</p>
<h2 id="常见-goroutine-内存泄漏模式">常见 Goroutine 内存泄漏模式</h2>
<h3 id="premature-function-return-功能过早返回">Premature Function Return /功能过早返回</h3>
<p>一个 goroutine 要写入 channel，但是在另一个端意外退出导致 channel 读取的代码没有执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Example</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">a</span> <span class="o">:=</span> <span class="mi">1</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">err</span>
        <span class="k">return</span>
    <span class="p">}()</span>

    <span class="c1">// do something
</span><span class="c1"></span>
    <span class="k">if</span> <span class="nx">a</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span>
    <span class="p">}</span>

    <span class="c1">// do something
</span><span class="c1"></span>
    <span class="nx">err</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>代码中主进程在<code>if a &gt; 0</code> 处 return，导致 channel 无法写入而被阻塞。</p>
<p>解决这种问题的一个思路是把无缓冲 channel 转化为缓冲大小为 1 的 channel。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">error</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>有缓冲 channel 即使没有读取操作，也不会阻塞。</p>
<h3 id="the-timeout-leak-超时泄漏">The Timeout Leak /超时泄漏</h3>
<p>这是我们工作中遇到的问题，经常需要执行一个可能超时的异步操作时被使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Example</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">timeoutOption</span> <span class="o">:=</span> <span class="nf">SomeTimeoutOption</span><span class="p">()</span>
    <span class="nx">done</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">any</span><span class="p">)</span>
    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">done</span> <span class="o">&lt;-</span> <span class="nx">result</span>
    <span class="p">}()</span>

    <span class="k">select</span> <span class="p">{</span>
        <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">done</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">case</span> <span class="o">&lt;-</span> <span class="nx">timeoutOption</span><span class="p">.</span><span class="nf">Timeout</span><span class="p">():</span>
            <span class="k">return</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>在这段代码里，一旦 timeoutOption 操作超时，就会通知 select，接着程序退出，于是 goroutine 写入 done 的操作被阻塞而无法退出。</p>
<p>解决思路同上一个模式，用有缓冲 channel 替代无缓冲 channel。</p>
<h3 id="the-ncast-leak-多端读写泄漏">The NCast Leak /多端读写泄漏</h3>
<p>如果 channel 的读端只有一个，但是写端有多个，就会发生这种情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Example</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">any</span><span class="p">)</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">i</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">items</span> <span class="p">{</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="kd">chan</span> <span class="nx">any</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">result</span>
        <span class="p">}(</span><span class="nx">c</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">data</span> <span class="o">:=</span> <span class="o">&lt;-</span> <span class="nx">c</span>
    <span class="k">return</span>
<span class="p">}</span>

</code></pre></td></tr></table>
</div>
</div><p>这种情况也适用于“多个写端一个读端”的情况，解决方法是把 channel 设置成和写或读数量一致的缓冲数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">any</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">items</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="channel-iteration-misuse-通道迭代误用">Channel Iteration Misuse /通道迭代误用</h3>
<p>Go 支持一种特性 <a href="https://gobyexample.com/range-over-channels" target="_blank" rel="noopener noreffer ">&ldquo;Range over channels&rdquo;</a>, 可以用 range 来循环读取 channel 的内容。</p>
<p>但是一旦读取不到内容，range 就会等待 channel 的写入，而 range 如果正好在 goroutine 内部，这个 goroutine 就会被阻塞。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">Example</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
    <span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">any</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nx">items</span> <span class="p">{</span>
        <span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
            <span class="nx">c</span> <span class="o">&lt;-</span> <span class="nx">data</span>
        <span class="p">}()</span>
    <span class="p">}</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="nx">data</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span> <span class="p">{</span>
            <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}()</span>

    <span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>解决这个问题的方式手动定义关闭 channel。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{}</span>
<span class="nx">c</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="nx">any</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span>
<span class="c1">//...
</span></code></pre></td></tr></table>
</div>
</div><p>这样在 WaitGroup 全部结束后，主程序会关闭 channel，从而让异步的 goroutine 内部的 range 退出循环等待。</p>
<h2 id="小结">小结</h2>
<p>Goroutine 内存泄漏是 Go 语言最容易发生的内存泄漏情况，它通常伴随着错误地使用 goroutine 和 channel。而 channel 的特殊用法如 select 和 range 又让 channel 阻塞变得更加隐蔽不易发现，进而增加排查内存泄漏的难度。</p>
<p>在写 goroutine 和调试内存泄漏问题时，要重点关注 channel 相关的操作，尤其涉及到文中列举的四类模式：功能过早返回、超时泄漏、多端读写泄漏、通道迭代误用。</p>
]]></description></item></channel></rss>