<!doctype html><html lang=en-us><head><title>《Python源码剖析》第三部分——Python虚拟机进阶 | 电波障害</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="写作者分享思想，同时也帮助自己思考。"><meta name=generator content="Hugo 0.79.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-64688885-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><nav class=navigation><a href=/><span class=arrow>←</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a>
<a class=button href=https://sund.site/index.xml>Subscribe</a></nav><main class=main><section id=single><h1 class=title>《Python源码剖析》第三部分——Python虚拟机进阶</h1><div class=tip><span>Jul 14, 2017 00:00</span>
<span class=split>·</span>
<span>5817 words</span>
<span class=split>·</span>
<span>12 minute read</span></div><div class=content><h2 id=python-环境初始化>Python 环境初始化 <a href=#python-%e7%8e%af%e5%a2%83%e5%88%9d%e5%a7%8b%e5%8c%96 class=anchor>🔗</a></h2><p>进程启动后创建PyInterpreterObject，PyInterpreterObject里面维护了全局module映射表<code>interp->modules</code>，该表默认初始化为__buildin__模块，</p><h2 id=python-的-import-机制>Python 的 import 机制 <a href=#python-%e7%9a%84-import-%e6%9c%ba%e5%88%b6 class=anchor>🔗</a></h2><blockquote><p>Python虚拟机在执行“import A”时，会为package A创建一个module对象，同时会在该module维护的dict中添加两个表示元信息的属性：<strong>name__和__path</strong>。而Python虚拟机从A/<strong>init</strong>.py中执行“import mod1”时，也会为mod1创建一个module对象，同时也会设置__name__属性，但是这时就不设置__path__属性了。</p></blockquote><blockquote><p>package是由module聚合而成。更清楚的表述是：module属于一个package。我们不能说，module1属于module2。我们前面已经看到，module的路径实际上是一种树状结构，从图14-11中可以看到，在这个树状结构中，module的父节点只能是package，而不可能是另一个module。</p></blockquote><h2 id=gil>GIL <a href=#gil class=anchor>🔗</a></h2><p>Python虚拟机使用一个全局解释器锁（Global Interpreter Lock，GIL）来互斥线程对python虚拟机的使用。</p><p>注意这里GIL是解释器一级的互斥锁，也就是同一时间只能有一个线程占用python解释器。所以<strong>GIL是用来让操作系统中分配的多个线程互斥的使用python解释器的，是建立在系统线程调度基础之上的一套C API互斥机制</strong>，是比操作系统线程资源更大粒度的锁。</p><p>Python的线程是基于操作系统原生线程的，所以python的线程不是「虚拟出来的」。</p><blockquote><p>那么究竟Python会在众多的等待线程中选择哪一个幸运儿呢？答案是，不知道。没错，对于这个问题，Python完全没有插手，而是交给了底层的操作系统来解决。也就是说，Python借用了底层操作系统所提供的线程调度机制来决定下一个进入Python解释器的线程究竟是谁。</p></blockquote><p>GIL在C里对应的结构：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>[thread_nt.h]
<span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#a2f;font-weight:700>struct</span> NRMUTEX {
    LONG   owned ;
    DWORD  thread_id ;
    HANDLE hevent ;
} NRMUTEX, <span style=color:#666>*</span>PNRMUTEX ;
</code></pre></div><p>其中<code>owned</code>初始化为-1，表示锁可用，否则为不可用。<code>thread_id</code>代表线程id，最后一个是平台相关的变量，win32上是一个event内核对象。</p><h2 id=多线程---标准调度>多线程 - 标准调度 <a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b---%e6%a0%87%e5%87%86%e8%b0%83%e5%ba%a6 class=anchor>🔗</a></h2><blockquote><p>当Python启动时，是并不支持多线程的。换句话说，Python中支持多线程的数据结构以及GIL都是没有创建的，Python之所以有这种行为是因为大多数的Python程序都不需要多线程的支持</p></blockquote><p>书中指出，由于python的多线程标准调度机制是有代价的，所以默认单线程不初始化GIL。</p><ol><li>主线程启动后，会用<code>ident = PyThread_start_new_thread(t_bootstrap, (void*) boot);</code>函数调用操作系统内核接口创建子线程，然后主线程挂起等待<code>obj.done</code>。注意，此时主线程中持有GIL。</li><li>主线程等待的这段时间里，子线程将自己的线程id等信息设置好，通知内核对象<code>obj.done</code>，唤醒等待中的主线程。此刻，主线程和子线程都同时由操作系统调度，但是主线程一直持有着GIL。</li><li>子线程继续执行后进入python解释器，发现需要等待获取GIL。此时子线程主动将自己挂起(而不是由操作系统挂起)。这样就进入了两个线程通过GIL调度的阶段。</li><li>主线程被唤醒后，继续执行，直到python内置的时钟计时器<code>_Py_Ticker</code>结束才将自己挂起，让出GIL(<code>_Py_Ticker</code>会在每次执行一条字节码后自动减1，初始默认为100)。</li></ol><p>通过上面4步，python的两个线程就完成了从系统调度上升到python标准GIL调度的流程。</p><h2 id=阻塞调度>阻塞调度 <a href=#%e9%98%bb%e5%a1%9e%e8%b0%83%e5%ba%a6 class=anchor>🔗</a></h2><p>如同上面流程介绍的，标准调度是python使用软件时钟调度线程，那么有时候python的线程会自我阻塞，比如<code>raw_input()</code>、<code>sleep()</code>等函数，这时python就会使用阻塞调度的方式。</p><ol><li>主线程调用<code>sleep(1)</code>后，调用<code>Py_BEGIN_ALLOW_THREADS</code>立刻释放GIL，然后调用操作系统的sleep操作。此时主线程就由操作系统自动管理。</li><li>子线程拿到GIL。此时主线程和子线程同时可被操作系统调度。操作系统在执行一段时间子线程后会挂起，调度主线程，发现主线程sleep没结束就挂起主线程，就继续唤醒子线程执行。</li><li>当主线程sleep结束，操作系统唤醒主线程。主线程调用<code>Py_END_ALLOW_THREADS</code>再次申请GIL，重新进入python标准调度流程。</li></ol><p><strong>可见python在保证线程安全的前提下，允许线程在某些时刻脱离GIL标准调度流程。</strong></p><p>其中<code>Py_BEGIN_ALLOW_THREADS</code>和<code>Py_END_ALLOW_THREADS</code>两个负责释放和等待GIL的宏的实现如下。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>[ceval.h]
<span style=color:#080>#define Py_BEGIN_ALLOW_THREADS { \
</span><span style=color:#080>            PyThreadState *_save; \
</span><span style=color:#080>            _save = PyEval_SaveThread();
</span><span style=color:#080>#define Py_END_ALLOW_THREADS    PyEval_RestoreThread(_save); \
</span><span style=color:#080>         }
</span><span style=color:#080></span>
[ceval.c]
PyThreadState<span style=color:#666>*</span> PyEval_SaveThread(<span style=color:#0b0;font-weight:700>void</span>)
{
    PyThreadState <span style=color:#666>*</span>tstate <span style=color:#666>=</span> PyThreadState_Swap(<span style=color:#a2f>NULL</span>);
    <span style=color:#a2f;font-weight:700>if</span> (interpreter_lock)
        PyThread_release_lock(interpreter_lock);
    <span style=color:#a2f;font-weight:700>return</span> tstate;
}

<span style=color:#0b0;font-weight:700>void</span> PyEval_RestoreThread(PyThreadState <span style=color:#666>*</span>tstate)
{
    <span style=color:#a2f;font-weight:700>if</span> (interpreter_lock) {
        <span style=color:#0b0;font-weight:700>int</span> err <span style=color:#666>=</span> errno;
        PyThread_acquire_lock(interpreter_lock, <span style=color:#666>1</span>);
        errno <span style=color:#666>=</span> err;
    }
    PyThreadState_Swap(tstate);
}
</code></pre></div><h2 id=用户级互斥>用户级互斥 <a href=#%e7%94%a8%e6%88%b7%e7%ba%a7%e4%ba%92%e6%96%a5 class=anchor>🔗</a></h2><p>用户级的互斥锁利用操作系统的互斥机制实现，同时要考虑防止和GIL形成死锁。所以过程与阻塞调度类似需要使用<code>Py_BEGIN_ALLOW_THREADS</code>和<code>Py_END_ALLOW_THREADS</code>这两个宏。</p><ol><li>线程a调用lock对象加锁，lock对象内部调用系统互斥机制，同时执行<code>Py_BEGIN_ALLOW_THREADS</code>释放GIL防止死锁。</li><li>线程b获得GIL，执行到某处释放锁，lock对象内部调用系统机制释放锁，同时底层调用了<code>Py_END_ALLOW_THREADS</code>等待GIL。</li><li>线程a被系统唤醒，获取GIL，一气呵成。</li></ol><h2 id=子线程的销毁>子线程的销毁 <a href=#%e5%ad%90%e7%ba%bf%e7%a8%8b%e7%9a%84%e9%94%80%e6%af%81 class=anchor>🔗</a></h2><blockquote><p>在线程的全部计算完成之后，Python将销毁线程。需要注意的是，Python主线程的销毁与子线程的销毁是不同的，因为主线程的销毁动作必须要销毁Python的运行时环境，而子线程的销毁则不需要进行这些动作。</p></blockquote><h2 id=内存管理>内存管理 <a href=#%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86 class=anchor>🔗</a></h2><p>大块内存管理直接调用C的malloc和free接口，小块内存分配则由python的内存池管理机制调度。</p><h3 id=小块内存管理的对象>小块内存管理的对象 <a href=#%e5%b0%8f%e5%9d%97%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%9a%84%e5%af%b9%e8%b1%a1 class=anchor>🔗</a></h3><p>Python的内存块叫block，每个block大小不同，都是8的整数倍。管理block的叫pool，一个pool是4K。pool管理<strong>相同大小</strong>的一堆block。pool对象的szindex变量保存了这个pool对应的block大小。</p><blockquote><p>，一个pool可能管理了100个32个字节的block，也可能管理了100个64个字节的block，但是绝不会有一个管理了50个32字节的block和50个64字节的block的pool存在</p></blockquote><p>Python对于内存块的管理类似对象的策略，每次内存分配一整个block，回收时先将不用的Block加入闲置的队列里等待重新利用，不是直接回收。(惰性回收策略)</p><p>管理多个pool的数据对象是arena。下图可见，pool结构是一次性分配好一块内存，而arena则是通过指针连向一块pool。</p><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/2duvofnkP9LEO8x.jpg alt></p></p><p>而python维护一个名叫arenas的数组，数组元素就是arena对象。arena之间通过由两条链表相连。它们分别是：</p><ul><li><em>unused_arena_objects</em> 是单向量表，指向未分配pool的arena</li><li><em>usable_arenas</em> 是双向链表，表示已经分配了pool的arena</li></ul><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/duFq5I6lWACjQyw.jpg alt></p></p><blockquote><p>当一个arena的area_object没有与pool集合建立联系时，这时的arena处于“未使用”状态；一旦建立了联系，这时arena就转换到了“可用”状态。对于每一种状态，都有一个arena的链表。“未使用”的arena的链表表头是unused_arena_objects、arena与arena之间通过nextarena连接，是一个单向链表；而“可用”的arena的链表表头是usable_arenas、arena与arena之间通过nextarena和prevarena连接，是一个双向链表。</p></blockquote><p><strong>Pool是python管理内存的对象，arena虽然更上层，但是arena内的pool集合可能管理32字节的block，也可能管理64字节的block，所以arena无法决定销毁和分配内存。Python仍然以pool为单位管理内存开销。(pool有size概念，arena没有size概念)</strong></p><p>Pool有三种状态full、empty和used。其中full不需要连接起来，其他两种状态会被freepools和usedpools连接起来方便管理。</p><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/mZr1P7ocQYbpCFB.jpg alt></p></p><h3 id=arena的分配>arena的分配 <a href=#arena%e7%9a%84%e5%88%86%e9%85%8d class=anchor>🔗</a></h3><p>arena可以指向32位pool集合，也可以指向64位pool集合。分配内存的过程如下：</p><ol><li>先在usable_arenas链表上找可用的arena，然后找到符合要求的pool</li><li>如果没有可用的arena，则从arenas数组里摘下来新的arena，放在usable_arenas里，然后初始化pool</li><li>从usedpools链表里找可用的blocks</li><li>usedpools没有可用的pool，就从freepools链表分配一个empty状态的pool</li></ol><h3 id=python编译时指定内存上限>Python编译时指定内存上限 <a href=#python%e7%bc%96%e8%af%91%e6%97%b6%e6%8c%87%e5%ae%9a%e5%86%85%e5%ad%98%e4%b8%8a%e9%99%90 class=anchor>🔗</a></h3><blockquote><p>当Python在WITH_MEMORY_LIMITS编译符号打开的背景下进行编译时，Python内部的另一个符号会被激活，这个名为SMALL_MEMORY_LIMIT的符号限制了整个内存池的大小，同时，也就限制了可以创建的arena的个数。在默认情况下，不论是Win32平台，还是unix平台，这个编译符号都是没有打开的，所以通常Python都没有对小块内存的内存池的大小做任何的限制。</p></blockquote><h3 id=小块内存管理的流程>小块内存管理的流程 <a href=#%e5%b0%8f%e5%9d%97%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86%e7%9a%84%e6%b5%81%e7%a8%8b class=anchor>🔗</a></h3><p><em>(此部分摘自书中代码注释)</em></p><ol><li>如果申请的内存小于SMALL_REQUEST_THRESHOLD，使用Python的小块内存的内存池。否则，转向malloc</li><li>根据申请内存的大小获得对应的size class index</li><li>如果usedpools中可用的pool，使用这个pool来分配block</li><li>分配结束后，如果pool中的block都被分配了，将pool从usedpools中摘除</li><li>如果usedpools中没有可用的pool，从usable_arenas中获取pool</li><li>如果usable_arenas中没有就“可用”的arena，开始申请arena</li><li>从usable_arenas的第一个arena中获取一个pool</li><li>获取pool成功，进行init pool的动作，将pool放入used_pools中，并返回分配得到的block</li><li>获取pool失败，对arena中的pool集合进行初始化，然后转入goto到init pool的动作处，初始化一个特定的pool</li></ol><h3 id=python-25对多次分配小内存造成内存泄漏的处理>Python 2.5对多次分配小内存造成内存泄漏的处理 <a href=#python-25%e5%af%b9%e5%a4%9a%e6%ac%a1%e5%88%86%e9%85%8d%e5%b0%8f%e5%86%85%e5%ad%98%e9%80%a0%e6%88%90%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e7%9a%84%e5%a4%84%e7%90%86 class=anchor>🔗</a></h3><p>在2.5之前版本，Python的arena从来不释放pool。这就造成反复分配小内存后造成的arena太多而内存无法回收。</p><p>2.5之后的处理办法：arena有两种状态，unused和usable。上文已经介绍过。</p><ol><li>如果arena中所有的pool都是empty的，释放pool集合占用的内存。arena变成unused状态，从usable_arenas剔除</li><li>如果arena初始化了新的pool，arena变成usable状态，从usable_arenas链表中顺序查找位置插入该arena。注意，usable_arenas是有序链表(按照arena中pool的个数排序，pool多的arena排前边，pool少的排后边)</li><li>这样，再有分配内存的请求时，先从usable_arenas表头顺序查，排在前边pool多的arena就被利用的充分，pool少的arena就更有可能变成unused状态，容易被释放掉。达到节省内存的目的</li></ol><h3 id=内存池全景>内存池全景 <a href=#%e5%86%85%e5%ad%98%e6%b1%a0%e5%85%a8%e6%99%af class=anchor>🔗</a></h3><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/1Lh6u4awv8ZyQ9H.jpg alt></p></p><h2 id=python垃圾回收机制>Python垃圾回收机制 <a href=#python%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e6%9c%ba%e5%88%b6 class=anchor>🔗</a></h2><p>除了计数器，python还是使用了标记-清除，分代回收机制。</p><h3 id=标记---清除>标记 - 清除 <a href=#%e6%a0%87%e8%ae%b0---%e6%b8%85%e9%99%a4 class=anchor>🔗</a></h3><h4 id=三色模型>三色模型 <a href=#%e4%b8%89%e8%89%b2%e6%a8%a1%e5%9e%8b class=anchor>🔗</a></h4><p>根据系统内所有对象的引用情况建立有向图，沿着有向图从根开始的逐层染色，黑色代表该节点所有引用都检查过了，灰色表示节点是可达的，当所有灰色节点都变为黑色，检查结束。</p><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/2a1kYDnyT4fBQxP.jpg alt></p></p><h3 id=python-中的标记清除>Python 中的标记清除 <a href=#python-%e4%b8%ad%e7%9a%84%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4 class=anchor>🔗</a></h3><p>Python的对象由三大部分组成，PyGC_Head，PyObject_Head和本体。其中PyObject_Head里存计数器用来标记当前节点是否可回收，但是对于循环引用的情况，就需要PyGC_Head里的refs，python会根据一些触发条件进行三色模型的标记，某个对象的「可达次数」标记在PyGC_Head里，当这个可达次数为0时，代表对象不可达，也就需要回收之。PyGC_Head之间有一条双向链表连接了所有对象，将他们纳入内存回收管理系统里。</p><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/UT5ry697VXINBQp.jpg alt></p></p><h4 id=流程>流程 <a href=#%e6%b5%81%e7%a8%8b class=anchor>🔗</a></h4><ol><li>在垃圾收集的第一步，就是遍历可收集对象链表，将每个对象的gc.gc_ref值设置为其ob_refcnt值。</li><li>接下来的动作就是要将环引用从引用中摘除。</li><li>有一些container对象的<code>PyGC_Head.gc.gc_ref</code>还不为0，这就意味着存在对这些对象的外部引用，这些对象，就是开始标记 - 清除算法的root object集合。</li></ol><h3 id=分代回收>分代回收 <a href=#%e5%88%86%e4%bb%a3%e5%9b%9e%e6%94%b6 class=anchor>🔗</a></h3><blockquote><p>这种以空间换时间的总体思想是：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就称为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小，也就是说，活得越长的对象，就越可能不是垃圾，就应该越少去收集。</p></blockquote><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/mQuPrwyD73ZjhBv.jpg alt></p></p><blockquote><p>Python采用了三代的分代收集机制，如果当前收集的是第1代，那么在开始垃圾收集之前，Python会将比其“年轻”的所有代的内存链表（当然，在这里只有第0代）整个地链接到第1代内存链表之后，这个操作是通过gc_list_merge实现的。</p></blockquote><h3 id=总结>总结 <a href=#%e6%80%bb%e7%bb%93 class=anchor>🔗</a></h3><ol><li>将比当前处理的“代”更年轻的“代”的链表合并到当前“代”中</li><li>在待处理链表上进行打破循环的模拟，寻找root object</li><li>将待处理链表中的unreachable object转移到unreachable链表中，处理完成后，当前“代”中只剩下reachable object了</li><li>如果可能，将当前“代”中的reachable object合并到更老的“代”中</li><li>对于unreachable链表中的对象，如果其带有<code>__del__</code>函数，则不能安全回收，需要将这些对象收集到finalizers链表中，因此，这些对象引用的对象也不能回收,也需要放入finalizers链表中</li><li>处理弱引用（weakref），如果可能，调用弱引用中注册的callback操作</li><li>对unreachable链表上的对象进行垃圾回收操作</li><li>将含有<code>__del__</code>操作的实例对象收集到Python内部维护的名为garbage的链表中，同时将finalizers链表中所有对象加入old链表中</li></ol><p><strong>注意，如果对象拥有<code>__del__</code>方法，就不能通过垃圾回收来自动回收</strong>，所以要慎重使用这个方法。</p></div><div class=tags><a href=https://sund.site/tags/python>python</a></div></section></main><footer id=footer><div id=social><a class=symbol href=https://github.com/stevedsun target=_blank><svg fill="#bbb" width="28" height="28" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Github</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)"><g id="Github" transform="translate(264.000000, 939.000000)"><path d="M8 72H64C68.418278 72 72 68.418278 72 64V8c0-4.418278-3.581721999999999-8-8-8H8c-4.418278 811624501e-24-8 3.581722-8 8V64C541083001e-24 68.418278 3.581722 72 8 72z" id="Rounded" fill="#bbb"/><path d="M35.9985 13C22.746 13 12 23.7870921 12 37.096644 12 47.7406712 18.876 56.7718301 28.4145 59.9584121 29.6145 60.1797862 30.0525 59.4358488 30.0525 58.7973276 30.0525 58.2250681 30.0315 56.7100863 30.0195 54.6996482 23.343 56.1558981 21.9345 51.4693938 21.9345 51.4693938 20.844 48.6864054 19.2705 47.9454799 19.2705 47.9454799 17.091 46.4500754 19.4355 46.4801943 19.4355 46.4801943 21.843 46.6503662 23.1105 48.9634994 23.1105 48.9634994 25.2525 52.6455377 28.728 51.5823398 30.096 50.9649018 30.3135 49.4077535 30.9345 48.3460615 31.62 47.7436831 26.2905 47.1352808 20.688 45.0691228 20.688 35.8361671 20.688 33.2052792 21.6225 31.0547881 23.1585 29.3696344 22.911 28.7597262 22.0875 26.3110578 23.3925 22.9934585 23.3925 22.9934585 25.4085 22.3459017 29.9925 25.4632101 31.908 24.9285993 33.96 24.6620468 36.0015 24.6515052 38.04 24.6620468 40.0935 24.9285993 42.0105 25.4632101 46.5915 22.3459017 48.603 22.9934585 48.603 22.9934585 49.9125 26.3110578 49.089 28.7597262 48.8415 29.3696344 50.3805 31.0547881 51.309 33.2052792 51.309 35.8361671 51.309 45.0917119 45.6975 47.1292571 40.3515 47.7256117 41.2125 48.4695491 41.9805 49.9393525 41.9805 52.1877301 41.9805 55.4089489 41.9505 58.0067059 41.9505 58.7973276 41.9505 59.4418726 42.3825 60.1918338 43.6005 59.9554002 53.13 56.7627944 60 47.7376593 60 37.096644 60 23.7870921 49.254 13 35.9985 13" fill="#fff"/></g></g></g></svg></a><a class=symbol href=https://twitter.com/way2steve target=_blank><svg fill="#bbb" width="28" height="28" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="438.536" height="438.536" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536"><g><path d="M414.41 24.123C398.333 8.042 378.963.0 356.315.0H82.228C59.58.0 40.21 8.042 24.126 24.123 8.045 40.207.003 59.576.003 82.225v274.084c0 22.647 8.042 42.018 24.123 58.102 16.084 16.084 35.454 24.126 58.102 24.126h274.084c22.648.0 42.018-8.042 58.095-24.126 16.084-16.084 24.126-35.454 24.126-58.102V82.225C438.532 59.576 430.49 40.204 414.41 24.123zM335.471 168.735c.191 1.713.288 4.278.288 7.71.0 15.989-2.334 32.025-6.995 48.104-4.661 16.087-11.8 31.504-21.416 46.254-9.606 14.749-21.074 27.791-34.396 39.115-13.325 11.32-29.311 20.365-47.968 27.117-18.648 6.762-38.637 10.143-59.953 10.143-33.116.0-63.76-8.952-91.931-26.836 4.568.568 9.329.855 14.275.855 27.6.0 52.439-8.565 74.519-25.7-12.941-.185-24.506-4.179-34.688-11.991-10.185-7.803-17.273-17.699-21.271-29.691 4.947.76 8.658 1.137 11.132 1.137 4.187.0 9.042-.76 14.56-2.279-13.894-2.669-25.598-9.562-35.115-20.697-9.519-11.136-14.277-23.84-14.277-38.114v-.571c10.085 4.755 19.602 7.229 28.549 7.422-17.321-11.613-25.981-28.265-25.981-49.963.0-10.66 2.758-20.747 8.278-30.264 15.035 18.464 33.311 33.213 54.816 44.252 21.507 11.038 44.54 17.227 69.092 18.558-.95-3.616-1.427-8.186-1.427-13.704.0-16.562 5.853-30.692 17.56-42.399 11.703-11.706 25.837-17.561 42.394-17.561 17.515.0 32.079 6.283 43.688 18.846 13.134-2.474 25.892-7.33 38.26-14.56-4.757 14.652-13.613 25.788-26.55 33.402 12.368-1.716 23.88-4.95 34.537-9.708C357.458 149.793 347.462 160.166 335.471 168.735z"/></g></svg></a></div><p class=copyright>© Copyright
2021
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>Steve Sun</p><p class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-cactus-plus>nodejh</a></p></footer></body></html>