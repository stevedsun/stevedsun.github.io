<!doctype html><html lang=zh><head><meta charset=utf-8><title>电波障害</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta property="og:title" content="《Python源码剖析》第一部分——Python对象基础"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://sund.site/posts/2017/07/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86python%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"><meta itemprop=name content="《Python源码剖析》第一部分——Python对象基础"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="《Python源码剖析》第一部分——Python对象基础"><meta name=twitter:description content><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=favicon-32.png><link rel=stylesheet href=https://sund.site/scss/style.min.ae23adef903c07f0d9df75832e4082f1ee49b423c638835fa33420622f3a6863.css></head><body><header><div class="header header-frame"><div><h1 class=header__title>《Python源码剖析》第一部分——Python对象基础</h1></div><nav class=header-nav><ul class="header-nav-list header-nav-list--menu"><li class=header-nav-list__item><a class=header-nav-list__link href=/about/><span>About</span></a></li></ul><button class=header-nav-list__nav-btn>navigation</button></nav><button class=mb-header__menu-btn>
<span class=mb-header__menu-btn-line></span><span class=mb-header__menu-btn-line></span><span class=mb-header__menu-btn-line></span></button></div><nav id=mobile-header-nav class=mb-header-nav><button class="mb-header-nav__close-btn flex-center"><svg class="mb-header-nav__svg-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/><path d="M0 0h24v24H0z" fill="none"/></svg></button><div class=mb-header-nav__wrapper><div class=mb-header-nav__container><svg width="240" height="72" viewBox="0 0 240 72" class="mb-header-nav__title"><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">Tags</text></svg><ul class=mb-header-nav-list><li class=mb-header-nav-list__item><a class=mb-header-nav-list__link href=https://sund.site/tags/python/>python</a></li></ul></div><div class=mb-header-nav__container><svg width="240" height="72" viewBox="0 0 240 72" class="mb-header-nav__title"><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">Menu</text></svg><ul class=mb-header-nav-list><li class=mb-header-nav-list__item><a class=mb-header-nav-list__link href=/about/>About</a></li></ul></div></div></nav></header><div id=content><article class=post><div class=post-content><h2 id=python的对象初始化>Python的对象初始化</h2><blockquote><p>在Python中，对象就是为C中的结构体在堆上申请的一块内存，一般来说，对象是不能被静态初始化的，并且也不能在栈空间上生存。唯一的例外就是类型对象，Python中所有的内建的类型对象（如整数类型对象，字符串类型对象）都是被静态初始化的。</p></blockquote><p>python 的对象不像 C 是分配在栈、堆、data segment等位置，而是全部分配在堆上！只有python内置类型在初始化时候才是被C语言层静态初始化。</p><p>PyObject内部就两样：引用计数器、类型对象指针。</p><p>类型对象的定义：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#000;font-weight:700>typedef</span> <span style=color:#000;font-weight:700>struct</span> _typeobject {
    PyObject_VAR_HEAD
    <span style=color:#458;font-weight:700>char</span> <span style=color:#000;font-weight:700>*</span>tp_name; <span style=color:#998;font-style:italic>/* For printing, in format &#34;&lt;module&gt;.&lt;name&gt;&#34; */</span>
    <span style=color:#458;font-weight:700>int</span> tp_basicsize, tp_itemsize; <span style=color:#998;font-style:italic>/* For allocation */</span>

    <span style=color:#998;font-style:italic>/* Methods to implement standard operations */</span>
    destructor tp_dealloc;
    printfunc tp_print;
    <span style=color:#a61717;background-color:#e3d2d2>……</span>
    <span style=color:#998;font-style:italic>/* More standard operations (here for binary compatibility) */</span>
    hashfunc tp_hash;
    ternaryfunc tp_call;
    <span style=color:#a61717;background-color:#e3d2d2>……</span>
} PyTypeObject;
</code></pre></div><p><code>PyObject_VAR_HEAD</code>是可变类型的头信息，其中除了<code>PyObject_HEAD</code>的内容外，额外添加了一个代表该对象元素数量的整型。从上边代码可见，python的类型也是一个可变对象。</p><h2 id=python的多态>Python的多态</h2><p>Python中所有类型在初始化后，在C语言层面都使用同一种指针<code>PyObject *</code>，所以python实现多态就非常容易。任何函数的参数都是一个PyObject类型指针，也就不存在编译器需要判断函数参数类型。</p><h2 id=python对象内存池>Python对象内存池</h2><p>Python为了避免频繁的释放对象，采用了内存池的机制，在对象引用计数为0时，不会释放内存，而是将内存交还给内存池供python重新分配使用。<strong>每一种python类型，都有特定的内存池机制。</strong></p><h2 id=整数对象>整数对象</h2><p>-5至257之间的小整数，存储在「小整数数组」里，这个数组Python自动创建，每次创建一个小整数，就指向这个数组里对应的PyIntObject值并把PyIntObject的计数加1。(因此在-5到257之间的数实际指向同一片内存空间，整数-5和-5的内存地址肯定是一样的)</p><p>大整数则由一个叫<code>block_list</code>的链表管理，每次分配一个大整数就在<code>free_list</code>(一个指向空闲内存block的指针)里拿出一个节点并把<code>free_list</code>后移一个<code>block</code>。关于<code>free_list</code>是如何把尚未分配的内存和已被释放的内存链接起来的，可以参见书中113页的插图理解。</p><p>值得注意的是，python用于分配给整型的堆内存是不会自行销毁的，而是不断复用。也就是说，<strong>同一时间如果同时使用的整型太多，会消耗大量内存，并且这些内存在python关闭之前一直被python持有着。</strong></p><h2 id=字符串对象>字符串对象</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#000;font-weight:700>typedef</span> <span style=color:#000;font-weight:700>struct</span> {
    PyObject_VAR_HEAD
    <span style=color:#458;font-weight:700>long</span> ob_shash;
    <span style=color:#458;font-weight:700>int</span> ob_sstate;
    <span style=color:#458;font-weight:700>char</span> ob_sval[<span style=color:#099>1</span>];
} PyStringObject;
</code></pre></div><p>在Python源码中的注释显示，预存字符串的hash值(为了节省字符串比较的时间)和这里的intern机制将Python虚拟机的执行效率提升了20%。</p><p><strong>intern机制</strong> 将新建的字符串缓存在一个PyDictObject里，相同的字符串共用同一内存。</p><p>单一字符的字符串，除了用intern缓存外，还会缓存在系统自带的一个字符串缓冲池里：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#000;font-weight:700>static</span> PyStringObject <span style=color:#000;font-weight:700>*</span>characters[UCHAR_MAX <span style=color:#000;font-weight:700>+</span> <span style=color:#099>1</span>]; 
</code></pre></div><p><strong><code>+</code>操作符和<code>join</code>的效率问题</strong> <code>+</code>连接n个操作符会创建n-1次临时空间，<code>join</code>会直接处理一个list里的字符串，只分配一次内存。节省开销。</p><h2 id=列表对象>列表对象</h2><p>参见C++ vector对象的存储方式。</p><h2 id=字典对象>字典对象</h2><p>Python使用散列表(时间复杂度O(1))而非红黑树(时间复杂度O(logN))来存储map结构。</p><p>**Hash冲突(碰撞)**不同的值映射到相同的键时，就产生了冲突。一般解决办法有：</p><ul><li><p>开链法(哈希桶)：
<img src=https://i.loli.net/2021/03/05/bQuAwlOTUIXkJ7x.gif alt></p></li><li><p>开放定址法：
hash一次没有命中就再hash一次，直到找到为止……(二次探测)</p></li></ul><p>小于8个元素的Dict，python使用PyDIctObject内部的smalltable数组保存元素内容。</p><p>PyDictObject对String类型的key做了特殊对待——简化了计算hash函数的过程(正常情况下key值是一个<code>PyObject *</code>对象，需要做大量类型判断，但是对PyStringObject就省了)。</p><p>**装载率(使用的空间/预先分配的空间)**大于2/3时，hash冲突的概率会急速升高，这时python就会动态分配更多的空间。与其他类型一样，如果装载率太小，也会自动缩减分配的空间。</p><blockquote><p>在确定新的table的大小时，通常选用的策略是时新的table中entry的数量是现在table中Active态entry数量的4倍，选用4倍是为了使table中处于Active态的entry的分布更加稀疏，减少插入元素时的冲突概率……所以当table中Active态的entry数量非常大时，Python只会要求2倍的空间，这次又是以执行速度来交换内存空间。</p></blockquote><p>注意这段话，执行速度和内存大小是反比关系，划分的空间越大，执行一次查找就越费时，所以分配的内存空间不是越大越好。</p><p>PyDictObject也使用了同PyListObject一样的缓冲池方式。参考列表对象部分内容。</p><p><em><strong>笔者总结：从上面的各种类型的处理规律可以总结出Python遵循的原则：小变量缓存，大变量尽量整块分配内存，回收变量时不释放内存而是尽量复用，预分配的空间既要满足需要又不能太大(太大就缩减)</strong></em></p></div></article><button class=floating-button>
<a class=floating-button__link href=https://sund.site><span>home</span></a></button></div><footer class=post-footer><div class=footer><div>© 2021, Steve Sun</div><div class=footer__socials><a href=https://twitter.com/way2steve target=_blank class=social-link title="Twitter link" rel=noopener aria-label="follow on Twitter——Opens in a new window"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0 0v24h24V0H0zm18.862 9.237c.208 4.617-3.235 9.765-9.33 9.765-1.854.0-3.579-.543-5.032-1.475 1.742.205 3.48-.278 4.86-1.359-1.437-.027-2.649-.976-3.066-2.28.515.098 1.021.069 1.482-.056-1.579-.317-2.668-1.739-2.633-3.26.442.246.949.394 1.486.411-1.461-.977-1.875-2.907-1.016-4.383 1.619 1.986 4.038 3.293 6.766 3.43-.479-2.053 1.079-4.03 3.198-4.03.944.0 1.797.398 2.396 1.037.748-.147 1.451-.42 2.085-.796-.245.767-.766 1.41-1.443 1.816.664-.08 1.297-.256 1.885-.517-.44.656-.997 1.234-1.638 1.697z"/></svg></a><a href=https://github.com/stevedsun target=_blank class=social-link title="Github link" rel=noopener aria-label="follow on Github——Opens in a new window"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0 0v24h24V0H0zm14.534 19.59c-.406.078-.534-.171-.534-.384v-2.195c0-.747-.262-1.233-.55-1.481 1.782-.198 3.654-.875 3.654-3.947.0-.874-.311-1.588-.824-2.147.083-.202.357-1.016-.079-2.117.0.0-.671-.215-2.198.82-.639-.18-1.323-.267-2.003-.271-.68.003-1.364.091-2.003.269-1.528-1.035-2.2-.82-2.2-.82-.434 1.102-.16 1.915-.077 2.118-.512.56-.824 1.273-.824 2.147.0 3.064 1.867 3.751 3.645 3.954-.229.2-.436.552-.508 1.07-.457.204-1.614.557-2.328-.666.0.0-.423-.768-1.227-.825.0.0-.78-.01-.055.487.0.0.525.246.889 1.17.0.0.463 1.428 2.688.944v1.489c0 .211-.129.459-.528.385-3.18-1.057-5.472-4.056-5.472-7.59.0-4.419 3.582-8 8-8s8 3.581 8 8c0 3.533-2.289 6.531-5.466 7.59z"/></svg></a></div></div></footer><script src=https://sund.site/js/script.js></script></body></html>