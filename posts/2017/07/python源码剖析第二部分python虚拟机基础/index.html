<!doctype html><html lang=zh><head><meta charset=utf-8><title>电波障害</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta property="og:title" content="《Python源码剖析》第二部分——Python虚拟机基础"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://sund.site/posts/2017/07/python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86python%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9F%BA%E7%A1%80/"><meta itemprop=name content="《Python源码剖析》第二部分——Python虚拟机基础"><meta itemprop=description content><meta name=twitter:card content="summary"><meta name=twitter:title content="《Python源码剖析》第二部分——Python虚拟机基础"><meta name=twitter:description content><link rel=apple-touch-icon sizes=180x180 href=apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=favicon-32.png><link rel=stylesheet href=https://sund.site/scss/style.min.ae23adef903c07f0d9df75832e4082f1ee49b423c638835fa33420622f3a6863.css></head><body><header><div class="header header-frame"><div><h1 class=header__title>《Python源码剖析》第二部分——Python虚拟机基础</h1></div><nav class=header-nav><ul class="header-nav-list header-nav-list--menu"><li class=header-nav-list__item><a class=header-nav-list__link href=/about/><span>About</span></a></li></ul><button class=header-nav-list__nav-btn>navigation</button></nav><button class=mb-header__menu-btn>
<span class=mb-header__menu-btn-line></span><span class=mb-header__menu-btn-line></span><span class=mb-header__menu-btn-line></span></button></div><nav id=mobile-header-nav class=mb-header-nav><button class="mb-header-nav__close-btn flex-center"><svg class="mb-header-nav__svg-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="32" height="32"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/><path d="M0 0h24v24H0z" fill="none"/></svg></button><div class=mb-header-nav__wrapper><div class=mb-header-nav__container><svg width="240" height="72" viewBox="0 0 240 72" class="mb-header-nav__title"><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">Tags</text></svg><ul class=mb-header-nav-list><li class=mb-header-nav-list__item><a class=mb-header-nav-list__link href=https://sund.site/tags/python/>python</a></li></ul></div><div class=mb-header-nav__container><svg width="240" height="72" viewBox="0 0 240 72" class="mb-header-nav__title"><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">Menu</text></svg><ul class=mb-header-nav-list><li class=mb-header-nav-list__item><a class=mb-header-nav-list__link href=/about/>About</a></li></ul></div></div></nav></header><div id=content><article class=post><div class=post-content><h2 id=python执行环境>Python执行环境</h2><blockquote><p>在编译过程中，这些包含在Python源代码中的静态信息都会被Python编译器收集起来，编译的结果中包含了字符串，常量值，字节码等在源代码中出现的一切有用的静态信息。在Python运行期间，这些源文件中提供的静态信息最终会被存储在一个运行时的对象中，当Python运行结束后，这个运行时对象中所包含的信息甚至还会被存储在一种文件中。这个对象和文件就是我们这章探索的重点：PyCodeObject对象和pyc文件。</p></blockquote><blockquote><p>在程序运行期间，编译结果存在于内存的PyCodeObject对象中；而Python结束运行后，编译结果又被保存到了pyc文件中。当下一次运行相同的程序时，Python会根据pyc文件中记录的编译结果直接建立内存中的PyCodeObject对象，而不用再次对源文件进行编译了。</p></blockquote><p>从文章摘录可见，python生成的不是编译后的文件，而是<code>.py</code>文件对应的静态信息——PyCodeObject，这里包括了字节码指令序列、字符串、常量。每个名字空间(类、模块、函数)都对应一个独立的PyCodeObject。(python连编译后的文件里存的都是个对象！)</p><p>不被import的py文件不会生成pyc。标准库里有py_compile等方法也可以生成pyc。</p><p><strong>import机制</strong> 导入某个模块时，先查找对应的pyc，如果没有pyc就生成然后import这个pyc。(所以实际导入的并不是py文件，而是py文件编译后的PyCodeObject)。</p><p><strong>PyFrameObject</strong> Python程序运行时的「执行环境」。参考操作系统执行可执行文件的过程。Python也是将函数对应的执行环境封装成栈帧的形式加载进内存。</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#000;font-weight:700>typedef</span> <span style=color:#000;font-weight:700>struct</span> _frame {
    PyObject_VAR_HEAD
    <span style=color:#000;font-weight:700>struct</span> _frame <span style=color:#000;font-weight:700>*</span>f_back;  <span style=color:#998;font-style:italic>//执行环境链上的前一个frame
</span><span style=color:#998;font-style:italic></span>    PyCodeObject <span style=color:#000;font-weight:700>*</span>f_code;   <span style=color:#998;font-style:italic>//PyCodeObject对象
</span><span style=color:#998;font-style:italic></span>    PyObject <span style=color:#000;font-weight:700>*</span>f_builtins;   <span style=color:#998;font-style:italic>//builtin名字空间
</span><span style=color:#998;font-style:italic></span>    PyObject <span style=color:#000;font-weight:700>*</span>f_globals;    <span style=color:#998;font-style:italic>//global名字空间
</span><span style=color:#998;font-style:italic></span>    PyObject <span style=color:#000;font-weight:700>*</span>f_locals;     <span style=color:#998;font-style:italic>//local名字空间
</span><span style=color:#998;font-style:italic></span>    PyObject <span style=color:#000;font-weight:700>**</span>f_valuestack;    <span style=color:#998;font-style:italic>//运行时栈的栈底位置
</span><span style=color:#998;font-style:italic></span>    PyObject <span style=color:#000;font-weight:700>**</span>f_stacktop;      <span style=color:#998;font-style:italic>//运行时栈的栈顶位置
</span><span style=color:#998;font-style:italic></span>    <span style=color:#a61717;background-color:#e3d2d2>……</span>
    <span style=color:#458;font-weight:700>int</span> f_lasti;        <span style=color:#998;font-style:italic>//上一条字节码指令在f_code中的偏移位置
</span><span style=color:#998;font-style:italic></span>    <span style=color:#458;font-weight:700>int</span> f_lineno;       <span style=color:#998;font-style:italic>//当前字节码对应的源代码行
</span><span style=color:#998;font-style:italic></span>    <span style=color:#a61717;background-color:#e3d2d2>……</span>
    <span style=color:#998;font-style:italic>//动态内存，维护（局部变量+cell对象集合+free对象集合+运行时栈）所需要的空间
</span><span style=color:#998;font-style:italic></span>    PyObject <span style=color:#000;font-weight:700>*</span>f_localsplus[<span style=color:#099>1</span>];  
} PyFrameObject;
</code></pre></div><p>Python标准库的<code>sys._getframe()</code>可以动态的在程序执行时获取当前内存中活跃的PyFrameObject信息。</p><h2 id=legb-规则>LEGB 规则</h2><p>即python作用域的查找顺序是<code>local</code>-<code>enclosing</code>-<code>global</code>-<code>buildin</code>。看下面代码：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>a <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1</span>

<span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>g</span>():
  <span style=color:#000;font-weight:700>print</span> a

<span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>f</span>():
  <span style=color:#000;font-weight:700>print</span> a <span style=color:#000;font-weight:700>//</span>[<span style=color:#099>1</span>]
  a <span style=color:#000;font-weight:700>=</span> <span style=color:#099>2</span> <span style=color:#000;font-weight:700>//</span>[<span style=color:#099>2</span>]
  <span style=color:#000;font-weight:700>print</span> a

g()
</code></pre></div><p>代码在[1]处会抛出异常，原因是python在编译阶段就把静态数据(局部变量、全局变量、字节码)放入pyc里，执行到<code>f()</code>里时，查找到<code>a</code>是在local作用域里定义的而不是global里，但是此时local的a还没赋值，所以就会抛出异常。由此可见，<strong>python作用域信息是在静态编译时就处理好了的</strong>。</p><h2 id=python-虚拟机运行框架>Python 虚拟机运行框架</h2><blockquote><p>运行时环境是一个全局的概念，而执行环境实际就是一个栈帧，是一个与某个Code Block对应的概念。</p></blockquote><blockquote><p>在PyCodeObject对象的co_code域中保存着字节码指令和字节码指令的参数，Python虚拟机执行字节码指令序列的过程就是从头到尾遍历整个co_code、依次执行字节码指令的过程。</p></blockquote><p>由上文引用可见，python在编译阶段将代码块的字节码保存在PyCodeObject的co_code属性里，然后在执行阶段从头到尾遍历这个co_code属性解读字节码。</p><p><strong>Python运行时环境</strong> Python在运行时用PyInterpreterState结构维护进程运行环境，PyThreadState维护线程运行环境，PyFrameObject维护栈帧运行环境，三者是依次包含关系，如下图所示：</p><p><img src=https://i.loli.net/2021/03/05/GHImB214fvxSXgk.png alt></p><p>Python虚拟机就是一个「软CPU」，动态加载上述三种结构进内存，并模拟操作系统执行过程。程序执行后，先创建各个运行时环境，再将栈帧中的字节码载入，循环遍历解释执行。</p><h2 id=python字节码>Python字节码</h2><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>i <span style=color:#000;font-weight:700>=</span> <span style=color:#099>1</span>
<span style=color:#099>0</span>   LOAD_CONST   <span style=color:#099>0</span>  (<span style=color:#099>1</span>)
<span style=color:#099>3</span>   STORE_NAME   <span style=color:#099>0</span>  (i)
</code></pre></div><p>例如python的一条语句<code>i=1</code>可以解释为下面两行字节码，最左边的第1列数字代表这行字节码在内存中的偏移位置，第2列是字节码的名字(CPU并不关心名字，它只是根据偏移量读出字节码，所以这个名字是方便阅读用的)，第3列是字节码的参数，如<code>LOAD_CONST</code>对应的数据在变量<code>f->f_code->co_consts</code>里，0就是这个参数位于<code>f->f_code->co_consts</code>的偏移量。最后一列的括号里是从参数里取到的value。</p><h2 id=python-的异常抛出机制>Python 的异常抛出机制</h2><p>异常处理的操作都在<code>Python/traceback.c</code>文件里，python每次调用一层函数，就创建改函数对应的PyFrameObject对象来保存函数运行时信息，PythonFrameObject里调用PyEval_EvalFrameEx循环解释字节码，如果抛出异常就创建PyTraceBackObject对象，将对象交给上一层PyFrameObject里的PyTracebackObject组成链表，最后返回最上层PyRun_SimpleFileExFlags函数，该函数调用PyErr_Print遍历PyTraceBackObject链表打印出异常信息。</p><p><img src=https://i.loli.net/2021/03/05/9bEUBjYov8mZy3s.jpg alt></p><h2 id=函数对象的实现>函数对象的实现</h2><p>PyFunctionObject是函数对象。在python调用函数时，生成PyFunctionObject对象，该对象的f_global指针用来将外层的全局变量传递给函数内部，然后在<code>ceval.c</code>文件的<code>fast_function</code>里解出PyFunctionObject对象里携带的信息，创建新的PyFrameObject对象(上文说过这个对象是维护运行时环境的)，最后调用执行字节码的函数<code>PyEval_EvalFrameEx</code>执行真正函数字节码。</p><p><strong>Python执行一段代码需要什么？</strong> 从书中描述可见，python执行一段代码需要做几件事：</p><ul><li>从源码编译出 PyCodeObject 保存变量和字节码</li><li>执行阶段，从PyCodeObject里取出信息交给 PyFrameObject，执行 PyEval_EvalFrameEx 解释字节码</li><li>如果遇到函数调用，就把函数对应的代码段从 PyCodeObject 存入 PyFunctionObject 对象，然后把这个函数对象通过参数传给新创建的 PyFrameObject ，在内层空间执行 PyEval_EvalFrameEx 解释字节码</li><li>将结果或异常存入 PyFrameObject 的变量( 异常是存入f_blockstack里，外层判断f_blockstack里的数据是被except捕获还是没有捕获而继续下一步操作) 抛给外层</li></ul><p>值得注意的是，<strong>python在执行阶段，将对函数参数的键值查找，转换为索引查找</strong>，即在转换PyCodeObject为PyFrameObject时，将参数信息按位置参数、键参数按照一定顺序存储在f_localsplus变量中，再用索引来查找对应参数，而需要查找键值。这样提高了运行时效率。下图是<code>foo('Rboert', age=5)</code>在内存中的存储形式。</p><p><img src=https://i.loli.net/2021/03/05/IGy8JTzZpgmN6sL.jpg alt></p><h2 id=闭包的实现>闭包的实现</h2><p>Python在编译阶段就把函数闭包内层和闭包外层使用的变量存入PyCodeObject中：</p><ul><li>co_cellvars：通常是一个tuple，保存嵌套的作用域中使用的变量名集合；</li><li>co_freevars：通常也是一个tuple，保存使用了的外层作用域中的变量名集合。</li></ul><p>在执行阶段，PyFrameObject的f_localsplus中也为闭包的变量划分的内存区域，如下图所示：</p><p><img src=https://i.loli.net/2021/03/05/fUB4wC36dAc7rqt.jpg alt></p><h2 id=元类>元类</h2><p>元类<code>&lt;type type></code>和其他类的关系如下图：</p><p><img src=https://i.loli.net/2021/03/05/N76woqSlmR28Oyt.jpg alt></p><p><strong>可调用性（callable）</strong> ，只要一个对象对应的class对象中实现了“<strong>call</strong>”操作（更确切地说，在Python内部的PyTypeObject中，tp_call不为空）那么这个对象就是一个可调用的对象，换句话说，在Python中，所谓“调用”，就是执行对象的type所对应的class对象的tp_call操作。</p><h2 id=descriptor>Descriptor</h2><blockquote><p>在PyType_Ready中，Python虚拟机会填充tp_dict，其中与操作名对应的是一个个descriptor
对于一个Python中的对象obj，如果obj.__ class__对应的class对象中存在__get__、__set__和__delete__三种操作，那么obj就可称为Python一个descriptor。</p></blockquote><blockquote><p>如果细分，那么descriptor还可分为如下两种：</p></blockquote><ol><li>data descriptor : type中定义了__get__和__set__的descriptor；</li><li>non data descriptor : type中只定义了__get__的descriptor。
在Python虚拟机访问instance对象的属性时，descriptor的一个作用是影响Python虚拟机对属性的选择。从PyObject_GenericGetAttr的伪代码可以看出，Python虚拟机会在instance对象自身的__dict__中寻找属性，也会在instance对象对应的class对象的mro列表中寻找</li></ol><blockquote><ol><li>Python虚拟机按照instance属性、class属性的顺序选择属性，即instance属性优先于class属性；</li><li>如果在class属性中发现同名的data descriptor，那么该descriptor会优先于instance属性被Python虚拟机选择</li></ol></blockquote><p><img src=https://i.loli.net/2021/03/05/1xKk3IVPdjWb8iB.jpg alt></p><h3 id=引申python-黑魔法-descriptor-描述器>引申：Python 黑魔法 Descriptor (描述器)</h3><ul><li><a href=http://www.jianshu.com/p/250f0d305c35>http://www.jianshu.com/p/250f0d305c35</a></li><li><a href=http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html>http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html</a></li></ul><h2 id=bound-method和unbound-method>Bound Method和Unbound Method</h2><p>假设有下面两种对类方法的调用：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#000;font-weight:700>class</span> <span style=color:#458;font-weight:700>A</span>(<span style=color:#0086b3>object</span>):
    <span style=color:#000;font-weight:700>def</span> <span style=color:#900;font-weight:700>f</span>(<span style=color:#999>self</span>):
        <span style=color:#000;font-weight:700>pass</span>

a <span style=color:#000;font-weight:700>=</span> A()
<span style=color:#998;font-style:italic># [1]</span>
a<span style=color:#000;font-weight:700>.</span>f()  

<span style=color:#998;font-style:italic># [2]</span>
A<span style=color:#000;font-weight:700>.</span>f(a)

<span style=color:#998;font-style:italic># [3]</span>
func <span style=color:#000;font-weight:700>=</span> a<span style=color:#000;font-weight:700>.</span>f
func()
</code></pre></div><p>在代码[1]里，实例a调用类方法f，python底层会自动完成实例a和类方法f之间的绑定动作(调用<code>func_ descr_get(A.f, a, A)</code>，将实例地址和函数对象PyFunctionObject封装到一个PyMethodObject)，而代码[2]里直接通过A调用，则f为非绑定的PyMethodObject，里面没有实例信息，需要传入a。</p><p>比较绑定方法与非绑定方法可知，通过[1]的方式每次都要绑定一次实例，开销非常大，下图比较的是[1]和[3]两种方式，绑定操作的执行次数。</p><p><img src=https://i.loli.net/2021/03/05/TpCcdaYmHlQnXzE.jpg alt></p><p>结论： <strong>调用类实例绑定的方法时，如果方法执行次数非常多，最好将方法赋值给一个变量，防止重复绑定增加开销</strong></p></div></article><button class=floating-button>
<a class=floating-button__link href=https://sund.site><span>home</span></a></button></div><footer class=post-footer><div class=footer><div>© 2021, Steve Sun</div><div class=footer__socials><a href=https://twitter.com/way2steve target=_blank class=social-link title="Twitter link" rel=noopener aria-label="follow on Twitter——Opens in a new window"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0 0v24h24V0H0zm18.862 9.237c.208 4.617-3.235 9.765-9.33 9.765-1.854.0-3.579-.543-5.032-1.475 1.742.205 3.48-.278 4.86-1.359-1.437-.027-2.649-.976-3.066-2.28.515.098 1.021.069 1.482-.056-1.579-.317-2.668-1.739-2.633-3.26.442.246.949.394 1.486.411-1.461-.977-1.875-2.907-1.016-4.383 1.619 1.986 4.038 3.293 6.766 3.43-.479-2.053 1.079-4.03 3.198-4.03.944.0 1.797.398 2.396 1.037.748-.147 1.451-.42 2.085-.796-.245.767-.766 1.41-1.443 1.816.664-.08 1.297-.256 1.885-.517-.44.656-.997 1.234-1.638 1.697z"/></svg></a><a href=https://github.com/stevedsun target=_blank class=social-link title="Github link" rel=noopener aria-label="follow on Github——Opens in a new window"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path d="M0 0v24h24V0H0zm14.534 19.59c-.406.078-.534-.171-.534-.384v-2.195c0-.747-.262-1.233-.55-1.481 1.782-.198 3.654-.875 3.654-3.947.0-.874-.311-1.588-.824-2.147.083-.202.357-1.016-.079-2.117.0.0-.671-.215-2.198.82-.639-.18-1.323-.267-2.003-.271-.68.003-1.364.091-2.003.269-1.528-1.035-2.2-.82-2.2-.82-.434 1.102-.16 1.915-.077 2.118-.512.56-.824 1.273-.824 2.147.0 3.064 1.867 3.751 3.645 3.954-.229.2-.436.552-.508 1.07-.457.204-1.614.557-2.328-.666.0.0-.423-.768-1.227-.825.0.0-.78-.01-.055.487.0.0.525.246.889 1.17.0.0.463 1.428 2.688.944v1.489c0 .211-.129.459-.528.385-3.18-1.057-5.472-4.056-5.472-7.59.0-4.419 3.582-8 8-8s8 3.581 8 8c0 3.533-2.289 6.531-5.466 7.59z"/></svg></a></div></div></footer><script src=https://sund.site/js/script.js></script></body></html>