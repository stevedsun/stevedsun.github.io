<!doctype html><html class="not-ready lg:text-base" style=--bg:#faf8f1 lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Go 内存泄漏常见模式 -</title><meta name=theme-color><meta name=description content="最近在工作中排查 Go 语言内存泄漏问题时，发现这篇 Uber 写的博客，其中分享了几种常见的 goroutine 内存泄漏模式，于是把整理了 goroutine 的相关问题，希望更多人搜索到到这篇文章，帮助大家快速定位内存泄漏问题。
Goroutine 内存泄漏的原因 Go 语言的内存泄漏通常因为错误地使用 goroutine 和 channel。例如以下几种情况：
在 goroutine 里打开一个连接（如 gRPC）但是忘记 close 在 goroutine 里的全局变量对象没有释放 在 goroutine 里读 channel， 但是没有写入端，而被阻塞 在 goroutine 里写入无缓冲的 channel，但是由于 channel 的读端被其他协程关闭而阻塞 在 goroutine 里写入有缓冲的 channel，但是 channel 缓冲已满 这几种情况，通常掺杂在复杂的代码里逻辑里，很难调试发现问题。因此衍生出以下几种日常工作中最容易出现问题的模式。
常见 Goroutine 内存泄漏模式 Premature Function Return /功能过早返回 一个 goroutine 要写入 channel，但是在另一个端意外退出导致 channel 读取的代码没有执行。
func Example() { a := 1 c := make(chan error) go func() { c <- err return }() // do something if a > 0 { return } // do something err := <-c } 代码中主进程在if a > 0 处 return，导致 channel 无法写入而被阻塞。"><meta name=author content="Steve Sun"><link rel="preload stylesheet" as=style href=/main.min.css><link rel=preload as=image href=theme.png><link rel=preload as=image href="https://www.gravatar.com/avatar/d651fa5e2ad1b1ae769664b91a4b0eb2?s=160&amp;d=identicon"><link rel=preload as=image href=twitter.svg><link rel=preload as=image href=github.svg><link rel=preload as=image href=instagram.svg><link rel=preload as=image href=rss.svg><script defer src=highlight.min.js onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=favicon.ico><link rel=apple-touch-icon href=apple-touch-icon.png><meta name=generator content="Hugo 0.119.0"><script async src="https://www.googletagmanager.com/gtag/js?id=G-XJJVVQ0LBH"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XJJVVQ0LBH",{anonymize_ip:!1})}</script><meta itemprop=name content="Go 内存泄漏常见模式"><meta itemprop=description content="最近在工作中排查 Go 语言内存泄漏问题时，发现这篇 Uber 写的博客，其中分享了几种常见的 goroutine 内存泄漏模式，于是把整理了 goroutine 的相关问题，希望更多人搜索到到这篇文章，帮助大家快速定位内存泄漏问题。
Goroutine 内存泄漏的原因 Go 语言的内存泄漏通常因为错误地使用 goroutine 和 channel。例如以下几种情况：
在 goroutine 里打开一个连接（如 gRPC）但是忘记 close 在 goroutine 里的全局变量对象没有释放 在 goroutine 里读 channel， 但是没有写入端，而被阻塞 在 goroutine 里写入无缓冲的 channel，但是由于 channel 的读端被其他协程关闭而阻塞 在 goroutine 里写入有缓冲的 channel，但是 channel 缓冲已满 这几种情况，通常掺杂在复杂的代码里逻辑里，很难调试发现问题。因此衍生出以下几种日常工作中最容易出现问题的模式。
常见 Goroutine 内存泄漏模式 Premature Function Return /功能过早返回 一个 goroutine 要写入 channel，但是在另一个端意外退出导致 channel 读取的代码没有执行。
func Example() { a := 1 c := make(chan error) go func() { c <- err return }() // do something if a > 0 { return } // do something err := <-c } 代码中主进程在if a > 0 处 return，导致 channel 无法写入而被阻塞。"><meta itemprop=datePublished content="2023-06-27T14:46:59+08:00"><meta itemprop=dateModified content="2023-06-27T14:46:59+08:00"><meta itemprop=wordCount content="309"><meta itemprop=keywords content="go,memory leak,"><meta property="og:title" content="Go 内存泄漏常见模式"><meta property="og:description" content="最近在工作中排查 Go 语言内存泄漏问题时，发现这篇 Uber 写的博客，其中分享了几种常见的 goroutine 内存泄漏模式，于是把整理了 goroutine 的相关问题，希望更多人搜索到到这篇文章，帮助大家快速定位内存泄漏问题。
Goroutine 内存泄漏的原因 Go 语言的内存泄漏通常因为错误地使用 goroutine 和 channel。例如以下几种情况：
在 goroutine 里打开一个连接（如 gRPC）但是忘记 close 在 goroutine 里的全局变量对象没有释放 在 goroutine 里读 channel， 但是没有写入端，而被阻塞 在 goroutine 里写入无缓冲的 channel，但是由于 channel 的读端被其他协程关闭而阻塞 在 goroutine 里写入有缓冲的 channel，但是 channel 缓冲已满 这几种情况，通常掺杂在复杂的代码里逻辑里，很难调试发现问题。因此衍生出以下几种日常工作中最容易出现问题的模式。
常见 Goroutine 内存泄漏模式 Premature Function Return /功能过早返回 一个 goroutine 要写入 channel，但是在另一个端意外退出导致 channel 读取的代码没有执行。
func Example() { a := 1 c := make(chan error) go func() { c <- err return }() // do something if a > 0 { return } // do something err := <-c } 代码中主进程在if a > 0 处 return，导致 channel 无法写入而被阻塞。"><meta property="og:type" content="article"><meta property="og:url" content="/posts/2023/goroutine-leak/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-27T14:46:59+08:00"><meta property="article:modified_time" content="2023-06-27T14:46:59+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go 内存泄漏常见模式"><meta name=twitter:description content="最近在工作中排查 Go 语言内存泄漏问题时，发现这篇 Uber 写的博客，其中分享了几种常见的 goroutine 内存泄漏模式，于是把整理了 goroutine 的相关问题，希望更多人搜索到到这篇文章，帮助大家快速定位内存泄漏问题。
Goroutine 内存泄漏的原因 Go 语言的内存泄漏通常因为错误地使用 goroutine 和 channel。例如以下几种情况：
在 goroutine 里打开一个连接（如 gRPC）但是忘记 close 在 goroutine 里的全局变量对象没有释放 在 goroutine 里读 channel， 但是没有写入端，而被阻塞 在 goroutine 里写入无缓冲的 channel，但是由于 channel 的读端被其他协程关闭而阻塞 在 goroutine 里写入有缓冲的 channel，但是 channel 缓冲已满 这几种情况，通常掺杂在复杂的代码里逻辑里，很难调试发现问题。因此衍生出以下几种日常工作中最容易出现问题的模式。
常见 Goroutine 内存泄漏模式 Premature Function Return /功能过早返回 一个 goroutine 要写入 channel，但是在另一个端意外退出导致 channel 读取的代码没有执行。
func Example() { a := 1 c := make(chan error) go func() { c <- err return }() // do something if a > 0 { return } // do something err := <-c } 代码中主进程在if a > 0 处 return，导致 channel 无法写入而被阻塞。"><link rel=canonical href=/posts/2023/goroutine-leak/></head><body class="text-black duration-200 ease-out dark:text-white"><header class="mx-auto flex h-[4.5rem] max-w-3xl px-8 lg:justify-center"><div class="relative z-50 mr-auto flex items-center"><a class="-translate-x-[1px] -translate-y-[1px] text-2xl font-semibold" href></a><div class="btn-dark text-[0] ml-4 h-6 w-6 shrink-0 cursor-pointer [background:url(./theme.png)_left_center/_auto_theme('spacing.6')_no-repeat] [transition:_background-position_0.4s_steps(5)] dark:[background-position:right]" role=button aria-label=Dark></div></div><div class="btn-menu relative z-50 -mr-8 flex h-[4.5rem] w-[5rem] shrink-0 cursor-pointer flex-col items-center justify-center gap-2.5 lg:hidden" role=button aria-label=Menu></div><script>const htmlClass=document.documentElement.classList;setTimeout(()=>{htmlClass.remove("not-ready")},10);const btnMenu=document.querySelector(".btn-menu");btnMenu.addEventListener("click",()=>{htmlClass.toggle("open")});const metaTheme=document.querySelector('meta[name="theme-color"]'),lightBg="#faf8f1".replace(/"/g,""),setDark=e=>{metaTheme.setAttribute("content",e?"#000":lightBg),htmlClass[e?"add":"remove"]("dark"),localStorage.setItem("dark",e)},darkScheme=window.matchMedia("(prefers-color-scheme: dark)");if(htmlClass.contains("dark"))setDark(!0);else{const e=localStorage.getItem("dark");setDark(e?e==="true":darkScheme.matches)}darkScheme.addEventListener("change",e=>{setDark(e.matches)});const btnDark=document.querySelector(".btn-dark");btnDark.addEventListener("click",()=>{setDark(localStorage.getItem("dark")!=="true")})</script><div class="nav-wrapper fixed inset-x-0 top-full z-40 flex h-full select-none flex-col justify-center pb-16 duration-200 dark:bg-black lg:static lg:h-auto lg:flex-row lg:!bg-transparent lg:pb-0 lg:transition-none"><nav class="lg:ml-12 lg:flex lg:flex-row lg:items-center lg:space-x-6"><a class="block text-center text-2xl leading-[5rem] lg:text-base lg:font-normal" href=/about/>About</a></nav><nav class="mt-12 flex justify-center space-x-10 dark:invert lg:ml-12 lg:mt-0 lg:items-center lg:space-x-6"><a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./twitter.svg) href=https://twitter.com/way2steve target=_blank rel=me>twitter</a>
<a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./github.svg) href=https://github.com/stevedsun target=_blank rel=me>github</a>
<a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./instagram.svg) href=https://instagram.com/stevedsun target=_blank rel=me>instagram</a>
<a class="h-8 w-8 text-[0] [background:var(--url)_center_center/cover_no-repeat] lg:h-6 lg:w-6" style=--url:url(./rss.svg) href=index.xml target=_blank rel=alternate>rss</a></nav></div></header><main class="prose prose-neutral relative mx-auto min-h-[calc(100%-9rem)] max-w-3xl px-8 pb-16 pt-12 dark:prose-invert"><article><header class=mb-16><h1 class="!my-0 pb-2.5">Go 内存泄漏常见模式</h1><div class="text-sm antialiased opacity-60"><time>Jun 27, 2023</time></div></header><section><p>最近在工作中排查 Go 语言内存泄漏问题时，发现<a href=https://www.uber.com/blog/leakprof-featherlight-in-production-goroutine-leak-detection/>这篇 Uber 写的博客</a>，其中分享了几种常见的 goroutine 内存泄漏模式，于是把整理了 goroutine 的相关问题，希望更多人搜索到到这篇文章，帮助大家快速定位内存泄漏问题。</p><h2 id=goroutine-内存泄漏的原因>Goroutine 内存泄漏的原因</h2><p>Go 语言的内存泄漏通常因为错误地使用 goroutine 和 channel。例如以下几种情况：</p><ol><li>在 goroutine 里打开一个连接（如 gRPC）但是忘记 close</li><li>在 goroutine 里的全局变量对象没有释放</li><li>在 goroutine 里读 channel， 但是没有写入端，而被阻塞</li><li>在 goroutine 里写入无缓冲的 channel，但是由于 channel 的读端被其他协程关闭而阻塞</li><li>在 goroutine 里写入有缓冲的 channel，但是 channel 缓冲已满</li></ol><p>这几种情况，通常掺杂在复杂的代码里逻辑里，很难调试发现问题。因此衍生出以下几种日常工作中<strong>最容易出现问题的模式</strong>。</p><h2 id=常见-goroutine-内存泄漏模式>常见 Goroutine 内存泄漏模式</h2><h3 id=premature-function-return-功能过早返回>Premature Function Return /功能过早返回</h3><p>一个 goroutine 要写入 channel，但是在另一个端意外退出导致 channel 读取的代码没有执行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Example</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do something
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>a</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do something
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>代码中主进程在<code>if a > 0</code> 处 return，导致 channel 无法写入而被阻塞。</p><p>解决这种问题的一个思路是把无缓冲 channel 转化为缓冲大小为 1 的 channel。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>error</span>, <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>有缓冲 channel 即使没有读取操作，也不会阻塞。</p><h3 id=the-timeout-leak-超时泄漏>The Timeout Leak /超时泄漏</h3><p>这是我们工作中遇到的问题，经常需要执行一个可能超时的异步操作时被使用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Example</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>timeoutOption</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>SomeTimeoutOption</span>()
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>done</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>any</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>done</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>result</span>
</span></span><span style=display:flex><span>    }()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>done</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>timeoutOption</span>.<span style=color:#a6e22e>Timeout</span>():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这段代码里，一旦 timeoutOption 操作超时，就会通知 select，接着程序退出，于是 goroutine 写入 done 的操作被阻塞而无法退出。</p><p>解决思路同上一个模式，用有缓冲 channel 替代无缓冲 channel。</p><h3 id=the-ncast-leak-多端读写泄漏>The NCast Leak /多端读写泄漏</h3><p>如果 channel 的读端只有一个，但是写端有多个，就会发生这种情况。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Example</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>any</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>items</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>c</span> <span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>any</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>result</span>
</span></span><span style=display:flex><span>        }(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种情况也适用于“多个写端一个读端”的情况，解决方法是把 channel 设置成和写或读数量一致的缓冲数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>any</span>, len(<span style=color:#a6e22e>items</span>))
</span></span></code></pre></div><h3 id=channel-iteration-misuse-通道迭代误用>Channel Iteration Misuse /通道迭代误用</h3><p>Go 支持一种特性 <a href=https://gobyexample.com/range-over-channels>&ldquo;Range over channels&rdquo;</a>, 可以用 range 来循环读取 channel 的内容。</p><p>但是一旦读取不到内容，range 就会等待 channel 的写入，而 range 如果正好在 goroutine 内部，这个 goroutine 就会被阻塞。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Example</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>any</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>items</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>data</span>
</span></span><span style=display:flex><span>        }()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>data</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>c</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Done</span>()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>wg</span>.<span style=color:#a6e22e>Wait</span>()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>解决这个问题的方式手动定义关闭 channel。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>wg</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>sync</span>.<span style=color:#a6e22e>WaitGroup</span>{}
</span></span><span style=display:flex><span><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#a6e22e>any</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> close(<span style=color:#a6e22e>c</span>)
</span></span><span style=display:flex><span><span style=color:#75715e>//...
</span></span></span></code></pre></div><p>这样在 WaitGroup 全部结束后，主程序会关闭 channel，从而让异步的 goroutine 内部的 range 退出循环等待。</p><h2 id=小结>小结</h2><p>Goroutine 内存泄漏是 Go 语言最容易发生的内存泄漏情况，它通常伴随着错误地使用 goroutine 和 channel。而 channel 的特殊用法如 select 和 range 又让 channel 阻塞变得更加隐蔽不易发现，进而增加排查内存泄漏的难度。</p><p>在写 goroutine 和调试内存泄漏问题时，要重点关注 channel 相关的操作，尤其涉及到文中列举的四类模式：功能过早返回、超时泄漏、多端读写泄漏、通道迭代误用。</p></section><script type=text/javascript src=https://cdnjs.buymeacoffee.com/1.0.0/button.prod.min.js data-name=bmc-button data-slug=stevedsun data-color=#FFDD00 data-emoji data-font=Cookie data-text="Buy me a coffee" data-outline-color=#000000 data-font-color=#000000 data-coffee-color=#ffffff></script><footer class="mt-12 flex flex-wrap"><a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=tags/go>go</a>
<a class="mb-1.5 mr-1.5 rounded-lg bg-black/[3%] px-5 py-1.5 no-underline dark:bg-white/[8%]" href=tags/memory-leak>memory leak</a></footer><nav class="mt-24 flex rounded-lg bg-black/[3%] text-lg dark:bg-white/[8%]"><a class="flex w-1/2 items-center rounded-l-md p-6 pr-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=/posts/2023/go-server-side-events/><span class=mr-1.5>←</span><span>Go Server Side Events</span></a>
<a class="ml-auto flex w-1/2 items-center justify-end rounded-r-md p-6 pl-3 font-semibold no-underline hover:bg-black/[2%] dark:hover:bg-white/[3%]" href=/posts/2023/kong-gateway/><span>Kong网关极简入门</span><span class=ml-1.5>→</span></a></nav><div class=mt-24 id=graphcomment></div><script type=text/javascript>var __semio__params={graphcommentId:"steve-sun",behaviour:{}};function __semio__onload(){__semio__gc_graphlogin(__semio__params)}(function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.onload=__semio__onload,e.defer=!0,e.src="https://integration.graphcomment.com/gc_graphlogin.js?"+Date.now(),(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)})()</script></article></main><footer class="opaco mx-auto flex h-[4.5rem] max-w-3xl items-center px-8 text-[0.9em] opacity-60"><div class=mr-auto>&copy; 2024
<a class=link href></a></div><a class="link mx-6" href=https://gohugo.io/ rel=noopener target=_blank>Powered by Hugo️️</a>️
<a class=link href=https://github.com/nanxiaobei/hugo-paper rel=noopener target=_blank>✎ Paper</a></footer></body></html>