<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fluentbit on Steve Sun</title><link>https://sund.site/tags/fluentbit/</link><description>Recent content in Fluentbit on Steve Sun</description><generator>Hugo</generator><language>zh-CN</language><copyright>Copyright Â© 2013-2025, Steve Sun.</copyright><lastBuildDate>Thu, 24 Nov 2022 12:26:23 +0800</lastBuildDate><follow_challenge><feedId>41397727810093074</feedId><userId>56666701051455488</userId></follow_challenge><atom:link href="https://sund.site/tags/fluentbit/index.xml" rel="self" type="application/rss+xml"/><item><title>Implementing a Prometheus Exporter for Fluent-bit</title><link>https://sund.site/posts/2022/implementing-prometheus-exporter-for-fluentbit/</link><pubDate>Thu, 24 Nov 2022 12:26:23 +0800</pubDate><guid>https://sund.site/posts/2022/implementing-prometheus-exporter-for-fluentbit/</guid><description>&lt;h2 id="background">Background&lt;/h2>
&lt;p>Fluent-bit is a great tool for logging and monitoring, many teams are using it to collect metrics and logs. Prometheus is also a popular tool for metrics analysis, but if you want to output Fluent-bit data to Prometheus, the only way is to use the node-exporter input plugin, which has fixed metrics and data format.&lt;/p>
&lt;p>In our case, we want to export specific input data into Prometheus, therefore we have to implement our Prometheus exporter in a customized Fluent-bit output plugin.&lt;/p>
&lt;p>Today I want to share the final solution for this case. The complete demo code can be found on this Github repo: &lt;a href="https://github.com/stevedsun/fluent-bit-output-prometheus-demo">https://github.com/stevedsun/fluent-bit-output-prometheus-demo&lt;/a>&lt;/p>
&lt;h2 id="fluent-bit-output-plugin">Fluent-bit Output Plugin&lt;/h2>
&lt;p>Fluent-bit provides a way to implement your Golang plugin. (See &lt;a href="https://docs.fluentbit.io/manual/v/1.9-pre/development/golang-output-plugins">Fluent-bit Go Output Plugin&lt;/a>)&lt;/p>
&lt;p>We can run an asynchronous HTTP server as the Prometheus exporter when Fluent-bit plugin initializing, and transform the Fluent-bit records to Prometheus metrics format when Fluent-bit flushes a record to the output plugin.&lt;/p>
&lt;p>To implement a Fluent-bit output plugin, there are four call-back functions we need to overwrite.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">//export FLBPluginRegister
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">FLBPluginRegister&lt;/span>(def unsafe.Pointer) &lt;span style="color:#fc5fa3">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// Here we define the plugin name and description.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	&lt;span style="color:#fc5fa3">return&lt;/span> output.&lt;span style="color:#41a1c0">FLBPluginRegister&lt;/span>(def, &lt;span style="color:#fc6a5d">&amp;#34;promexporter&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;Prometheus Exporter&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">//export FLBPluginInit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">FLBPluginInit&lt;/span>(plugin unsafe.Pointer) &lt;span style="color:#fc5fa3">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// We can extract output plugin parameters from `FLBPlguinConfigKey`.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	user := output.&lt;span style="color:#41a1c0">FLBPluginConfigKey&lt;/span>(plugin, &lt;span style="color:#fc6a5d">&amp;#34;username&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	passwd := output.&lt;span style="color:#41a1c0">FLBPluginConfigKey&lt;/span>(plugin, &lt;span style="color:#fc6a5d">&amp;#34;password&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// Here we can run a new Prometheus exporter server.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	&lt;span style="color:#41a1c0">NewExporter&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">return&lt;/span> output.FLB_OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">//export FLBPluginFlushCtx
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">FLBPluginFlushCtx&lt;/span>(ctx, data unsafe.Pointer, length C.&lt;span style="color:#fc5fa3">int&lt;/span>, tag *C.char) &lt;span style="color:#fc5fa3">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// Here we process every record, extract it and ship to exporter
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	dec := output.&lt;span style="color:#41a1c0">NewDecoder&lt;/span>(data, &lt;span style="color:#d0a8ff">int&lt;/span>(length))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#6c7986">// Extract Record
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>		ret, _, record := output.&lt;span style="color:#41a1c0">GetRecord&lt;/span>(dec)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">if&lt;/span> ret != &lt;span style="color:#d0bf69">0&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">for&lt;/span> k, v := &lt;span style="color:#fc5fa3">range&lt;/span> record {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#6c7986">// You have to extract record here, ship them to exporter.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">return&lt;/span> output.FLB_OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">//export FLBPluginExit
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">FLBPluginExit&lt;/span>() &lt;span style="color:#fc5fa3">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">if&lt;/span> err := server.srv.&lt;span style="color:#41a1c0">Shutdown&lt;/span>(context.&lt;span style="color:#41a1c0">TODO&lt;/span>()); err != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#d0a8ff">panic&lt;/span>(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// Here we have to close go channel and daemon exporter server.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	&lt;span style="color:#d0a8ff">close&lt;/span>(collector.buff)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	server.wg.&lt;span style="color:#41a1c0">Wait&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">return&lt;/span> output.FLB_OK
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>Note&lt;/strong>! You should not remove the comment lines above the function, they are important for building .so files.&lt;/p>
&lt;pre>&lt;code> //export FLBPluginExit
&lt;/code>&lt;/pre>
&lt;h2 id="the-exporter-http-server">The Exporter HTTP Server&lt;/h2>
&lt;p>The next step is to implement the HTTP server and make it run on a daemon.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// Here we start a background server on port 8989, the server will handle `/metrics` path, prometheus exporter will implement the handler.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">startHttpServer&lt;/span>(wg *sync.WaitGroup, reg *prometheus.Registry) *http.Server {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	srv := &amp;amp;http.Server{Addr: &lt;span style="color:#fc6a5d">&amp;#34;:8989&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	http.&lt;span style="color:#41a1c0">Handle&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;/metrics&amp;#34;&lt;/span>, promhttp.&lt;span style="color:#41a1c0">HandlerFor&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		reg,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		promhttp.HandlerOpts{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			EnableOpenMetrics: &lt;span style="color:#fc5fa3">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			Registry: reg,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">go&lt;/span> &lt;span style="color:#fc5fa3">func&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">defer&lt;/span> wg.&lt;span style="color:#41a1c0">Done&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">if&lt;/span> err := srv.&lt;span style="color:#41a1c0">ListenAndServe&lt;/span>(); err != http.ErrServerClosed {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#41a1c0">Println&lt;/span>(&lt;span style="color:#fc6a5d">&amp;#34;ListenAndServe():&amp;#34;&lt;/span>, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">return&lt;/span> srv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">NewExporter&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	reg := prometheus.&lt;span style="color:#41a1c0">NewRegistry&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	reg.&lt;span style="color:#41a1c0">MustRegister&lt;/span>(collector)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// Here, we start a new HTTP server and save the instance object into a golang sync.WaitGroup, so that we can watch its status in `FLBPluginExit`
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>	server.wg = &amp;amp;sync.WaitGroup{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	server.wg.&lt;span style="color:#41a1c0">Add&lt;/span>(&lt;span style="color:#d0bf69">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	server.srv = &lt;span style="color:#41a1c0">startHttpServer&lt;/span>(server.wg, reg)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="the-exporter-collector">The Exporter Collector&lt;/h2>
&lt;p>Now we have an HTTP server, but if we want to make it an exporter, we have to define the &lt;strong>collector&lt;/strong>. The collector is a Prometheus concept that implements two call-back functions:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// Here for instance, we define metrics to collect cpu info, which reuses the default Fluent-bit CPU metrics input data
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> &lt;span style="color:#41a1c0">NewMyCollector&lt;/span>() *myCollector {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">return&lt;/span> &amp;amp;myCollector{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		metrics: &lt;span style="color:#fc5fa3">map&lt;/span>[&lt;span style="color:#fc5fa3">string&lt;/span>]*prometheus.Desc{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc6a5d">&amp;#34;cpu&amp;#34;&lt;/span>: prometheus.&lt;span style="color:#41a1c0">NewDesc&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc6a5d">&amp;#34;cpu&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc6a5d">&amp;#34;Collect CPU usage&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				[]&lt;span style="color:#fc5fa3">string&lt;/span>{&lt;span style="color:#fc6a5d">&amp;#34;cpu&amp;#34;&lt;/span>, &lt;span style="color:#fc6a5d">&amp;#34;mode&amp;#34;&lt;/span>}, &lt;span style="color:#fc5fa3">nil&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#6c7986">// this buff is a golang channel object, which receive data sending from `FLBPluginFlushCtx` function
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>		buff: &lt;span style="color:#d0a8ff">make&lt;/span>(&lt;span style="color:#fc5fa3">chan&lt;/span> cpuMetrics),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// `Describe` send our metrics name and defination to Prometheus exporter
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> (collector *myCollector) &lt;span style="color:#41a1c0">Describe&lt;/span>(ch &lt;span style="color:#fc5fa3">chan&lt;/span>&amp;lt;- *prometheus.Desc) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">for&lt;/span> _, desc := &lt;span style="color:#fc5fa3">range&lt;/span> collector.metrics {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		ch &amp;lt;- desc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// `Collect` will read data from golang channel `buff` and send data to HTTP server handler
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">func&lt;/span> (collector *myCollector) &lt;span style="color:#41a1c0">Collect&lt;/span>(ch &lt;span style="color:#fc5fa3">chan&lt;/span>&amp;lt;- prometheus.Metric) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">for&lt;/span> _, desc := &lt;span style="color:#fc5fa3">range&lt;/span> collector.metrics {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">select&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">case&lt;/span> metric := &amp;lt;-collector.buff:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			fmt.&lt;span style="color:#41a1c0">Println&lt;/span>(metric.cpu, metric.mode, metric.value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			ch &amp;lt;- prometheus.&lt;span style="color:#41a1c0">MustNewConstMetric&lt;/span>(desc, prometheus.GaugeValue, metric.value, metric.cpu, metric.mode)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">var&lt;/span> collector = &lt;span style="color:#41a1c0">NewMyCollector&lt;/span>()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="building-so-file-and-running-in-fluent-bit">Building so file and running in Fluent-bit&lt;/h2>
&lt;p>Last but not least, building Golang plugin into so file.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>go build -buildmode=c-shared -o out_prom_exporter.so prom_exporter.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Run Fluent-bit with CLI flags:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>fluent-bit -v -e ./out_prom_exporter.so -i cpu -o promexporter
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s all steps to implement a customized Fluent-bit Prometheus exporter plugin. To see more details, please go to the Github repo &lt;a href="https://github.com/stevedsun/fluent-bit-output-prometheus-demo%3E">https://github.com/stevedsun/fluent-bit-output-prometheus-demo&amp;gt;&lt;/a>.&lt;/p></description></item><item><title>Building a File Parser</title><link>https://sund.site/posts/2022/2022-5-8_lexer_design/</link><pubDate>Sun, 08 May 2022 14:00:00 +0800</pubDate><guid>https://sund.site/posts/2022/2022-5-8_lexer_design/</guid><description>&lt;p>Last week, after reading this article - &lt;a href="https://www.aaronraff.dev/blog/how-to-write-a-lexer-in-go">How to Write a Lexer in Go&lt;/a>, I found that it is not so difficult to design a configuration file parser by this article&amp;rsquo;s mindset. Then I tried to write a fluent-bit configuration parser and finally got this &lt;a href="https://github.com/stevedsun/go-fluentbit-conf-parser">Fluent-Bit configuration parser for Golang&lt;/a>.&lt;/p>
&lt;p>In this article, I want to introduce how to parse Fluent-bit configuration &lt;code>.conf&lt;/code> file, and the thinking behind it.&lt;/p>
&lt;h2 id="fluent-bit-configuration-format-and-schema">Fluent-bit configuration format and schema&lt;/h2>
&lt;pre tabindex="0">&lt;code>[FIRST_SECTION]
 Key1 some value
 Key2 another value

[SECOND_SECTION]
 KeyN 3.14
&lt;/code>&lt;/pre>&lt;p>Here is a classic mode configuration of Fluent-bit, it includes two parts:&lt;/p>
&lt;ul>
&lt;li>Section&lt;/li>
&lt;li>Key/value pair&lt;/li>
&lt;/ul>
&lt;p>First of all, we need to define a struct that represents the Fluent-bit configuration file.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">type&lt;/span> FluentBitConf &lt;span style="color:#fc5fa3">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Sections []Section
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">type&lt;/span> Section &lt;span style="color:#fc5fa3">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Name &lt;span style="color:#fc5fa3">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Entries []Entry
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">type&lt;/span> Entry &lt;span style="color:#fc5fa3">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Key &lt;span style="color:#fc5fa3">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	Value &lt;span style="color:#fc5fa3">interface&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Once we have a struct, the next step is to parse tokens from the file and save their values into golang struct. We can copy the logic of the lexer to develop our fluent bit parser.&lt;/p>
&lt;p>In a lexer program, the target characters which we want to parse out are called &amp;ldquo;Token&amp;rdquo;, Token is also the keyword that our parser program is searching for. A parser program will read characters in a file one by one, whenever it found a token, the parser saves the value between tokens into the final structure and go ahead.&lt;/p>
&lt;h2 id="parse-a-single-token">Parse a single token&lt;/h2>
&lt;p>If we want to parse a Section, we have to make the parser read characters one by one and stop at &lt;code>[&lt;/code> character, which means the beginning of a Section. The parser must save the current state as &lt;code>t_section&lt;/code> and keep the parser reading until &lt;code>]&lt;/code> character, the word between &lt;code>[&lt;/code> and &lt;code>]&lt;/code> is the Section value we need to persist into go struct.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">// define some tag to tell parser state
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>&lt;span style="color:#fc5fa3">const&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	t_section = &lt;span style="color:#fc5fa3">iota&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> (parser *FluentBitConfParser) &lt;span style="color:#41a1c0">Parse&lt;/span>() *FluentBitConf {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">var&lt;/span> currSection *Section = &lt;span style="color:#fc5fa3">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// read charector one by one
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>		r, _, err := parser.reader.&lt;span style="color:#41a1c0">ReadRune&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">if&lt;/span> err != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// stop at the end of file
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>			&lt;span style="color:#fc5fa3">if&lt;/span> err == io.EOF {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc5fa3">if&lt;/span> currSection != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>					parser.Conf.Sections = &lt;span style="color:#d0a8ff">append&lt;/span>(parser.Conf.Sections, *currSection)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc5fa3">return&lt;/span> parser.Conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">return&lt;/span> parser.Conf
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">switch&lt;/span> r {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">case&lt;/span> &lt;span style="color:#fc6a5d">&amp;#39;\n&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">case&lt;/span> &lt;span style="color:#fc6a5d">&amp;#39;[&amp;#39;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#6c7986">// save last config item
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>			&lt;span style="color:#fc5fa3">if&lt;/span> currSection != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				parser.Conf.Sections = &lt;span style="color:#d0a8ff">append&lt;/span>(parser.Conf.Sections, *currSection)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#6c7986">// create new config item
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>			currSection = &amp;amp;Section{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				Name: &lt;span style="color:#fc6a5d">&amp;#34;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				Entries: []Entry{},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			parser.token = t_section
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">if&lt;/span> unicode.&lt;span style="color:#41a1c0">IsSpace&lt;/span>(r) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc5fa3">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#6c7986">// here is important function, read the charectors after token-chareactor and save them into struct
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#6c7986">&lt;/span>			strValue, _ := parser.&lt;span style="color:#41a1c0">parseString&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">switch&lt;/span> parser.token {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">case&lt;/span> t_section:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				currSection.Name = strValue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				parser.token = t_entry_key
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>In function &lt;code>parser.parseString()&lt;/code>, we have to read until the end of a value (for section, it&amp;rsquo;s &lt;code>]&lt;/code>), then return the value.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#fc5fa3">func&lt;/span> (parser *FluentBitConfParser) &lt;span style="color:#41a1c0">parseString&lt;/span>() (&lt;span style="color:#fc5fa3">string&lt;/span>, &lt;span style="color:#fc5fa3">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">var&lt;/span> val &lt;span style="color:#fc5fa3">string&lt;/span> = &lt;span style="color:#fc6a5d">&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">if&lt;/span> err := parser.reader.&lt;span style="color:#41a1c0">UnreadRune&lt;/span>(); err != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">return&lt;/span> &lt;span style="color:#fc6a5d">&amp;#34;&amp;#34;&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#fc5fa3">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		r, _, err := parser.reader.&lt;span style="color:#41a1c0">ReadRune&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">if&lt;/span> err != &lt;span style="color:#fc5fa3">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">if&lt;/span> err == io.EOF {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>				&lt;span style="color:#fc5fa3">return&lt;/span> val, &lt;span style="color:#fc5fa3">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">return&lt;/span> &lt;span style="color:#fc6a5d">&amp;#34;&amp;#34;&lt;/span>, err
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#fc5fa3">if&lt;/span> parser.token == t_section &amp;amp;&amp;amp; r == &lt;span style="color:#fc6a5d">&amp;#39;]&amp;#39;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>			&lt;span style="color:#fc5fa3">return&lt;/span> val, &lt;span style="color:#fc5fa3">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		val = val + &lt;span style="color:#d0a8ff">string&lt;/span>(r)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That&amp;rsquo;s all logic for parsing a section. Parse key/value pair is the same process, just note to make the parser know which state it is and save values between whitespace or &lt;code>\n&lt;/code>, you can see the code in &lt;a href="https://github.com/stevedsun/go-fluentbit-conf-parser/blob/master/parser.go">the Github repo&lt;/a>.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>To parse a configuration file, we have to&lt;/p>
&lt;ul>
&lt;li>Defining token (key characters)&lt;/li>
&lt;li>Reading characters and looking for a token&lt;/li>
&lt;li>Saving current state to tell parser which struct the following characters belong&lt;/li>
&lt;/ul></description></item></channel></rss>