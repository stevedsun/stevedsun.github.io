<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on 電波障害</title><link>https://sund.site/categories/go/</link><description>Recent content in Go on 電波障害</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 13 Sep 2023 09:19:18 +0800</lastBuildDate><atom:link href="https://sund.site/categories/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Go Server Side Events</title><link>https://sund.site/posts/2023/go-server-side-events/</link><pubDate>Wed, 13 Sep 2023 09:19:18 +0800</pubDate><guid>https://sund.site/posts/2023/go-server-side-events/</guid><description>Server-Sent Events (SSE) is a technology that enables real-time communication between a web browser and a server. It allows the server to send updates or event notifications to the browser without the need for the browser to repeatedly make requests.
SSE is often used in applications that require real-time updates, such as chat applications, social media feeds, stock market tickers, or notifications systems. It provides a lightweight and efficient way to deliver server-side updates to clients, improving responsiveness and reducing unnecessary network traffic.</description></item><item><title>Go 内存泄漏常见模式</title><link>https://sund.site/posts/2023/goroutine-leak/</link><pubDate>Tue, 27 Jun 2023 14:46:59 +0800</pubDate><guid>https://sund.site/posts/2023/goroutine-leak/</guid><description>最近在工作中排查 Go 语言内存泄漏问题时，发现这篇 Uber 写的博客，其中分享了几种常见的 goroutine 内存泄漏模式，于是把整理了 goroutine 的相关问题，希望更多人搜索到到这篇文章，帮助大家快速定位内存泄漏问题。
Goroutine 内存泄漏的原因 Go 语言的内存泄漏通常因为错误地使用 goroutine 和 channel。例如以下几种情况：
在 goroutine 里打开一个连接（如 gRPC）但是忘记 close 在 goroutine 里的全局变量对象没有释放 在 goroutine 里读 channel， 但是没有写入端，而被阻塞 在 goroutine 里写入无缓冲的 channel，但是由于 channel 的读端被其他协程关闭而阻塞 在 goroutine 里写入有缓冲的 channel，但是 channel 缓冲已满 这几种情况，通常掺杂在复杂的代码里逻辑里，很难调试发现问题。因此衍生出以下几种日常工作中最容易出现问题的模式。
常见 Goroutine 内存泄漏模式 Premature Function Return /功能过早返回 一个 goroutine 要写入 channel，但是在另一个端意外退出导致 channel 读取的代码没有执行。
func Example() { a := 1 c := make(chan error) go func() { c &amp;lt;- err return }() // do something if a &amp;gt; 0 { return } // do something err := &amp;lt;-c } 代码中主进程在if a &amp;gt; 0 处 return，导致 channel 无法写入而被阻塞。</description></item><item><title>Implementing a Prometheus Exporter for Fluent-bit</title><link>https://sund.site/posts/2022/implementing-prometheus-exporter-for-fluentbit/</link><pubDate>Thu, 24 Nov 2022 12:26:23 +0800</pubDate><guid>https://sund.site/posts/2022/implementing-prometheus-exporter-for-fluentbit/</guid><description>Background Fluent-bit is a great tool for logging and monitoring, many teams are using it to collect metrics and logs. Prometheus is also a popular tool for metrics analysis, but if you want to output Fluent-bit data to Prometheus, the only way is to use the node-exporter input plugin, which has fixed metrics and data format.
In our case, we want to export specific input data into Prometheus, therefore we have to implement our Prometheus exporter in a customized Fluent-bit output plugin.</description></item><item><title>Building a File Parser</title><link>https://sund.site/posts/2022/2022-5-8_lexer_design/</link><pubDate>Sun, 08 May 2022 14:00:00 +0800</pubDate><guid>https://sund.site/posts/2022/2022-5-8_lexer_design/</guid><description>Last week, after reading this article - How to Write a Lexer in Go, I found that it is not so difficult to design a configuration file parser by this article&amp;rsquo;s mindset. Then I tried to write a fluent-bit configuration parser and finally got this Fluent-Bit configuration parser for Golang.
In this article, I want to introduce how to parse Fluent-bit configuration .conf file, and the thinking behind it.
Fluent-bit configuration format and schema [FIRST_SECTION]
Key1 some value
Key2 another value
[SECOND_SECTION]
KeyN 3.</description></item></channel></rss>