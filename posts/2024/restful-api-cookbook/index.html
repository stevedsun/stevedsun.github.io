<!doctype html><html lang=zh-CN><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://sund.site/favicon.ico><title>RESTful Web Service Cookbook 笔记 | Steve Sun</title><meta name=title content="RESTful Web Service Cookbook 笔记"><meta name=description content='RESTful Web Service Cookbook 是一本简短、精炼的 RESTful 接口设计指南。这篇文章（笔记）用来记录这本书中提到的重点。

因为 RESTful 对后端开发来说实在太熟悉不过，所以我会省略掉那些习以为常的约定，只记录书中提到的、大多数开发者没有注意到的细节。
HTTP Method
GET
进行安全与幂等的信息获取。
POST
执行的目标是一个资源集合（工厂），而不是具体的 URI。
适用场景：

创建新的资源,把资源作为一个工厂。
通过一个控制器资源来修改一个或多个资源。
执行需要大数据输入（参数较多）的查询。
在其他 HTTP 方法看上去不合适时，执行不安全或非幂等的操作。

解决方案：

将一个已存在的资源标识为创建新资源的工厂。虽然您可以把任意资源用做工厂,但常见的做法是使用一个集合资源。
让客户端向工厂资源提交附有需要创建资源的表述的 POST 请求。通过可选支持的 Slug 头, 客户端可以向服务器建议一个名字,作为被创建资源的 URI 的一部分。
资源创建之后,返回响应码 201(Created),并在 Location 头中包含新创建资源的 URI。
如果响应正文包含了新创建资源的完整表述,那么在 Content-Location 头中包含新创建资源的 URI。

PUT
仅在客户端可以控制 URI 的构成时,才使用 PUT 方法创建新资源。（换句话说，PUT 也可以创建资源，但是仅限于客户端可以指定 URI）
确定资源对象的粒度
应该以适合客户端使用模式的方式来设计资源,而不是基于现有的数据库或对象模型。

可缓存性
减小修改频率
可变性——分离可变和不可变数据

如何设计复合资源?
复合资源降低了统一接口的可见性,因为它们的表述中包含了和其他资源相重叠的数据。

如果符合资源使用频率不高，可以考虑用缓存替代。
考虑网络开销，复合资源会不会降低服务端吞吐量，增大延时。

HTTP Body
以 JSON 格式的 Body 为例：

最好包含一个指向 self 的链接
如果分页，最好包含下一页的链接
如果分页，要指示集合的大小（总数）
如果查询对象是本地化的，添加一个属性来表示本地化内容的语言

{
  "name": "John",
  "id": "urn:example:user:1234",
  "link": {
    "rel": "self",
    "href": "http://www.example.org/person/john"
  },
  "address": {
    "id": "urn:example:address:4567",
    "link": {
      "rel": "self",
      "href": "http://www.example.org/person/john/address"
    }
  }
}
HTTP Response

对于客户端错误，返回 4xx 状态码 + Date （错误发生的时间）。
对于服务端错误，返回 5xx 状态码 + Date （错误发生的时间）。
Body 中要描述错误，如果有外部文档和链接可参考，在 Header 提供一个 Link 头或直接把链接写在 Body 里。
为了后期追踪或分析，在服务器上记录了错误日志，应该提供一个可以找到该错误的标识符或链接。

设计查询结构
设计查询请求

为了缓存和性能，尽量避免范围查询。解决方法包括：

使用预定义查询
也可以使用 HTTP Header： Range


避免使用通用语言（SQL、XPATH）的查询。
避免 URI 和数据存储方式的紧耦合（前端把后端当作数据库）。
对于参数较多，可以考虑使用 POST（因为 URI 长度有最大限制）

POST 接口的缺点是丧失了缓存能力
POST 请求是不可缓存的，所以 Cache-Control 和 Expires 头无济于事
解决缓存问题，可以让 POST 创建一个临时资源，把 link 返回前端，前端下次用 GET 获取该资源



设计查询响应结果

返回集合。添加合理的缓存过期头。
如果没有结果，应该返回空集合。
'><meta name=keywords content="api,"><link rel=canonical href=https://sund.site/posts/2024/restful-api-cookbook/><meta property="og:url" content="https://sund.site/posts/2024/restful-api-cookbook/"><meta property="og:site_name" content="Steve Sun"><meta property="og:title" content="RESTful Web Service Cookbook 笔记"><meta property="og:description" content='RESTful Web Service Cookbook 是一本简短、精炼的 RESTful 接口设计指南。这篇文章（笔记）用来记录这本书中提到的重点。
因为 RESTful 对后端开发来说实在太熟悉不过，所以我会省略掉那些习以为常的约定，只记录书中提到的、大多数开发者没有注意到的细节。
HTTP Method GET 进行安全与幂等的信息获取。
POST 执行的目标是一个资源集合（工厂），而不是具体的 URI。
适用场景：
创建新的资源,把资源作为一个工厂。 通过一个控制器资源来修改一个或多个资源。 执行需要大数据输入（参数较多）的查询。 在其他 HTTP 方法看上去不合适时，执行不安全或非幂等的操作。 解决方案：
将一个已存在的资源标识为创建新资源的工厂。虽然您可以把任意资源用做工厂,但常见的做法是使用一个集合资源。 让客户端向工厂资源提交附有需要创建资源的表述的 POST 请求。通过可选支持的 Slug 头, 客户端可以向服务器建议一个名字,作为被创建资源的 URI 的一部分。 资源创建之后,返回响应码 201(Created),并在 Location 头中包含新创建资源的 URI。 如果响应正文包含了新创建资源的完整表述,那么在 Content-Location 头中包含新创建资源的 URI。 PUT 仅在客户端可以控制 URI 的构成时,才使用 PUT 方法创建新资源。（换句话说，PUT 也可以创建资源，但是仅限于客户端可以指定 URI）
确定资源对象的粒度 应该以适合客户端使用模式的方式来设计资源,而不是基于现有的数据库或对象模型。
可缓存性 减小修改频率 可变性——分离可变和不可变数据 如何设计复合资源? 复合资源降低了统一接口的可见性,因为它们的表述中包含了和其他资源相重叠的数据。
如果符合资源使用频率不高，可以考虑用缓存替代。 考虑网络开销，复合资源会不会降低服务端吞吐量，增大延时。 HTTP Body 以 JSON 格式的 Body 为例：
最好包含一个指向 self 的链接 如果分页，最好包含下一页的链接 如果分页，要指示集合的大小（总数） 如果查询对象是本地化的，添加一个属性来表示本地化内容的语言 { "name": "John", "id": "urn:example:user:1234", "link": { "rel": "self", "href": "http://www.example.org/person/john" }, "address": { "id": "urn:example:address:4567", "link": { "rel": "self", "href": "http://www.example.org/person/john/address" } } } HTTP Response 对于客户端错误，返回 4xx 状态码 + Date （错误发生的时间）。 对于服务端错误，返回 5xx 状态码 + Date （错误发生的时间）。 Body 中要描述错误，如果有外部文档和链接可参考，在 Header 提供一个 Link 头或直接把链接写在 Body 里。 为了后期追踪或分析，在服务器上记录了错误日志，应该提供一个可以找到该错误的标识符或链接。 设计查询结构 设计查询请求 为了缓存和性能，尽量避免范围查询。解决方法包括： 使用预定义查询 也可以使用 HTTP Header： Range 避免使用通用语言（SQL、XPATH）的查询。 避免 URI 和数据存储方式的紧耦合（前端把后端当作数据库）。 对于参数较多，可以考虑使用 POST（因为 URI 长度有最大限制） POST 接口的缺点是丧失了缓存能力 POST 请求是不可缓存的，所以 Cache-Control 和 Expires 头无济于事 解决缓存问题，可以让 POST 创建一个临时资源，把 link 返回前端，前端下次用 GET 获取该资源 设计查询响应结果 返回集合。添加合理的缓存过期头。 如果没有结果，应该返回空集合。'><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-07-13T16:12:34+08:00"><meta property="article:modified_time" content="2024-07-13T16:12:34+08:00"><meta property="article:tag" content="Api"><meta property="og:image" content="https://sund.site/images/share.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sund.site/images/share.png"><meta name=twitter:title content="RESTful Web Service Cookbook 笔记"><meta name=twitter:description content='RESTful Web Service Cookbook 是一本简短、精炼的 RESTful 接口设计指南。这篇文章（笔记）用来记录这本书中提到的重点。
因为 RESTful 对后端开发来说实在太熟悉不过，所以我会省略掉那些习以为常的约定，只记录书中提到的、大多数开发者没有注意到的细节。
HTTP Method GET 进行安全与幂等的信息获取。
POST 执行的目标是一个资源集合（工厂），而不是具体的 URI。
适用场景：
创建新的资源,把资源作为一个工厂。 通过一个控制器资源来修改一个或多个资源。 执行需要大数据输入（参数较多）的查询。 在其他 HTTP 方法看上去不合适时，执行不安全或非幂等的操作。 解决方案：
将一个已存在的资源标识为创建新资源的工厂。虽然您可以把任意资源用做工厂,但常见的做法是使用一个集合资源。 让客户端向工厂资源提交附有需要创建资源的表述的 POST 请求。通过可选支持的 Slug 头, 客户端可以向服务器建议一个名字,作为被创建资源的 URI 的一部分。 资源创建之后,返回响应码 201(Created),并在 Location 头中包含新创建资源的 URI。 如果响应正文包含了新创建资源的完整表述,那么在 Content-Location 头中包含新创建资源的 URI。 PUT 仅在客户端可以控制 URI 的构成时,才使用 PUT 方法创建新资源。（换句话说，PUT 也可以创建资源，但是仅限于客户端可以指定 URI）
确定资源对象的粒度 应该以适合客户端使用模式的方式来设计资源,而不是基于现有的数据库或对象模型。
可缓存性 减小修改频率 可变性——分离可变和不可变数据 如何设计复合资源? 复合资源降低了统一接口的可见性,因为它们的表述中包含了和其他资源相重叠的数据。
如果符合资源使用频率不高，可以考虑用缓存替代。 考虑网络开销，复合资源会不会降低服务端吞吐量，增大延时。 HTTP Body 以 JSON 格式的 Body 为例：
最好包含一个指向 self 的链接 如果分页，最好包含下一页的链接 如果分页，要指示集合的大小（总数） 如果查询对象是本地化的，添加一个属性来表示本地化内容的语言 { "name": "John", "id": "urn:example:user:1234", "link": { "rel": "self", "href": "http://www.example.org/person/john" }, "address": { "id": "urn:example:address:4567", "link": { "rel": "self", "href": "http://www.example.org/person/john/address" } } } HTTP Response 对于客户端错误，返回 4xx 状态码 + Date （错误发生的时间）。 对于服务端错误，返回 5xx 状态码 + Date （错误发生的时间）。 Body 中要描述错误，如果有外部文档和链接可参考，在 Header 提供一个 Link 头或直接把链接写在 Body 里。 为了后期追踪或分析，在服务器上记录了错误日志，应该提供一个可以找到该错误的标识符或链接。 设计查询结构 设计查询请求 为了缓存和性能，尽量避免范围查询。解决方法包括： 使用预定义查询 也可以使用 HTTP Header： Range 避免使用通用语言（SQL、XPATH）的查询。 避免 URI 和数据存储方式的紧耦合（前端把后端当作数据库）。 对于参数较多，可以考虑使用 POST（因为 URI 长度有最大限制） POST 接口的缺点是丧失了缓存能力 POST 请求是不可缓存的，所以 Cache-Control 和 Expires 头无济于事 解决缓存问题，可以让 POST 创建一个临时资源，把 link 返回前端，前端下次用 GET 获取该资源 设计查询响应结果 返回集合。添加合理的缓存过期头。 如果没有结果，应该返回空集合。'><meta itemprop=name content="RESTful Web Service Cookbook 笔记"><meta itemprop=description content='RESTful Web Service Cookbook 是一本简短、精炼的 RESTful 接口设计指南。这篇文章（笔记）用来记录这本书中提到的重点。
因为 RESTful 对后端开发来说实在太熟悉不过，所以我会省略掉那些习以为常的约定，只记录书中提到的、大多数开发者没有注意到的细节。
HTTP Method GET 进行安全与幂等的信息获取。
POST 执行的目标是一个资源集合（工厂），而不是具体的 URI。
适用场景：
创建新的资源,把资源作为一个工厂。 通过一个控制器资源来修改一个或多个资源。 执行需要大数据输入（参数较多）的查询。 在其他 HTTP 方法看上去不合适时，执行不安全或非幂等的操作。 解决方案：
将一个已存在的资源标识为创建新资源的工厂。虽然您可以把任意资源用做工厂,但常见的做法是使用一个集合资源。 让客户端向工厂资源提交附有需要创建资源的表述的 POST 请求。通过可选支持的 Slug 头, 客户端可以向服务器建议一个名字,作为被创建资源的 URI 的一部分。 资源创建之后,返回响应码 201(Created),并在 Location 头中包含新创建资源的 URI。 如果响应正文包含了新创建资源的完整表述,那么在 Content-Location 头中包含新创建资源的 URI。 PUT 仅在客户端可以控制 URI 的构成时,才使用 PUT 方法创建新资源。（换句话说，PUT 也可以创建资源，但是仅限于客户端可以指定 URI）
确定资源对象的粒度 应该以适合客户端使用模式的方式来设计资源,而不是基于现有的数据库或对象模型。
可缓存性 减小修改频率 可变性——分离可变和不可变数据 如何设计复合资源? 复合资源降低了统一接口的可见性,因为它们的表述中包含了和其他资源相重叠的数据。
如果符合资源使用频率不高，可以考虑用缓存替代。 考虑网络开销，复合资源会不会降低服务端吞吐量，增大延时。 HTTP Body 以 JSON 格式的 Body 为例：
最好包含一个指向 self 的链接 如果分页，最好包含下一页的链接 如果分页，要指示集合的大小（总数） 如果查询对象是本地化的，添加一个属性来表示本地化内容的语言 { "name": "John", "id": "urn:example:user:1234", "link": { "rel": "self", "href": "http://www.example.org/person/john" }, "address": { "id": "urn:example:address:4567", "link": { "rel": "self", "href": "http://www.example.org/person/john/address" } } } HTTP Response 对于客户端错误，返回 4xx 状态码 + Date （错误发生的时间）。 对于服务端错误，返回 5xx 状态码 + Date （错误发生的时间）。 Body 中要描述错误，如果有外部文档和链接可参考，在 Header 提供一个 Link 头或直接把链接写在 Body 里。 为了后期追踪或分析，在服务器上记录了错误日志，应该提供一个可以找到该错误的标识符或链接。 设计查询结构 设计查询请求 为了缓存和性能，尽量避免范围查询。解决方法包括： 使用预定义查询 也可以使用 HTTP Header： Range 避免使用通用语言（SQL、XPATH）的查询。 避免 URI 和数据存储方式的紧耦合（前端把后端当作数据库）。 对于参数较多，可以考虑使用 POST（因为 URI 长度有最大限制） POST 接口的缺点是丧失了缓存能力 POST 请求是不可缓存的，所以 Cache-Control 和 Expires 头无济于事 解决缓存问题，可以让 POST 创建一个临时资源，把 link 返回前端，前端下次用 GET 获取该资源 设计查询响应结果 返回集合。添加合理的缓存过期头。 如果没有结果，应该返回空集合。'><meta itemprop=datePublished content="2024-07-13T16:12:34+08:00"><meta itemprop=dateModified content="2024-07-13T16:12:34+08:00"><meta itemprop=wordCount content="155"><meta itemprop=image content="https://sund.site/images/share.png"><meta itemprop=keywords content="Api"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width-max:720px;--font-primary:Verdana, sans-serif;--font-secondary:monospace;--font-size-primary:1em;--font-size-secondary:0.8em;--body-bg-color:#fcfcfc;--bold-text-color:#222;--body-text-color:#444;--link-color:#3273dc;--link-visited-color:#8b6fcb;--table-border-color:#f2f2f2;--table-th-bg-color:#f2f2f2;--img-border-color:#f2f2f2;--code-bg-color:#f2f2f2;--code-text-color:#222;--blockquote-border-color:#666;--blockquote-text-color:#666;--upvoted-color:#FA8072}@media(prefers-color-scheme:dark){:root{--body-bg-color:#1c1c1c;--bold-text-color:#eee;--body-text-color:#ddd;--link-color:#8cc2dd;--link-visited-color:#c3b1ee;--table-border-color:#999;--table-th-bg-color:#999;--img-border-color:#999;--code-bg-color:#555;--code-text-color:#ddd;--blockquote-border-color:#ccc;--blockquote-text-color:#ccc}}body{font-family:var(--font-primary);font-size:var(--font-size-primary);margin:auto;padding:20px;max-width:var(--width-max);text-align:left;background-color:var(--body-bg-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--body-text-color)}h1,h2,h3,h4,h5,h6,strong,b{color:var(--bold-text-color)}h1,h2,h3,h4,h5,h6{margin:16px 0}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}.title{text-decoration:none;border:0}.title:hover{text-decoration:none}.title span{font-weight:400}nav a{margin-right:8px}textarea{width:100%;font-size:16px}input{font-size:14px}content{line-height:1.6}table{width:100%;border-collapse:collapse;border:1px solid var(--table-border-color);border-radius:4px}th,td{border:1px solid var(--table-border-color);padding:4px}th{background-color:var(--table-th-bg-color)}hr{border:0;border-top:1px dashed}img{max-width:100%;display:block;margin-left:auto;margin-right:auto;border:1px solid var(--img-border-color);border-radius:4px;content-visibility:auto;loading:lazy}img[src*="#minipic"]{max-width:50%;margin-left:0;margin-right:auto}i{font-style:normal}time{font-family:var(--font-secondary);font-size:15px}code{font-family:var(--font-secondary);background-color:var(--code-bg-color);color:var(--code-text-color);padding:2px;border-radius:4px}pre code{display:block;padding:16px;white-space:pre-wrap;overflow-x:auto}div.highlight pre{border-radius:4px}div.highlight code{background-color:var(--code-bg-color);color:var(--code-text-color)}blockquote{border-left:2px solid var(--blockquote-border-color);color:var(--blockquote-text-color);margin:0;padding-left:16px;font-style:normal}blockquote p{margin:0}footer{padding:25px 0;text-align:center;font-size:var(--font-size-secondary)}ul li:has(input){list-style-type:none;margin-left:-25.5px}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li span.grouped{flex:0 0 80px}ul.blog-posts li a:visited{color:var(--link-visited-color)}div.toc{position:fixed;top:50%;left:calc((100vw + var(--width-max))/2);transform:translateY(-50%);width:calc((90vw - var(--width-max))/2);max-height:80vh;overflow-y:auto;padding:20px 8px;z-index:99;&::-webkit-scrollbar { display:none; } -ms-overflow-style:none;scrollbar-width:none}div.toc ul{list-style-type:none;padding-left:0}div.toc ul li{margin:8px 0}div.toc ul li a{text-decoration:none;color:var(--blockquote-text-color)}div.toc ul li a:hover{color:var(--link-color)}button.upvote-btn{margin:0;padding:0;border:none;background:0 0;cursor:pointer;display:flex;flex-direction:column;align-items:center;color:var(--body-text-color)}button.upvoted{color:var(--upvoted-color)}span.upvote-count{margin-top:-4px;font-size:smaller}@media(max-width:500px){img[src*="#minipic"]{max-width:100%;margin-left:auto;margin-right:auto}div.toc{display:none}}</style><style>body,div.post-body,h1,h2,h3,h4{font-family:microsoft yahei,pingfang sc,avenir,segoe ui,hiragino sans gb,STHeiti,microsoft sans serif,wenquanyi micro hei,sans-serif}</style><script async src="https://www.googletagmanager.com/gtag/js?id=G-XJJVVQ0LBH"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XJJVVQ0LBH")</script></head><body><header><a href=/ class=title><h1>Steve Sun</h1></a><nav><a href=/>Home</a>
<a href=/friends/>Friends</a>
<a href=/posts/>Posts</a></nav></header><main><h1>RESTful Web Service Cookbook 笔记</h1><p><i><time datetime=2024-07-13 pubdate>13 Jul, 2024</time></i></p><content><p><a href=https://www.oreilly.com/library/view/restful-web-services/9780596809140/>RESTful Web Service Cookbook</a> 是一本简短、精炼的 RESTful 接口设计指南。这篇文章（笔记）用来记录这本书中提到的重点。</p><blockquote><p>因为 RESTful 对后端开发来说实在太熟悉不过，所以我会省略掉那些习以为常的约定，只记录书中提到的、大多数开发者没有注意到的细节。</p></blockquote><h2 id=http-method>HTTP Method</h2><h3 id=get>GET</h3><p>进行<strong>安全</strong>与<strong>幂等</strong>的信息获取。</p><h3 id=post>POST</h3><p>执行的目标是一个资源集合（工厂），而不是具体的 URI。</p><p>适用场景：</p><ul><li>创建新的资源,把资源作为一个工厂。</li><li>通过一个控制器资源来修改一个或多个资源。</li><li>执行需要大数据输入（参数较多）的查询。</li><li><strong>在其他 HTTP 方法看上去不合适时，执行不安全或非幂等的操作</strong>。</li></ul><p>解决方案：</p><ul><li>将一个已存在的资源标识为创建新资源的工厂。虽然您可以把任意资源用做工厂,但常见的做法是使用一个集合资源。</li><li>让客户端向工厂资源提交附有需要创建资源的表述的 POST 请求。通过可选支持的 <strong>Slug</strong> 头, 客户端可以向服务器建议一个名字,作为被创建资源的 URI 的一部分。</li><li>资源创建之后,返回响应码 <strong>201(Created)</strong>,并在 <strong>Location</strong> 头中包含新创建资源的 URI。</li><li>如果响应正文包含了新创建资源的完整表述,那么在 <strong>Content-Location</strong> 头中包含新创建资源的 URI。</li></ul><h3 id=put>PUT</h3><p>仅在客户端可以控制 URI 的构成时,才使用 PUT 方法创建新资源。<strong>（换句话说，PUT 也可以创建资源，但是仅限于客户端可以指定 URI）</strong></p><h2 id=确定资源对象的粒度>确定资源对象的粒度</h2><p>应该以适合客户端使用模式的方式来设计资源,而不是基于现有的数据库或对象模型。</p><ul><li>可缓存性</li><li>减小修改频率</li><li>可变性——分离可变和不可变数据</li></ul><h3 id=如何设计复合资源>如何设计复合资源?</h3><p><strong>复合资源</strong>降低了统一接口的可见性,因为它们的表述中包含了和其他资源相重叠的数据。</p><ul><li>如果符合资源使用<strong>频率不高</strong>，可以考虑用<strong>缓存</strong>替代。</li><li>考虑网络开销，复合资源会不会降低服务端吞吐量，增大延时。</li></ul><h2 id=http-body>HTTP Body</h2><p>以 JSON 格式的 Body 为例：</p><ol><li>最好包含一个指向 self 的链接</li><li>如果分页，最好包含下一页的链接</li><li>如果分页，要指示集合的大小（总数）</li><li>如果查询对象是本地化的，添加一个属性来表示本地化内容的语言</li></ol><div class=highlight><pre tabindex=0 style=color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  &#34;name&#34;: <span style=color:#fc6a5d>&#34;John&#34;</span>,
</span></span><span style=display:flex><span>  &#34;id&#34;: <span style=color:#fc6a5d>&#34;urn:example:user:1234&#34;</span>,
</span></span><span style=display:flex><span>  &#34;link&#34;: {
</span></span><span style=display:flex><span>    &#34;rel&#34;: <span style=color:#fc6a5d>&#34;self&#34;</span>,
</span></span><span style=display:flex><span>    &#34;href&#34;: <span style=color:#fc6a5d>&#34;http://www.example.org/person/john&#34;</span>
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  &#34;address&#34;: {
</span></span><span style=display:flex><span>    &#34;id&#34;: <span style=color:#fc6a5d>&#34;urn:example:address:4567&#34;</span>,
</span></span><span style=display:flex><span>    &#34;link&#34;: {
</span></span><span style=display:flex><span>      &#34;rel&#34;: <span style=color:#fc6a5d>&#34;self&#34;</span>,
</span></span><span style=display:flex><span>      &#34;href&#34;: <span style=color:#fc6a5d>&#34;http://www.example.org/person/john/address&#34;</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=http-response>HTTP Response</h2><ol><li>对于客户端错误，返回 4xx 状态码 + Date （错误发生的时间）。</li><li>对于服务端错误，返回 5xx 状态码 + Date （错误发生的时间）。</li><li>Body 中要描述错误，如果有外部文档和链接可参考，在 Header 提供一个 Link 头或直接把链接写在 Body 里。</li><li>为了后期追踪或分析，在服务器上记录了错误日志，应该提供一个可以找到该错误的标识符或链接。</li></ol><h2 id=设计查询结构>设计查询结构</h2><h3 id=设计查询请求>设计查询请求</h3><ol><li>为了缓存和性能，尽量避免范围查询。解决方法包括：<ul><li>使用预定义查询</li><li>也可以使用 HTTP Header： Range</li></ul></li><li>避免使用通用语言（SQL、XPATH）的查询。</li><li>避免 URI 和数据存储方式的紧耦合（前端把后端当作数据库）。</li><li>对于参数较多，可以考虑使用 POST（因为 URI 长度有最大限制）<ul><li>POST 接口的缺点是丧失了缓存能力</li><li>POST 请求是不可缓存的，所以 Cache-Control 和 Expires 头无济于事</li><li>解决缓存问题，可以让 POST 创建一个临时资源，把 link 返回前端，前端下次用 GET 获取该资源</li></ul></li></ol><h3 id=设计查询响应结果>设计查询响应结果</h3><ol><li>返回集合。添加合理的缓存过期头。</li><li>如果没有结果，应该返回<strong>空集合</strong>。</li></ol></content><p><a href=https://sund.site/tags/api/>#Api</a></p><div class=toc><nav id=TableOfContents><ul><li><a href=#http-method>HTTP Method</a><ul><li><a href=#get>GET</a></li><li><a href=#post>POST</a></li><li><a href=#put>PUT</a></li></ul></li><li><a href=#确定资源对象的粒度>确定资源对象的粒度</a><ul><li><a href=#如何设计复合资源>如何设计复合资源?</a></li></ul></li><li><a href=#http-body>HTTP Body</a></li><li><a href=#http-response>HTTP Response</a></li><li><a href=#设计查询结构>设计查询结构</a><ul><li><a href=#设计查询请求>设计查询请求</a></li><li><a href=#设计查询响应结果>设计查询响应结果</a></li></ul></li></ul></nav></div></main><footer>Subscribe via <a href=/index.xml>RSS</a>.<br>Made with
<a href=https://github.com/rokcso/hugo-bearblog-neo/>Hugo Bear Neo</a>.<br>Copyright © 2013-2025, Steve Sun.
🗺️ <a href=/sitemap.xml>Sitemap</a>.</footer></body></html>