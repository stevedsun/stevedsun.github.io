<!doctype html><html lang=en-us><head><title>《Python源码剖析》第二部分——Python虚拟机基础 | 电波障害</title><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="写作者分享思想，同时也帮助自己思考。"><meta name=generator content="Hugo 0.79.1"><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel=stylesheet href=/css/style.css><link rel="shortcut icon" href=/images/favicon.ico type=image/x-icon><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-64688885-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><nav class=navigation><a href=/><span class=arrow>←</span>Home</a>
<a href=/posts>Archive</a>
<a href=/tags>Tags</a>
<a href=/about>About</a>
<a class=button href=https://sund.site/index.xml>Subscribe</a></nav><main class=main><section id=single><h1 class=title>《Python源码剖析》第二部分——Python虚拟机基础</h1><div class=tip><span>Jul 13, 2017 00:00</span>
<span class=split>·</span>
<span>4082 words</span>
<span class=split>·</span>
<span>9 minute read</span></div><div class=content><h2 id=python执行环境>Python执行环境 <a href=#python%e6%89%a7%e8%a1%8c%e7%8e%af%e5%a2%83 class=anchor>🔗</a></h2><blockquote><p>在编译过程中，这些包含在Python源代码中的静态信息都会被Python编译器收集起来，编译的结果中包含了字符串，常量值，字节码等在源代码中出现的一切有用的静态信息。在Python运行期间，这些源文件中提供的静态信息最终会被存储在一个运行时的对象中，当Python运行结束后，这个运行时对象中所包含的信息甚至还会被存储在一种文件中。这个对象和文件就是我们这章探索的重点：PyCodeObject对象和pyc文件。</p></blockquote><blockquote><p>在程序运行期间，编译结果存在于内存的PyCodeObject对象中；而Python结束运行后，编译结果又被保存到了pyc文件中。当下一次运行相同的程序时，Python会根据pyc文件中记录的编译结果直接建立内存中的PyCodeObject对象，而不用再次对源文件进行编译了。</p></blockquote><p>从文章摘录可见，python生成的不是编译后的文件，而是<code>.py</code>文件对应的静态信息——PyCodeObject，这里包括了字节码指令序列、字符串、常量。每个名字空间(类、模块、函数)都对应一个独立的PyCodeObject。(python连编译后的文件里存的都是个对象！)</p><p>不被import的py文件不会生成pyc。标准库里有py_compile等方法也可以生成pyc。</p><p><strong>import机制</strong> 导入某个模块时，先查找对应的pyc，如果没有pyc就生成然后import这个pyc。(所以实际导入的并不是py文件，而是py文件编译后的PyCodeObject)。</p><p><strong>PyFrameObject</strong> Python程序运行时的「执行环境」。参考操作系统执行可执行文件的过程。Python也是将函数对应的执行环境封装成栈帧的形式加载进内存。</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#a2f;font-weight:700>typedef</span> <span style=color:#a2f;font-weight:700>struct</span> _frame {
    PyObject_VAR_HEAD
    <span style=color:#a2f;font-weight:700>struct</span> _frame <span style=color:#666>*</span>f_back;  <span style=color:#080;font-style:italic>//执行环境链上的前一个frame
</span><span style=color:#080;font-style:italic></span>    PyCodeObject <span style=color:#666>*</span>f_code;   <span style=color:#080;font-style:italic>//PyCodeObject对象
</span><span style=color:#080;font-style:italic></span>    PyObject <span style=color:#666>*</span>f_builtins;   <span style=color:#080;font-style:italic>//builtin名字空间
</span><span style=color:#080;font-style:italic></span>    PyObject <span style=color:#666>*</span>f_globals;    <span style=color:#080;font-style:italic>//global名字空间
</span><span style=color:#080;font-style:italic></span>    PyObject <span style=color:#666>*</span>f_locals;     <span style=color:#080;font-style:italic>//local名字空间
</span><span style=color:#080;font-style:italic></span>    PyObject <span style=color:#666>**</span>f_valuestack;    <span style=color:#080;font-style:italic>//运行时栈的栈底位置
</span><span style=color:#080;font-style:italic></span>    PyObject <span style=color:#666>**</span>f_stacktop;      <span style=color:#080;font-style:italic>//运行时栈的栈顶位置
</span><span style=color:#080;font-style:italic></span>    <span>……</span>
    <span style=color:#0b0;font-weight:700>int</span> f_lasti;        <span style=color:#080;font-style:italic>//上一条字节码指令在f_code中的偏移位置
</span><span style=color:#080;font-style:italic></span>    <span style=color:#0b0;font-weight:700>int</span> f_lineno;       <span style=color:#080;font-style:italic>//当前字节码对应的源代码行
</span><span style=color:#080;font-style:italic></span>    <span>……</span>
    <span style=color:#080;font-style:italic>//动态内存，维护（局部变量+cell对象集合+free对象集合+运行时栈）所需要的空间
</span><span style=color:#080;font-style:italic></span>    PyObject <span style=color:#666>*</span>f_localsplus[<span style=color:#666>1</span>];  
} PyFrameObject;
</code></pre></div><p>Python标准库的<code>sys._getframe()</code>可以动态的在程序执行时获取当前内存中活跃的PyFrameObject信息。</p><h2 id=legb-规则>LEGB 规则 <a href=#legb-%e8%a7%84%e5%88%99 class=anchor>🔗</a></h2><p>即python作用域的查找顺序是<code>local</code>-<code>enclosing</code>-<code>global</code>-<code>buildin</code>。看下面代码：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python>a <span style=color:#666>=</span> <span style=color:#666>1</span>

<span style=color:#a2f;font-weight:700>def</span> <span style=color:#00a000>g</span>():
  <span style=color:#a2f;font-weight:700>print</span> a

<span style=color:#a2f;font-weight:700>def</span> <span style=color:#00a000>f</span>():
  <span style=color:#a2f;font-weight:700>print</span> a <span style=color:#666>//</span>[<span style=color:#666>1</span>]
  a <span style=color:#666>=</span> <span style=color:#666>2</span> <span style=color:#666>//</span>[<span style=color:#666>2</span>]
  <span style=color:#a2f;font-weight:700>print</span> a

g()
</code></pre></div><p>代码在[1]处会抛出异常，原因是python在编译阶段就把静态数据(局部变量、全局变量、字节码)放入pyc里，执行到<code>f()</code>里时，查找到<code>a</code>是在local作用域里定义的而不是global里，但是此时local的a还没赋值，所以就会抛出异常。由此可见，<strong>python作用域信息是在静态编译时就处理好了的</strong>。</p><h2 id=python-虚拟机运行框架>Python 虚拟机运行框架 <a href=#python-%e8%99%9a%e6%8b%9f%e6%9c%ba%e8%bf%90%e8%a1%8c%e6%a1%86%e6%9e%b6 class=anchor>🔗</a></h2><blockquote><p>运行时环境是一个全局的概念，而执行环境实际就是一个栈帧，是一个与某个Code Block对应的概念。</p></blockquote><blockquote><p>在PyCodeObject对象的co_code域中保存着字节码指令和字节码指令的参数，Python虚拟机执行字节码指令序列的过程就是从头到尾遍历整个co_code、依次执行字节码指令的过程。</p></blockquote><p>由上文引用可见，python在编译阶段将代码块的字节码保存在PyCodeObject的co_code属性里，然后在执行阶段从头到尾遍历这个co_code属性解读字节码。</p><p><strong>Python运行时环境</strong> Python在运行时用PyInterpreterState结构维护进程运行环境，PyThreadState维护线程运行环境，PyFrameObject维护栈帧运行环境，三者是依次包含关系，如下图所示：</p><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/GHImB214fvxSXgk.png alt></p></p><p>Python虚拟机就是一个「软CPU」，动态加载上述三种结构进内存，并模拟操作系统执行过程。程序执行后，先创建各个运行时环境，再将栈帧中的字节码载入，循环遍历解释执行。</p><h2 id=python字节码>Python字节码 <a href=#python%e5%ad%97%e8%8a%82%e7%a0%81 class=anchor>🔗</a></h2><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>i <span style=color:#666>=</span> <span style=color:#666>1</span>
<span style=color:#666>0</span>   LOAD_CONST   <span style=color:#666>0</span>  (<span style=color:#666>1</span>)
<span style=color:#666>3</span>   STORE_NAME   <span style=color:#666>0</span>  (i)
</code></pre></div><p>例如python的一条语句<code>i=1</code>可以解释为下面两行字节码，最左边的第1列数字代表这行字节码在内存中的偏移位置，第2列是字节码的名字(CPU并不关心名字，它只是根据偏移量读出字节码，所以这个名字是方便阅读用的)，第3列是字节码的参数，如<code>LOAD_CONST</code>对应的数据在变量<code>f->f_code->co_consts</code>里，0就是这个参数位于<code>f->f_code->co_consts</code>的偏移量。最后一列的括号里是从参数里取到的value。</p><h2 id=python-的异常抛出机制>Python 的异常抛出机制 <a href=#python-%e7%9a%84%e5%bc%82%e5%b8%b8%e6%8a%9b%e5%87%ba%e6%9c%ba%e5%88%b6 class=anchor>🔗</a></h2><p>异常处理的操作都在<code>Python/traceback.c</code>文件里，python每次调用一层函数，就创建改函数对应的PyFrameObject对象来保存函数运行时信息，PythonFrameObject里调用PyEval_EvalFrameEx循环解释字节码，如果抛出异常就创建PyTraceBackObject对象，将对象交给上一层PyFrameObject里的PyTracebackObject组成链表，最后返回最上层PyRun_SimpleFileExFlags函数，该函数调用PyErr_Print遍历PyTraceBackObject链表打印出异常信息。</p><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/9bEUBjYov8mZy3s.jpg alt></p></p><h2 id=函数对象的实现>函数对象的实现 <a href=#%e5%87%bd%e6%95%b0%e5%af%b9%e8%b1%a1%e7%9a%84%e5%ae%9e%e7%8e%b0 class=anchor>🔗</a></h2><p>PyFunctionObject是函数对象。在python调用函数时，生成PyFunctionObject对象，该对象的f_global指针用来将外层的全局变量传递给函数内部，然后在<code>ceval.c</code>文件的<code>fast_function</code>里解出PyFunctionObject对象里携带的信息，创建新的PyFrameObject对象(上文说过这个对象是维护运行时环境的)，最后调用执行字节码的函数<code>PyEval_EvalFrameEx</code>执行真正函数字节码。</p><p><strong>Python执行一段代码需要什么？</strong> 从书中描述可见，python执行一段代码需要做几件事：</p><ul><li>从源码编译出 PyCodeObject 保存变量和字节码</li><li>执行阶段，从PyCodeObject里取出信息交给 PyFrameObject，执行 PyEval_EvalFrameEx 解释字节码</li><li>如果遇到函数调用，就把函数对应的代码段从 PyCodeObject 存入 PyFunctionObject 对象，然后把这个函数对象通过参数传给新创建的 PyFrameObject ，在内层空间执行 PyEval_EvalFrameEx 解释字节码</li><li>将结果或异常存入 PyFrameObject 的变量( 异常是存入f_blockstack里，外层判断f_blockstack里的数据是被except捕获还是没有捕获而继续下一步操作) 抛给外层</li></ul><p>值得注意的是，<strong>python在执行阶段，将对函数参数的键值查找，转换为索引查找</strong>，即在转换PyCodeObject为PyFrameObject时，将参数信息按位置参数、键参数按照一定顺序存储在f_localsplus变量中，再用索引来查找对应参数，而需要查找键值。这样提高了运行时效率。下图是<code>foo('Rboert', age=5)</code>在内存中的存储形式。</p><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/IGy8JTzZpgmN6sL.jpg alt></p></p><h2 id=闭包的实现>闭包的实现 <a href=#%e9%97%ad%e5%8c%85%e7%9a%84%e5%ae%9e%e7%8e%b0 class=anchor>🔗</a></h2><p>Python在编译阶段就把函数闭包内层和闭包外层使用的变量存入PyCodeObject中：</p><ul><li>co_cellvars：通常是一个tuple，保存嵌套的作用域中使用的变量名集合；</li><li>co_freevars：通常也是一个tuple，保存使用了的外层作用域中的变量名集合。</li></ul><p>在执行阶段，PyFrameObject的f_localsplus中也为闭包的变量划分的内存区域，如下图所示：</p><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/fUB4wC36dAc7rqt.jpg alt></p></p><h2 id=元类>元类 <a href=#%e5%85%83%e7%b1%bb class=anchor>🔗</a></h2><p>元类<code>&lt;type type></code>和其他类的关系如下图：</p><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/N76woqSlmR28Oyt.jpg alt></p></p><p><strong>可调用性（callable）</strong> ，只要一个对象对应的class对象中实现了“<strong>call</strong>”操作（更确切地说，在Python内部的PyTypeObject中，tp_call不为空）那么这个对象就是一个可调用的对象，换句话说，在Python中，所谓“调用”，就是执行对象的type所对应的class对象的tp_call操作。</p><h2 id=descriptor>Descriptor <a href=#descriptor class=anchor>🔗</a></h2><blockquote><p>在PyType_Ready中，Python虚拟机会填充tp_dict，其中与操作名对应的是一个个descriptor
对于一个Python中的对象obj，如果obj.__ class__对应的class对象中存在__get__、__set__和__delete__三种操作，那么obj就可称为Python一个descriptor。</p></blockquote><blockquote><p>如果细分，那么descriptor还可分为如下两种：</p></blockquote><ol><li>data descriptor : type中定义了__get__和__set__的descriptor；</li><li>non data descriptor : type中只定义了__get__的descriptor。
在Python虚拟机访问instance对象的属性时，descriptor的一个作用是影响Python虚拟机对属性的选择。从PyObject_GenericGetAttr的伪代码可以看出，Python虚拟机会在instance对象自身的__dict__中寻找属性，也会在instance对象对应的class对象的mro列表中寻找</li></ol><blockquote><ol><li>Python虚拟机按照instance属性、class属性的顺序选择属性，即instance属性优先于class属性；</li><li>如果在class属性中发现同名的data descriptor，那么该descriptor会优先于instance属性被Python虚拟机选择</li></ol></blockquote><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/1xKk3IVPdjWb8iB.jpg alt></p></p><h3 id=引申python-黑魔法-descriptor-描述器>引申：Python 黑魔法 Descriptor (描述器) <a href=#%e5%bc%95%e7%94%b3python-%e9%bb%91%e9%ad%94%e6%b3%95-descriptor-%e6%8f%8f%e8%bf%b0%e5%99%a8 class=anchor>🔗</a></h3><ul><li><a href=http://www.jianshu.com/p/250f0d305c35>http://www.jianshu.com/p/250f0d305c35</a></li><li><a href=http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html>http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html</a></li></ul><h2 id=bound-method和unbound-method>Bound Method和Unbound Method <a href=#bound-method%e5%92%8cunbound-method class=anchor>🔗</a></h2><p>假设有下面两种对类方法的调用：</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#a2f;font-weight:700>class</span> <span style=color:#00f>A</span>(<span style=color:#a2f>object</span>):
    <span style=color:#a2f;font-weight:700>def</span> <span style=color:#00a000>f</span>(self):
        <span style=color:#a2f;font-weight:700>pass</span>

a <span style=color:#666>=</span> A()
<span style=color:#080;font-style:italic># [1]</span>
a<span style=color:#666>.</span>f()  

<span style=color:#080;font-style:italic># [2]</span>
A<span style=color:#666>.</span>f(a)

<span style=color:#080;font-style:italic># [3]</span>
func <span style=color:#666>=</span> a<span style=color:#666>.</span>f
func()
</code></pre></div><p>在代码[1]里，实例a调用类方法f，python底层会自动完成实例a和类方法f之间的绑定动作(调用<code>func_ descr_get(A.f, a, A)</code>，将实例地址和函数对象PyFunctionObject封装到一个PyMethodObject)，而代码[2]里直接通过A调用，则f为非绑定的PyMethodObject，里面没有实例信息，需要传入a。</p><p>比较绑定方法与非绑定方法可知，通过[1]的方式每次都要绑定一次实例，开销非常大，下图比较的是[1]和[3]两种方式，绑定操作的执行次数。</p><p><p class=markdown-image><img src=https://i.loli.net/2021/03/05/TpCcdaYmHlQnXzE.jpg alt></p></p><p>结论： <strong>调用类实例绑定的方法时，如果方法执行次数非常多，最好将方法赋值给一个变量，防止重复绑定增加开销</strong></p></div><div class=tags><a href=https://sund.site/tags/python>python</a></div></section></main><footer id=footer><div id=social><a class=symbol href=https://github.com/stevedsun target=_blank><svg fill="#bbb" width="28" height="28" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><title>Github</title><desc>Created with Sketch.</desc><defs/><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="Social-Icons---Rounded-Black" transform="translate(-264.000000, -939.000000)"><g id="Github" transform="translate(264.000000, 939.000000)"><path d="M8 72H64C68.418278 72 72 68.418278 72 64V8c0-4.418278-3.581721999999999-8-8-8H8c-4.418278 811624501e-24-8 3.581722-8 8V64C541083001e-24 68.418278 3.581722 72 8 72z" id="Rounded" fill="#bbb"/><path d="M35.9985 13C22.746 13 12 23.7870921 12 37.096644 12 47.7406712 18.876 56.7718301 28.4145 59.9584121 29.6145 60.1797862 30.0525 59.4358488 30.0525 58.7973276 30.0525 58.2250681 30.0315 56.7100863 30.0195 54.6996482 23.343 56.1558981 21.9345 51.4693938 21.9345 51.4693938 20.844 48.6864054 19.2705 47.9454799 19.2705 47.9454799 17.091 46.4500754 19.4355 46.4801943 19.4355 46.4801943 21.843 46.6503662 23.1105 48.9634994 23.1105 48.9634994 25.2525 52.6455377 28.728 51.5823398 30.096 50.9649018 30.3135 49.4077535 30.9345 48.3460615 31.62 47.7436831 26.2905 47.1352808 20.688 45.0691228 20.688 35.8361671 20.688 33.2052792 21.6225 31.0547881 23.1585 29.3696344 22.911 28.7597262 22.0875 26.3110578 23.3925 22.9934585 23.3925 22.9934585 25.4085 22.3459017 29.9925 25.4632101 31.908 24.9285993 33.96 24.6620468 36.0015 24.6515052 38.04 24.6620468 40.0935 24.9285993 42.0105 25.4632101 46.5915 22.3459017 48.603 22.9934585 48.603 22.9934585 49.9125 26.3110578 49.089 28.7597262 48.8415 29.3696344 50.3805 31.0547881 51.309 33.2052792 51.309 35.8361671 51.309 45.0917119 45.6975 47.1292571 40.3515 47.7256117 41.2125 48.4695491 41.9805 49.9393525 41.9805 52.1877301 41.9805 55.4089489 41.9505 58.0067059 41.9505 58.7973276 41.9505 59.4418726 42.3825 60.1918338 43.6005 59.9554002 53.13 56.7627944 60 47.7376593 60 37.096644 60 23.7870921 49.254 13 35.9985 13" fill="#fff"/></g></g></g></svg></a><a class=symbol href=https://twitter.com/way2steve target=_blank><svg fill="#bbb" width="28" height="28" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="438.536" height="438.536" viewBox="0 0 438.536 438.536" style="enable-background:new 0 0 438.536 438.536"><g><path d="M414.41 24.123C398.333 8.042 378.963.0 356.315.0H82.228C59.58.0 40.21 8.042 24.126 24.123 8.045 40.207.003 59.576.003 82.225v274.084c0 22.647 8.042 42.018 24.123 58.102 16.084 16.084 35.454 24.126 58.102 24.126h274.084c22.648.0 42.018-8.042 58.095-24.126 16.084-16.084 24.126-35.454 24.126-58.102V82.225C438.532 59.576 430.49 40.204 414.41 24.123zM335.471 168.735c.191 1.713.288 4.278.288 7.71.0 15.989-2.334 32.025-6.995 48.104-4.661 16.087-11.8 31.504-21.416 46.254-9.606 14.749-21.074 27.791-34.396 39.115-13.325 11.32-29.311 20.365-47.968 27.117-18.648 6.762-38.637 10.143-59.953 10.143-33.116.0-63.76-8.952-91.931-26.836 4.568.568 9.329.855 14.275.855 27.6.0 52.439-8.565 74.519-25.7-12.941-.185-24.506-4.179-34.688-11.991-10.185-7.803-17.273-17.699-21.271-29.691 4.947.76 8.658 1.137 11.132 1.137 4.187.0 9.042-.76 14.56-2.279-13.894-2.669-25.598-9.562-35.115-20.697-9.519-11.136-14.277-23.84-14.277-38.114v-.571c10.085 4.755 19.602 7.229 28.549 7.422-17.321-11.613-25.981-28.265-25.981-49.963.0-10.66 2.758-20.747 8.278-30.264 15.035 18.464 33.311 33.213 54.816 44.252 21.507 11.038 44.54 17.227 69.092 18.558-.95-3.616-1.427-8.186-1.427-13.704.0-16.562 5.853-30.692 17.56-42.399 11.703-11.706 25.837-17.561 42.394-17.561 17.515.0 32.079 6.283 43.688 18.846 13.134-2.474 25.892-7.33 38.26-14.56-4.757 14.652-13.613 25.788-26.55 33.402 12.368-1.716 23.88-4.95 34.537-9.708C357.458 149.793 347.462 160.166 335.471 168.735z"/></g></svg></a></div><p class=copyright>© Copyright
2021
<span class=split><svg fill="#bbb" width="15" height="15" id="heart-15" xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 15 15"><path d="M13.91 6.75c-1.17 2.25-4.3 5.31-6.07 6.94-.1903.1718-.4797.1718-.67.0C5.39 12.06 2.26 9 1.09 6.75-1.48 1.8 5-1.5 7.5 3.45 10-1.5 16.48 1.8 13.91 6.75z"/></svg></span>Steve Sun</p><p class=powerby>Powered by <a href=http://www.gohugo.io/>Hugo</a> Theme By <a href=https://github.com/nodejh/hugo-theme-cactus-plus>nodejh</a></p></footer></body></html>