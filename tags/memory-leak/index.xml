<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Memory Leak on Steve Sun</title><link>https://sund.site/tags/memory-leak/</link><description>Recent content in Memory Leak on Steve Sun</description><generator>Hugo</generator><language>zh-CN</language><copyright>Copyright © 2013-2025, Steve Sun.</copyright><lastBuildDate>Tue, 27 Jun 2023 14:46:59 +0800</lastBuildDate><follow_challenge><feedId>41397727810093074</feedId><userId>56666701051455488</userId></follow_challenge><atom:link href="https://sund.site/tags/memory-leak/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 内存泄漏常见模式</title><link>https://sund.site/posts/2023/goroutine-leak/</link><pubDate>Tue, 27 Jun 2023 14:46:59 +0800</pubDate><guid>https://sund.site/posts/2023/goroutine-leak/</guid><description>&lt;p&gt;最近在工作中排查 Go 语言内存泄漏问题时，发现&lt;a href="https://www.uber.com/blog/leakprof-featherlight-in-production-goroutine-leak-detection/"&gt;这篇 Uber 写的博客&lt;/a&gt;，其中分享了几种常见的 goroutine 内存泄漏模式，于是把整理了 goroutine 的相关问题，希望更多人搜索到到这篇文章，帮助大家快速定位内存泄漏问题。&lt;/p&gt;
&lt;h2 id="goroutine-内存泄漏的原因"&gt;Goroutine 内存泄漏的原因&lt;/h2&gt;
&lt;p&gt;Go 语言的内存泄漏通常因为错误地使用 goroutine 和 channel。例如以下几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 goroutine 里打开一个连接（如 gRPC）但是忘记 close&lt;/li&gt;
&lt;li&gt;在 goroutine 里的全局变量对象没有释放&lt;/li&gt;
&lt;li&gt;在 goroutine 里读 channel， 但是没有写入端，而被阻塞&lt;/li&gt;
&lt;li&gt;在 goroutine 里写入无缓冲的 channel，但是由于 channel 的读端被其他协程关闭而阻塞&lt;/li&gt;
&lt;li&gt;在 goroutine 里写入有缓冲的 channel，但是 channel 缓冲已满&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这几种情况，通常掺杂在复杂的代码里逻辑里，很难调试发现问题。因此衍生出以下几种日常工作中&lt;strong&gt;最容易出现问题的模式&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="常见-goroutine-内存泄漏模式"&gt;常见 Goroutine 内存泄漏模式&lt;/h2&gt;
&lt;h3 id="premature-function-return-功能过早返回"&gt;Premature Function Return /功能过早返回&lt;/h3&gt;
&lt;p&gt;一个 goroutine 要写入 channel，但是在另一个端意外退出导致 channel 读取的代码没有执行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#fc5fa3"&gt;func&lt;/span&gt; &lt;span style="color:#41a1c0"&gt;Example&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; a := &lt;span style="color:#d0bf69"&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; c := &lt;span style="color:#d0a8ff"&gt;make&lt;/span&gt;(&lt;span style="color:#fc5fa3"&gt;chan&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;error&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;go&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; c &amp;lt;- err
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#6c7986"&gt;// do something&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;if&lt;/span&gt; a &amp;gt; &lt;span style="color:#d0bf69"&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#6c7986"&gt;// do something&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; err := &amp;lt;-c
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;代码中主进程在&lt;code&gt;if a &amp;gt; 0&lt;/code&gt; 处 return，导致 channel 无法写入而被阻塞。&lt;/p&gt;
&lt;p&gt;解决这种问题的一个思路是把无缓冲 channel 转化为缓冲大小为 1 的 channel。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;c := &lt;span style="color:#d0a8ff"&gt;make&lt;/span&gt;(&lt;span style="color:#fc5fa3"&gt;chan&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;error&lt;/span&gt;, &lt;span style="color:#d0bf69"&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;有缓冲 channel 即使没有读取操作，也不会阻塞。&lt;/p&gt;
&lt;h3 id="the-timeout-leak-超时泄漏"&gt;The Timeout Leak /超时泄漏&lt;/h3&gt;
&lt;p&gt;这是我们工作中遇到的问题，经常需要执行一个可能超时的异步操作时被使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#fc5fa3"&gt;func&lt;/span&gt; &lt;span style="color:#41a1c0"&gt;Example&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; timeoutOption := &lt;span style="color:#41a1c0"&gt;SomeTimeoutOption&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; done := &lt;span style="color:#d0a8ff"&gt;make&lt;/span&gt;(&lt;span style="color:#fc5fa3"&gt;chan&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;any&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;go&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; done &amp;lt;- result
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;select&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;case&lt;/span&gt; &amp;lt;- done:
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;case&lt;/span&gt; &amp;lt;- timeoutOption.&lt;span style="color:#41a1c0"&gt;Timeout&lt;/span&gt;():
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在这段代码里，一旦 timeoutOption 操作超时，就会通知 select，接着程序退出，于是 goroutine 写入 done 的操作被阻塞而无法退出。&lt;/p&gt;
&lt;p&gt;解决思路同上一个模式，用有缓冲 channel 替代无缓冲 channel。&lt;/p&gt;
&lt;h3 id="the-ncast-leak-多端读写泄漏"&gt;The NCast Leak /多端读写泄漏&lt;/h3&gt;
&lt;p&gt;如果 channel 的读端只有一个，但是写端有多个，就会发生这种情况。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#fc5fa3"&gt;func&lt;/span&gt; &lt;span style="color:#41a1c0"&gt;Example&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; c := &lt;span style="color:#d0a8ff"&gt;make&lt;/span&gt;(&lt;span style="color:#fc5fa3"&gt;chan&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;any&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;for&lt;/span&gt; _, i := &lt;span style="color:#fc5fa3"&gt;range&lt;/span&gt; items {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;go&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;func&lt;/span&gt;(c &lt;span style="color:#fc5fa3"&gt;chan&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;any&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; c &amp;lt;- result
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }(c)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; data := &amp;lt;- c
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种情况也适用于“多个写端一个读端”的情况，解决方法是把 channel 设置成和写或读数量一致的缓冲数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;c := &lt;span style="color:#d0a8ff"&gt;make&lt;/span&gt;(&lt;span style="color:#fc5fa3"&gt;chan&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;any&lt;/span&gt;, &lt;span style="color:#d0a8ff"&gt;len&lt;/span&gt;(items))
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id="channel-iteration-misuse-通道迭代误用"&gt;Channel Iteration Misuse /通道迭代误用&lt;/h3&gt;
&lt;p&gt;Go 支持一种特性 &lt;a href="https://gobyexample.com/range-over-channels"&gt;&amp;ldquo;Range over channels&amp;rdquo;&lt;/a&gt;, 可以用 range 来循环读取 channel 的内容。&lt;/p&gt;
&lt;p&gt;但是一旦读取不到内容，range 就会等待 channel 的写入，而 range 如果正好在 goroutine 内部，这个 goroutine 就会被阻塞。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#fc5fa3"&gt;func&lt;/span&gt; &lt;span style="color:#41a1c0"&gt;Example&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; wg := &amp;amp;sync.WaitGroup{}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; c := &lt;span style="color:#d0a8ff"&gt;make&lt;/span&gt;(&lt;span style="color:#fc5fa3"&gt;chan&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;any&lt;/span&gt;, &lt;span style="color:#d0bf69"&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;for&lt;/span&gt; _, i := items {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; wg.&lt;span style="color:#41a1c0"&gt;Add&lt;/span&gt;(&lt;span style="color:#d0bf69"&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;go&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; c &amp;lt;- data
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;go&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;func&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#fc5fa3"&gt;for&lt;/span&gt; data := &lt;span style="color:#fc5fa3"&gt;range&lt;/span&gt; c {
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; wg.&lt;span style="color:#41a1c0"&gt;Done&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; }()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; wg.&lt;span style="color:#41a1c0"&gt;Wait&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;解决这个问题的方式手动定义关闭 channel。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="color:#fff;background-color:#1f1f24;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;wg := &amp;amp;sync.WaitGroup{}
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;c := &lt;span style="color:#d0a8ff"&gt;make&lt;/span&gt;(&lt;span style="color:#fc5fa3"&gt;chan&lt;/span&gt; &lt;span style="color:#fc5fa3"&gt;any&lt;/span&gt;, &lt;span style="color:#d0bf69"&gt;1&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#fc5fa3"&gt;defer&lt;/span&gt; &lt;span style="color:#d0a8ff"&gt;close&lt;/span&gt;(c)
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#fd8f3f"&gt;//...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样在 WaitGroup 全部结束后，主程序会关闭 channel，从而让异步的 goroutine 内部的 range 退出循环等待。&lt;/p&gt;
&lt;h2 id="小结"&gt;小结&lt;/h2&gt;
&lt;p&gt;Goroutine 内存泄漏是 Go 语言最容易发生的内存泄漏情况，它通常伴随着错误地使用 goroutine 和 channel。而 channel 的特殊用法如 select 和 range 又让 channel 阻塞变得更加隐蔽不易发现，进而增加排查内存泄漏的难度。&lt;/p&gt;
&lt;p&gt;在写 goroutine 和调试内存泄漏问题时，要重点关注 channel 相关的操作，尤其涉及到文中列举的四类模式：功能过早返回、超时泄漏、多端读写泄漏、通道迭代误用。&lt;/p&gt;</description></item></channel></rss>