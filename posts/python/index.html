<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Steve Sun"><title>《Python源码剖析》第一部分——Python对象基础 ｜ 電波障害</title><meta name=description content="Python的对象初始化 在Python中，对象就是为C中的结构体在堆上申请的一块"><meta name=keywords content="Steve Sun,Notion,Develop,Programm,Coding,Note-taking,Book"><link rel="shortcut icon" href=https://sund.site/images/favicon.ico><link rel=stylesheet type=text/css media=screen href=https://sund.site/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css><link rel=stylesheet type=text/css media=screen href=https://sund.site/css/zozo.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css><link rel=stylesheet type=text/css media=screen href=https://sund.site/css/highlight.css></head><body><div class="main animate__animated animate__fadeInDown"><div class="nav_container animated fadeInDown"><div class=site_nav id=site_nav><ul><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></div><div class=menu_icon><a id=menu_icon><i class=ri-menu-line></i></a></div></div><div class="header animated fadeInDown"><div class=site_title_container><div class=site_title><h1><a href=https://sund.site/><span>電波障害</span></a></h1></div><div class=description><p class=sub_title>Steve Sun, full-stack developer</p><div class=my_socials><a href=https://github.com/stevedsun title=github target=_blank><i class=ri-github-fill></i></a><a href=https://twitter.com/way2steve title=twitter target=_blank><i class=ri-twitter-fill></i></a><a href=https://sund.site/index.xml type=application/rss+xml title=rss target=_blank><i class=ri-rss-fill></i></a></div></div></div></div><div class=content><div class=post_page><div class="post animate__animated animate__fadeInDown"><div class="post_title post_detail_title"><h2><a href=/posts/python/>《Python源码剖析》第一部分——Python对象基础</a></h2><span class=date>2017.07.12</span></div><div class="post_content markdown"><h2 id=python的对象初始化>Python的对象初始化</h2><blockquote><p>在Python中，对象就是为C中的结构体在堆上申请的一块内存，一般来说，对象是不能被静态初始化的，并且也不能在栈空间上生存。唯一的例外就是类型对象，Python中所有的内建的类型对象（如整数类型对象，字符串类型对象）都是被静态初始化的。</p></blockquote><p>python 的对象不像 C 是分配在栈、堆、data segment等位置，而是全部分配在堆上！只有python内置类型在初始化时候才是被C语言层静态初始化。</p><p>PyObject内部就两样：引用计数器、类型对象指针。</p><p>类型对象的定义：</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_typeobject</span> <span class=p>{</span>
    <span class=n>PyObject_VAR_HEAD</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>tp_name</span><span class=p>;</span> <span class=cm>/* For printing, in format &#34;&lt;module&gt;.&lt;name&gt;&#34; */</span>
    <span class=kt>int</span> <span class=n>tp_basicsize</span><span class=p>,</span> <span class=n>tp_itemsize</span><span class=p>;</span> <span class=cm>/* For allocation */</span>

    <span class=cm>/* Methods to implement standard operations */</span>
    <span class=n>destructor</span> <span class=n>tp_dealloc</span><span class=p>;</span>
    <span class=n>printfunc</span> <span class=n>tp_print</span><span class=p>;</span>
    <span class=err>……</span>
    <span class=cm>/* More standard operations (here for binary compatibility) */</span>
    <span class=n>hashfunc</span> <span class=n>tp_hash</span><span class=p>;</span>
    <span class=n>ternaryfunc</span> <span class=n>tp_call</span><span class=p>;</span>
    <span class=err>……</span>
<span class=p>}</span> <span class=n>PyTypeObject</span><span class=p>;</span>
</code></pre></div><p><code>PyObject_VAR_HEAD</code>是可变类型的头信息，其中除了<code>PyObject_HEAD</code>的内容外，额外添加了一个代表该对象元素数量的整型。从上边代码可见，python的类型也是一个可变对象。</p><h2 id=python的多态>Python的多态</h2><p>Python中所有类型在初始化后，在C语言层面都使用同一种指针<code>PyObject *</code>，所以python实现多态就非常容易。任何函数的参数都是一个PyObject类型指针，也就不存在编译器需要判断函数参数类型。</p><h2 id=python对象内存池>Python对象内存池</h2><p>Python为了避免频繁的释放对象，采用了内存池的机制，在对象引用计数为0时，不会释放内存，而是将内存交还给内存池供python重新分配使用。<strong>每一种python类型，都有特定的内存池机制。</strong></p><h2 id=整数对象>整数对象</h2><p>-5至257之间的小整数，存储在「小整数数组」里，这个数组Python自动创建，每次创建一个小整数，就指向这个数组里对应的PyIntObject值并把PyIntObject的计数加1。(因此在-5到257之间的数实际指向同一片内存空间，整数-5和-5的内存地址肯定是一样的)</p><p>大整数则由一个叫<code>block_list</code>的链表管理，每次分配一个大整数就在<code>free_list</code>(一个指向空闲内存block的指针)里拿出一个节点并把<code>free_list</code>后移一个<code>block</code>。关于<code>free_list</code>是如何把尚未分配的内存和已被释放的内存链接起来的，可以参见书中113页的插图理解。</p><p>值得注意的是，python用于分配给整型的堆内存是不会自行销毁的，而是不断复用。也就是说，<strong>同一时间如果同时使用的整型太多，会消耗大量内存，并且这些内存在python关闭之前一直被python持有着。</strong></p><h2 id=字符串对象>字符串对象</h2><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
    <span class=n>PyObject_VAR_HEAD</span>
    <span class=kt>long</span> <span class=n>ob_shash</span><span class=p>;</span>
    <span class=kt>int</span> <span class=n>ob_sstate</span><span class=p>;</span>
    <span class=kt>char</span> <span class=n>ob_sval</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>
<span class=p>}</span> <span class=n>PyStringObject</span><span class=p>;</span>
</code></pre></div><p>在Python源码中的注释显示，预存字符串的hash值(为了节省字符串比较的时间)和这里的intern机制将Python虚拟机的执行效率提升了20%。</p><p><strong>intern机制</strong> 将新建的字符串缓存在一个PyDictObject里，相同的字符串共用同一内存。</p><p>单一字符的字符串，除了用intern缓存外，还会缓存在系统自带的一个字符串缓冲池里：</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=n>PyStringObject</span> <span class=o>*</span><span class=n>characters</span><span class=p>[</span><span class=n>UCHAR_MAX</span> <span class=o>+</span> <span class=mi>1</span><span class=p>];</span> 
</code></pre></div><p><strong><code>+</code>操作符和<code>join</code>的效率问题</strong> <code>+</code>连接n个操作符会创建n-1次临时空间，<code>join</code>会直接处理一个list里的字符串，只分配一次内存。节省开销。</p><h2 id=列表对象>列表对象</h2><p>参见C++ vector对象的存储方式。</p><h2 id=字典对象>字典对象</h2><p>Python使用散列表(时间复杂度O(1))而非红黑树(时间复杂度O(logN))来存储map结构。</p><p>**Hash冲突(碰撞)**不同的值映射到相同的键时，就产生了冲突。一般解决办法有：</p><ul><li><p>开链法(哈希桶)：
<img src=https://i.loli.net/2021/03/05/bQuAwlOTUIXkJ7x.gif alt></p></li><li><p>开放定址法：
hash一次没有命中就再hash一次，直到找到为止……(二次探测)</p></li></ul><p>小于8个元素的Dict，python使用PyDIctObject内部的smalltable数组保存元素内容。</p><p>PyDictObject对String类型的key做了特殊对待——简化了计算hash函数的过程(正常情况下key值是一个<code>PyObject *</code>对象，需要做大量类型判断，但是对PyStringObject就省了)。</p><p>**装载率(使用的空间/预先分配的空间)**大于2/3时，hash冲突的概率会急速升高，这时python就会动态分配更多的空间。与其他类型一样，如果装载率太小，也会自动缩减分配的空间。</p><blockquote><p>在确定新的table的大小时，通常选用的策略是时新的table中entry的数量是现在table中Active态entry数量的4倍，选用4倍是为了使table中处于Active态的entry的分布更加稀疏，减少插入元素时的冲突概率……所以当table中Active态的entry数量非常大时，Python只会要求2倍的空间，这次又是以执行速度来交换内存空间。</p></blockquote><p>注意这段话，执行速度和内存大小是反比关系，划分的空间越大，执行一次查找就越费时，所以分配的内存空间不是越大越好。</p><p>PyDictObject也使用了同PyListObject一样的缓冲池方式。参考列表对象部分内容。</p><p><em><strong>笔者总结：从上面的各种类型的处理规律可以总结出Python遵循的原则：小变量缓存，大变量尽量整块分配内存，回收变量时不释放内存而是尽量复用，预分配的空间既要满足需要又不能太大(太大就缩减)</strong></em></p></div><div class=post_footer><div class=meta><div class=info><span class="field tags"><i class=ri-stack-line></i><a href=https://sund.site/tags/python/>python</a></span></div></div></div></div><div class=doc_comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"v2steve"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><a id=back_to_top href=# class=back_to_top><i class=ri-arrow-up-s-line></i></a><footer class=footer><div class=footer_slogan><span></span></div></footer><script src=https://sund.site/js/jquery-3.5.1.min.js></script><link href=https://sund.site/css/fancybox.min.css rel=stylesheet><script src=https://sund.site/js/fancybox.min.js></script><script src=https://sund.site/js/zozo.js></script><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\[\[','\]\]']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-64688885-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>