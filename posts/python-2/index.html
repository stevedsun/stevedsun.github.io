<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Steve Sun"><title>《Python源码剖析》第二部分——Python虚拟机基础 ｜ 電波障害</title><meta name=description content="Python执行环境 在编译过程中，这些包含在Python源代码中的静态信息都会被"><meta name=keywords content="Steve Sun,Notion,Develop,Programm,Coding,Note-taking,Book"><link rel="shortcut icon" href=https://sund.site/images/favicon.ico><link rel=stylesheet type=text/css media=screen href=https://sund.site/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css><link rel=stylesheet type=text/css media=screen href=https://sund.site/css/zozo.css><link rel=stylesheet type=text/css media=screen href=https://cdn.jsdelivr.net/npm/remixicon@2.5.0/fonts/remixicon.css><link rel=stylesheet type=text/css media=screen href=https://sund.site/css/highlight.css></head><body><div class="main animate__animated animate__fadeInDown"><div class="nav_container animated fadeInDown"><div class=site_nav id=site_nav><ul><li><a href=/>Home</a></li><li><a href=/posts/>Archive</a></li><li><a href=/tags/>Tags</a></li><li><a href=/about/>About</a></li></ul></div><div class=menu_icon><a id=menu_icon><i class=ri-menu-line></i></a></div></div><div class="header animated fadeInDown"><div class=site_title_container><div class=site_title><h1><a href=https://sund.site/><span>電波障害</span></a></h1></div><div class=description><p class=sub_title>Steve Sun, a full-stack developer</p><div class=my_socials><a href=https://github.com/stevedsun title=github target=_blank><i class=ri-github-fill></i></a><a href=https://twitter.com/way2steve title=twitter target=_blank><i class=ri-twitter-fill></i></a><a href=https://sund.site/index.xml type=application/rss+xml title=rss target=_blank><i class=ri-rss-fill></i></a></div></div></div></div><div class=content><div class=post_page><div class="post animate__animated animate__fadeInDown"><div class="post_title post_detail_title"><h2><a href=/posts/python-2/>《Python源码剖析》第二部分——Python虚拟机基础</a></h2><span class=date>2017.07.13</span></div><div class="post_content markdown"><h2 id=python执行环境>Python执行环境</h2><blockquote><p>在编译过程中，这些包含在Python源代码中的静态信息都会被Python编译器收集起来，编译的结果中包含了字符串，常量值，字节码等在源代码中出现的一切有用的静态信息。在Python运行期间，这些源文件中提供的静态信息最终会被存储在一个运行时的对象中，当Python运行结束后，这个运行时对象中所包含的信息甚至还会被存储在一种文件中。这个对象和文件就是我们这章探索的重点：PyCodeObject对象和pyc文件。</p></blockquote><blockquote><p>在程序运行期间，编译结果存在于内存的PyCodeObject对象中；而Python结束运行后，编译结果又被保存到了pyc文件中。当下一次运行相同的程序时，Python会根据pyc文件中记录的编译结果直接建立内存中的PyCodeObject对象，而不用再次对源文件进行编译了。</p></blockquote><p>从文章摘录可见，python生成的不是编译后的文件，而是<code>.py</code>文件对应的静态信息——PyCodeObject，这里包括了字节码指令序列、字符串、常量。每个名字空间(类、模块、函数)都对应一个独立的PyCodeObject。(python连编译后的文件里存的都是个对象！)</p><p>不被import的py文件不会生成pyc。标准库里有py_compile等方法也可以生成pyc。</p><p><strong>import机制</strong> 导入某个模块时，先查找对应的pyc，如果没有pyc就生成然后import这个pyc。(所以实际导入的并不是py文件，而是py文件编译后的PyCodeObject)。</p><p><strong>PyFrameObject</strong> Python程序运行时的「执行环境」。参考操作系统执行可执行文件的过程。Python也是将函数对应的执行环境封装成栈帧的形式加载进内存。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=k>struct</span> <span class=n>_frame</span> <span class=p>{</span>
    <span class=n>PyObject_VAR_HEAD</span>
    <span class=k>struct</span> <span class=n>_frame</span> <span class=o>*</span><span class=n>f_back</span><span class=p>;</span>  <span class=c1>//执行环境链上的前一个frame
</span><span class=c1></span>    <span class=n>PyCodeObject</span> <span class=o>*</span><span class=n>f_code</span><span class=p>;</span>   <span class=c1>//PyCodeObject对象
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>*</span><span class=n>f_builtins</span><span class=p>;</span>   <span class=c1>//builtin名字空间
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>*</span><span class=n>f_globals</span><span class=p>;</span>    <span class=c1>//global名字空间
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>*</span><span class=n>f_locals</span><span class=p>;</span>     <span class=c1>//local名字空间
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>**</span><span class=n>f_valuestack</span><span class=p>;</span>    <span class=c1>//运行时栈的栈底位置
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>**</span><span class=n>f_stacktop</span><span class=p>;</span>      <span class=c1>//运行时栈的栈顶位置
</span><span class=c1></span>    <span class=err>……</span>
    <span class=kt>int</span> <span class=n>f_lasti</span><span class=p>;</span>        <span class=c1>//上一条字节码指令在f_code中的偏移位置
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>f_lineno</span><span class=p>;</span>       <span class=c1>//当前字节码对应的源代码行
</span><span class=c1></span>    <span class=err>……</span>
    <span class=c1>//动态内存，维护（局部变量+cell对象集合+free对象集合+运行时栈）所需要的空间
</span><span class=c1></span>    <span class=n>PyObject</span> <span class=o>*</span><span class=n>f_localsplus</span><span class=p>[</span><span class=mi>1</span><span class=p>];</span>  
<span class=p>}</span> <span class=n>PyFrameObject</span><span class=p>;</span>
</code></pre></div><p>Python标准库的<code>sys._getframe()</code>可以动态的在程序执行时获取当前内存中活跃的PyFrameObject信息。</p><h2 id=legb-规则>LEGB 规则</h2><p>即python作用域的查找顺序是<code>local</code>-<code>enclosing</code>-<code>global</code>-<code>buildin</code>。看下面代码：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=n>a</span> <span class=o>=</span> <span class=mi>1</span>

<span class=k>def</span> <span class=nf>g</span><span class=p>():</span>
  <span class=k>print</span> <span class=n>a</span>

<span class=k>def</span> <span class=nf>f</span><span class=p>():</span>
  <span class=k>print</span> <span class=n>a</span> <span class=o>//</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
  <span class=n>a</span> <span class=o>=</span> <span class=mi>2</span> <span class=o>//</span><span class=p>[</span><span class=mi>2</span><span class=p>]</span>
  <span class=k>print</span> <span class=n>a</span>

<span class=n>g</span><span class=p>()</span>
</code></pre></div><p>代码在[1]处会抛出异常，原因是python在编译阶段就把静态数据(局部变量、全局变量、字节码)放入pyc里，执行到<code>f()</code>里时，查找到<code>a</code>是在local作用域里定义的而不是global里，但是此时local的a还没赋值，所以就会抛出异常。由此可见，<strong>python作用域信息是在静态编译时就处理好了的</strong>。</p><h2 id=python-虚拟机运行框架>Python 虚拟机运行框架</h2><blockquote><p>运行时环境是一个全局的概念，而执行环境实际就是一个栈帧，是一个与某个Code Block对应的概念。</p></blockquote><blockquote><p>在PyCodeObject对象的co_code域中保存着字节码指令和字节码指令的参数，Python虚拟机执行字节码指令序列的过程就是从头到尾遍历整个co_code、依次执行字节码指令的过程。</p></blockquote><p>由上文引用可见，python在编译阶段将代码块的字节码保存在PyCodeObject的co_code属性里，然后在执行阶段从头到尾遍历这个co_code属性解读字节码。</p><p><strong>Python运行时环境</strong> Python在运行时用PyInterpreterState结构维护进程运行环境，PyThreadState维护线程运行环境，PyFrameObject维护栈帧运行环境，三者是依次包含关系，如下图所示：</p><p><img src=https://i.loli.net/2021/03/05/GHImB214fvxSXgk.png alt></p><p>Python虚拟机就是一个「软CPU」，动态加载上述三种结构进内存，并模拟操作系统执行过程。程序执行后，先创建各个运行时环境，再将栈帧中的字节码载入，循环遍历解释执行。</p><h2 id=python字节码>Python字节码</h2><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>i</span> <span class=o>=</span> <span class=mi>1</span>
<span class=mi>0</span>   <span class=n>LOAD_CONST</span>   <span class=mi>0</span>  <span class=p>(</span><span class=mi>1</span><span class=p>)</span>
<span class=mi>3</span>   <span class=n>STORE_NAME</span>   <span class=mi>0</span>  <span class=p>(</span><span class=n>i</span><span class=p>)</span>
</code></pre></div><p>例如python的一条语句<code>i=1</code>可以解释为下面两行字节码，最左边的第1列数字代表这行字节码在内存中的偏移位置，第2列是字节码的名字(CPU并不关心名字，它只是根据偏移量读出字节码，所以这个名字是方便阅读用的)，第3列是字节码的参数，如<code>LOAD_CONST</code>对应的数据在变量<code>f->f_code->co_consts</code>里，0就是这个参数位于<code>f->f_code->co_consts</code>的偏移量。最后一列的括号里是从参数里取到的value。</p><h2 id=python-的异常抛出机制>Python 的异常抛出机制</h2><p>异常处理的操作都在<code>Python/traceback.c</code>文件里，python每次调用一层函数，就创建改函数对应的PyFrameObject对象来保存函数运行时信息，PythonFrameObject里调用PyEval_EvalFrameEx循环解释字节码，如果抛出异常就创建PyTraceBackObject对象，将对象交给上一层PyFrameObject里的PyTracebackObject组成链表，最后返回最上层PyRun_SimpleFileExFlags函数，该函数调用PyErr_Print遍历PyTraceBackObject链表打印出异常信息。</p><p><img src=https://i.loli.net/2021/03/05/9bEUBjYov8mZy3s.jpg alt></p><h2 id=函数对象的实现>函数对象的实现</h2><p>PyFunctionObject是函数对象。在python调用函数时，生成PyFunctionObject对象，该对象的f_global指针用来将外层的全局变量传递给函数内部，然后在<code>ceval.c</code>文件的<code>fast_function</code>里解出PyFunctionObject对象里携带的信息，创建新的PyFrameObject对象(上文说过这个对象是维护运行时环境的)，最后调用执行字节码的函数<code>PyEval_EvalFrameEx</code>执行真正函数字节码。</p><p><strong>Python执行一段代码需要什么？</strong> 从书中描述可见，python执行一段代码需要做几件事：</p><ul><li>从源码编译出 PyCodeObject 保存变量和字节码</li><li>执行阶段，从PyCodeObject里取出信息交给 PyFrameObject，执行 PyEval_EvalFrameEx 解释字节码</li><li>如果遇到函数调用，就把函数对应的代码段从 PyCodeObject 存入 PyFunctionObject 对象，然后把这个函数对象通过参数传给新创建的 PyFrameObject ，在内层空间执行 PyEval_EvalFrameEx 解释字节码</li><li>将结果或异常存入 PyFrameObject 的变量( 异常是存入f_blockstack里，外层判断f_blockstack里的数据是被except捕获还是没有捕获而继续下一步操作) 抛给外层</li></ul><p>值得注意的是，<strong>python在执行阶段，将对函数参数的键值查找，转换为索引查找</strong>，即在转换PyCodeObject为PyFrameObject时，将参数信息按位置参数、键参数按照一定顺序存储在f_localsplus变量中，再用索引来查找对应参数，而需要查找键值。这样提高了运行时效率。下图是<code>foo('Rboert', age=5)</code>在内存中的存储形式。</p><p><img src=https://i.loli.net/2021/03/05/IGy8JTzZpgmN6sL.jpg alt></p><h2 id=闭包的实现>闭包的实现</h2><p>Python在编译阶段就把函数闭包内层和闭包外层使用的变量存入PyCodeObject中：</p><ul><li>co_cellvars：通常是一个tuple，保存嵌套的作用域中使用的变量名集合；</li><li>co_freevars：通常也是一个tuple，保存使用了的外层作用域中的变量名集合。</li></ul><p>在执行阶段，PyFrameObject的f_localsplus中也为闭包的变量划分的内存区域，如下图所示：</p><p><img src=https://i.loli.net/2021/03/05/fUB4wC36dAc7rqt.jpg alt></p><h2 id=元类>元类</h2><p>元类<code>&lt;type type></code>和其他类的关系如下图：</p><p><img src=https://i.loli.net/2021/03/05/N76woqSlmR28Oyt.jpg alt></p><p><strong>可调用性（callable）</strong> ，只要一个对象对应的class对象中实现了“<strong>call</strong>”操作（更确切地说，在Python内部的PyTypeObject中，tp_call不为空）那么这个对象就是一个可调用的对象，换句话说，在Python中，所谓“调用”，就是执行对象的type所对应的class对象的tp_call操作。</p><h2 id=descriptor>Descriptor</h2><blockquote><p>在PyType_Ready中，Python虚拟机会填充tp_dict，其中与操作名对应的是一个个descriptor
对于一个Python中的对象obj，如果obj.__ class__对应的class对象中存在__get__、__set__和__delete__三种操作，那么obj就可称为Python一个descriptor。</p></blockquote><blockquote><p>如果细分，那么descriptor还可分为如下两种：</p></blockquote><ol><li>data descriptor : type中定义了__get__和__set__的descriptor；</li><li>non data descriptor : type中只定义了__get__的descriptor。
在Python虚拟机访问instance对象的属性时，descriptor的一个作用是影响Python虚拟机对属性的选择。从PyObject_GenericGetAttr的伪代码可以看出，Python虚拟机会在instance对象自身的__dict__中寻找属性，也会在instance对象对应的class对象的mro列表中寻找</li></ol><blockquote><ol><li>Python虚拟机按照instance属性、class属性的顺序选择属性，即instance属性优先于class属性；</li><li>如果在class属性中发现同名的data descriptor，那么该descriptor会优先于instance属性被Python虚拟机选择</li></ol></blockquote><p><img src=https://i.loli.net/2021/03/05/1xKk3IVPdjWb8iB.jpg alt></p><h3 id=引申python-黑魔法-descriptor-描述器>引申：Python 黑魔法 Descriptor (描述器)</h3><ul><li><a href=http://www.jianshu.com/p/250f0d305c35>http://www.jianshu.com/p/250f0d305c35</a></li><li><a href=http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html>http://pyzh.readthedocs.io/en/latest/Descriptor-HOW-TO-Guide.html</a></li></ul><h2 id=bound-method和unbound-method>Bound Method和Unbound Method</h2><p>假设有下面两种对类方法的调用：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=k>class</span> <span class=nc>A</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
    <span class=k>def</span> <span class=nf>f</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=k>pass</span>

<span class=n>a</span> <span class=o>=</span> <span class=n>A</span><span class=p>()</span>
<span class=c1># [1]</span>
<span class=n>a</span><span class=o>.</span><span class=n>f</span><span class=p>()</span>  

<span class=c1># [2]</span>
<span class=n>A</span><span class=o>.</span><span class=n>f</span><span class=p>(</span><span class=n>a</span><span class=p>)</span>

<span class=c1># [3]</span>
<span class=n>func</span> <span class=o>=</span> <span class=n>a</span><span class=o>.</span><span class=n>f</span>
<span class=n>func</span><span class=p>()</span>
</code></pre></div><p>在代码[1]里，实例a调用类方法f，python底层会自动完成实例a和类方法f之间的绑定动作(调用<code>func_ descr_get(A.f, a, A)</code>，将实例地址和函数对象PyFunctionObject封装到一个PyMethodObject)，而代码[2]里直接通过A调用，则f为非绑定的PyMethodObject，里面没有实例信息，需要传入a。</p><p>比较绑定方法与非绑定方法可知，通过[1]的方式每次都要绑定一次实例，开销非常大，下图比较的是[1]和[3]两种方式，绑定操作的执行次数。</p><p><img src=https://i.loli.net/2021/03/05/TpCcdaYmHlQnXzE.jpg alt></p><p>结论： <strong>调用类实例绑定的方法时，如果方法执行次数非常多，最好将方法赋值给一个变量，防止重复绑定增加开销</strong></p></div><div class=post_footer><div class=meta><div class=info><span class="field tags"><i class=ri-stack-line></i><a href=https://sund.site/tags/python/>python</a></span></div></div></div></div><div class=doc_comments><div id=disqus_thread></div><script type=application/javascript>var disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById('disqus_thread').innerHTML='Disqus comments not available by default when the website is previewed locally.';return;}
var d=document,s=d.createElement('script');s.async=true;s.src='//'+"v2steve"+'.disqus.com/embed.js';s.setAttribute('data-timestamp',+new Date());(d.head||d.body).appendChild(s);})();</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div></div></div></div><a id=back_to_top href=# class=back_to_top><i class=ri-arrow-up-s-line></i></a><footer class=footer><div class=footer_slogan><span></span></div></footer><script src=https://sund.site/js/jquery-3.5.1.min.js></script><link href=https://sund.site/css/fancybox.min.css rel=stylesheet><script src=https://sund.site/js/fancybox.min.js></script><script src=https://sund.site/js/zozo.js></script><script type=text/javascript async src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML">MathJax.Hub.Config({tex2jax:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\[\[','\]\]']],processEscapes:true,processEnvironments:true,skipTags:['script','noscript','style','textarea','pre'],TeX:{equationNumbers:{autoNumber:"AMS"},extensions:["AMSmath.js","AMSsymbols.js"]}}});MathJax.Hub.Queue(function(){var all=MathJax.Hub.getAllJax(),i;for(i=0;i<all.length;i+=1){all[i].SourceElement().parentNode.className+=' has-jax';}});</script><style>code.has-jax{font:inherit;font-size:100%;background:inherit;border:inherit;color:#515151}</style><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-64688885-1','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script></body></html>