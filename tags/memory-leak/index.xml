<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>memory leak on Steve Sun</title><link>https://sund.site/tags/memory-leak/</link><description>Recent content in memory leak on Steve Sun</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 27 Jun 2023 14:46:59 +0800</lastBuildDate><atom:link href="https://sund.site/tags/memory-leak/index.xml" rel="self" type="application/rss+xml"/><item><title>Go 内存泄漏常见模式</title><link>https://sund.site/posts/2023/goroutine-leak/</link><pubDate>Tue, 27 Jun 2023 14:46:59 +0800</pubDate><guid>https://sund.site/posts/2023/goroutine-leak/</guid><description>最近在工作中排查 Go 语言内存泄漏问题时，发现这篇 Uber 写的博客，其中分享了几种常见的 goroutine 内存泄漏模式，于是把整理了 goroutine 的相关问题，希望更多人搜索到到这篇文章，帮助大家快速定位内存泄漏问题。
Goroutine 内存泄漏的原因 Go 语言的内存泄漏通常因为错误地使用 goroutine 和 channel。例如以下几种情况：
在 goroutine 里打开一个连接（如 gRPC）但是忘记 close 在 goroutine 里的全局变量对象没有释放 在 goroutine 里读 channel， 但是没有写入端，而被阻塞 在 goroutine 里写入无缓冲的 channel，但是由于 channel 的读端被其他协程关闭而阻塞 在 goroutine 里写入有缓冲的 channel，但是 channel 缓冲已满 这几种情况，通常掺杂在复杂的代码里逻辑里，很难调试发现问题。因此衍生出以下几种日常工作中最容易出现问题的模式。
常见 Goroutine 内存泄漏模式 Premature Function Return /功能过早返回 一个 goroutine 要写入 channel，但是在另一个端意外退出导致 channel 读取的代码没有执行。
func Example() { a := 1 c := make(chan error) go func() { c &amp;lt;- err return }() // do something if a &amp;gt; 0 { return } // do something err := &amp;lt;-c } 代码中主进程在if a &amp;gt; 0 处 return，导致 channel 无法写入而被阻塞。</description></item></channel></rss>